\section{A General Framework}
\label{sec:a-general-framework}

%In this section 
We now present our framework for algebraically
indexed types. % and representation independence. %We define the syntax
%and semantics of algebraically indexed types, then their semantics
%and finally we present a general programming language for
%algebraically indexed types, together with an abstraction theorem.

\subsection{Algebraically-Indexed Types}
\label{sec:algebraically-indexed-types}

The index expressions and types of an instantiation of our general
framework are derived from the following data:
\begin{enumerate}
\item A collection $\SortSet$ of index sorts. We use the
  meta-syntactic variables $s,s_1,s_2,...$ for arbitrary sorts taken
  from $\SortSet$.
\item A collection $\IndexOpSet$ of index operations, with a function
  $\indexOpArity : \IndexOpSet \to \SortSet^* \times \SortSet$. (We use
  the notation $A^*$ to denote the set of lists of elements of some
  set $A$.)
\item A collection $\PrimTypeSet$ of primitive types, with a function
  $\primTyArity : \PrimTypeSet \to \SortSet^*$. %, describing the sorts
%  of the arguments of each primitive type.
\end{enumerate}

\begin{example}[Two-Dimensional Geometry]
  \label{ex:two-dim-geo-operations}
  The two-dimensional geometry system has a sort for each of the
  geometric groups mentioned in \autoref{sec:motivating-examples}, so
  $\SortSet = \{\SynTransl{2}, \SynGL{2}, \SynOrth{2}, \SynGL{1} \}$.
  %For the index operations, 
  We have additive group structure on $\SynTransl{2}$, multiplicative
  group structure on $\SynGL{1}$, $\SynGL{2}$, and $\SynOrth{2}$,
  injections from $\SynOrth{2}$ and $\SynGL{1}$ into $\SynGL{2}$,
  determinant, and absolute value. Thus, $\IndexOpSet = \{ 0, +, -,
  1_G, -\cdot_G-, -^{-1_G}, \iota_O, \iota_1, \det, \abs{\cdot} \}$, where
  $G \in \{\SynGL{1}, \SynGL{2}, \SynOrth{2}\}$, and
  %  with the following assignment of arities:
  \begin{displaymath}
    \begin{array}{@{}l@{\hspace{0em}=\hspace{0em}}l@{\hspace{0.5em}}l@{\hspace{0em}=\hspace{0em}}l}
      \indexOpArity(0) & ([], \SynTransl{2}) &
      \indexOpArity(1_G) & ([], G) \\
      \indexOpArity(+) & ([\SynTransl{2}, \SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(\cdot_G) & ([G,G],G) \\
      \indexOpArity(-) & ([\SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(^{-1_G}) & ([G], G) \\
      \indexOpArity(\iota_o) & ([\SynOrth{2}], \SynGL{2}) &
      \indexOpArity(\iota_1) & ([\SynGL{1}], \SynGL{2}) \\
      \indexOpArity(\det) & ([\SynGL{2}], \SynGL{1}) &
      \indexOpArity(\abs{\cdot}) & ([\SynGL{1}], \SynGL{1})
    \end{array}
  \end{displaymath}
%  The intended interpretations of the top three pairs of operations
%  are group unit, group combination and group negation,
%  respectively. 
%  When we discuss equational theories on index expressions 
%in \autoref{sec:type-equality} 
%we will impose the (abelian) group laws. For this example, 
We also have $\PrimTypeSet = \{ \tyPrimNm{vec},
  \tyPrimNm{real} \}$, with $\primTyArity(\tyPrimNm{vec}) =
           [\SynGL{2}, \SynTransl{2}]$ and
           $\primTyArity(\tyPrimNm{real}) = [\SynGL{1}]$.
\end{example}

We assume a countably infinite collection of index variable names $i,
i_1, i_2,\ldots$. \emph{Index contexts} $\Delta = i_1 \mathord: s_1,
..., i_n \mathord: s_n$ are lists of variable/sort pairs such that
all the variable names are distinct.
\begin{figure*}[t]
  \centering
  % \textbf{Index contexts}\\

  % $\Delta = i_1 \mathord: s_1, ..., i_n \mathord: s_n$, where each $s_i \in \SortSet$ and no variable name is repeated.

  % \bigskip

  {\small
  \textbf{Well-sorted index expressions}
  \begin{mathpar}
    \inferrule* [right=IVar]
    {i : s \in \Delta}
    {\Delta \vdash i : s}
    
    \inferrule* [right=IOp]
    {\indexOp{f} \in \mathit{IndexOp} \\
      \indexOpArity(\indexOp{f}) = ([s_1,...,s_n], s) \\
      \{\Delta \vdash e_j : s_j\}_{1 \leq j \leq n}}
    {\Delta \vdash \indexOp{f}(e_1, ..., e_n) : s}
  \end{mathpar}

  \smallskip

  \textbf{Well-indexed types}
  \begin{mathpar}
    \inferrule* [right=TyPrim]
    {\tyPrimNm{X} \in \mathit{PrimType} \\\\
      \primTyArity(\tyPrimNm{X}) = [s_1,...,s_n] \\
      \{\Delta \vdash e_j : s_j\}_{1\leq j \leq n}}
    {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \isType}

    \inferrule* [right=TyUnit]
    { }
    {\Delta \vdash \tyUnit \isType}

    \inferrule* [right=TyArr]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyArr B \isType}

    \inferrule* [right=TyTuple]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyProduct B \isType}

    \inferrule* [right=TySum]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A + B \isType}
    
    \inferrule* [right=TyForall] %FIXME: macroize forall
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \forall i \mathord: s. A \isType}

    \inferrule* [right=TyEx]
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \exists i \mathord: s. A \isType}
  \end{mathpar}}
  \caption{Index expressions and types}
  \label{fig:indexes-and-types}
\end{figure*}
%Given the above data, 
The rules in \autoref{fig:indexes-and-types}
generate two judgements: well-sorted index expressions $\Delta \vdash
e : s$ and well-indexed types $\Delta \vdash A \isType$. Since index
variables may appear in types, types are judged to be well-indexed
with respect to an index context $\Delta$. The rules for well-sorted
index expressions are particularly simple. %: either an index expression
%is a variable that appears in the context (rule \TirName{IVar}), or it
%is an application of an index operation taken from $\IndexOpSet$ to
%other index expressions (rule \TirName{IOp}). 
The rules for well-indexed types include the usual ones
%rules 
for
%constructing types of 
the simply-typed $\lambda$-calculus with unit, sum and tuple types
(rules \TirName{TyUnit}, \TirName{TyArr}, \TirName{TyTuple} and
\TirName{TySum}). 
We use $\tyPrimNm{bool}$ as an abbreviation for $\tyPrimNm{unit} + \tyPrimNm{unit}$.
The rule \TirName{TyPrim} %allows us to 
forms, from a primitive type $\tyPrimNm{X}$ and appropriately sorted
index expressions $e_1,...,e_n$, the well-indexed type
$\tyPrim{X}{e_1,...,e_n}$. The rule \TirName{TyForall} 
%permits the formation of 
forms universally quantified types, where the universal
quantification ranges over all index expressions of some
sort. Existential types, %are constructed 
formed using the \TirName{TyEx} rule,
%and 
allow for abstraction by hiding. %FIXME: think about the
%introduction of existentials more, perhaps forward ref to their use
We say that a type is \emph{quantifier-free} if it does not contain
ether universal or existential quantification.

\subsubsection{Simultaneous Substitution of Index Expressions}
\label{sec:simultaneous-substitution}

It %will be technically 
is convenient to express substitution of index
expressions %in our framework 
in terms of simultaneous substitutions.
Given a pair of index contexts $\Delta$ and $\Delta' = i_1 \mathord:
s_1, ..., i_n \mathord: s_n$, a \emph{simultaneous substitution}
$\Delta \vdash \sigma \Rightarrow \Delta'$ is a sequence of
expressions $\sigma = (e_1,...,e_n)$ such that $\Delta \vdash e_j :
s_j$ for all $1 \leq j \leq n$. Given a simultaneous substitution
$\Delta \vdash \sigma = (e_1,...,e_n) \Rightarrow \Delta'$ and a
variable $i_j \mathord: s_j$ in $\Delta'$, we write $\sigma(i_j)$ for
the index expression $e_j$. We write $\Delta \Rightarrow \Delta'$ for
the set of all simultaneous substitutions $\sigma$ such that $\Delta
\vdash \sigma \Rightarrow \Delta'$.
%
%It will be useful to 
We can think of any sequence of sorts as an index
context. In particular, we will make use of simultaneous substitutions
of the form $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$, since these are exactly sequences of
index arguments suitable for the primitive type $\tyPrimNm{X}$. By
further abuse of notation, we write $\Delta \Rightarrow
\primTyArity(\tyPrimNm{X})$ for the set of all simultaneous
substitutions $\sigma$ such that $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$.

For a simultaneous substitution $\Delta \vdash \sigma \Rightarrow
\Delta'$, where $\Delta' = i_1\mathord:s_1,...,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
either $\Delta$ or $\Delta'$, we can form the \emph{lifted}
simultaneous substitution $\Delta,i\mathord:s \vdash
\sigma_{i\mathord:s} = (\sigma(i_1), ..., \sigma(i_n), i) \Rightarrow
\Delta',i\mathord:s$. %Note that we have implicity used the fact that
%well-sortedness of index expressions is preserved by addition of extra
%items to the context.
%
Application of a simultaneous substitution $\Delta \vdash \sigma
\Rightarrow \Delta'$ to a well-sorted index expression $\Delta' \vdash
e : s$ yields a well-sorted index expression $\Delta \vdash \sigma^*e
: s$. The expression $\sigma^*e$ is defined on variables as $\sigma^*i
\isDefinedAs \sigma(i)$, and on operation symbols as
$\sigma^*(\indexOp{f}(e_1,...,e_n)) \isDefinedAs
\indexOp{f}(\sigma^*e_1, ..., \sigma^*e_n)$.  %Similarly, 
Given
%a well-indexed type 
$\Delta' \vdash A \isType$, 
%can apply $\sigma$ to $A$ to produce a new well-indexed type 
we have $\Delta \vdash \sigma^*A
\isType$. The key clauses defining $\sigma^*A$ are for primitive types
and the universal and existential quantifiers:
\begin{displaymath}
  \begin{array}{c}
    \sigma^*(\tyPrim{X}{e_1,...,e_n}) \isDefinedAs \tyPrim{X}{\sigma^*e_1,...,\sigma^*e_n}
    \\
    \begin{array}{c@{\hspace{2em}}c}
      \sigma^*(\forall i\mathord:s.A) \isDefinedAs \forall i\mathord:s.\sigma_{i\mathord:s}^*A
      &
      \sigma^*(\exists i\mathord:s.A) \isDefinedAs \exists i\mathord:S. \sigma_{i\mathord:s}^*A
    \end{array}
  \end{array}
\end{displaymath}
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e : s$, then $\Delta \vdash \sigma^*e : s$; and
%   \item If $\Delta' \vdash A \isType$, then $\Delta \vdash \sigma^*A
%     \isType$.
%   \end{enumerate}
% \end{lemma}
The \emph{identity} simultaneous substitution $\Delta \vdash
\id_\Delta \Rightarrow \Delta$ is %just the sequence of variables in
%$\Delta$: 
$\id_\Delta = (i_1,...,i_n)$ where $\Delta =
i_1\mathord:s_1,...,i_n\mathord:s_n$. The \emph{composition} of 
%two simultaneous substitutions 
$\Delta \vdash \sigma \Rightarrow \Delta'$
and $\Delta' \vdash \sigma' \Rightarrow \Delta''$, where $\sigma' =
(e'_1,...,e'_n)$, is defined as $\Delta \vdash \sigma' \circ \sigma
\isDefinedAs (\sigma^*e'_1, ..., \sigma^*e'_n) \Rightarrow \Delta''$.
%
Given a context $\Delta = i_1\mathord:s_1,...,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
$\Delta$, we define the \emph{projection} simultaneous substitution
$\Delta, i\mathord:s \vdash \pi_{i\mathord:s} \Rightarrow \Delta$ as
$\pi_{i\mathord:s} = (i_1,...,i_n)$. %The subscript on
%$\pi_{i\mathord:s}$ is the variable/sort pair that is being discarded.

\subsubsection{Index Expression Equality and Type Equality}
\label{sec:type-equality}

Much of the power of indexing types by the expressions of an algebraic
theory comes from the equations of the theory. 
%In the %two-dimensional geometry example of 
For example, in 
\autoref{sec:motivating-examples} the types
$\tyPrim{vec}{B,t_1 + t_2}$ and $\tyPrim{vec}{B, t_2 + t_1}$ are
considered equal by the type system
%due to the commutativity of the $+$ operation.
because $+$ is commutative.
%
In the general framework, the equations between types are derived from
a set $\IndexAxiomSet$ of axioms $\Delta \vdash e \stackrel{ax}\equiv
e' : s$ that %We assume that all axioms $(\Delta \vdash e
%\stackrel{ax}\equiv e' : s)$ % \in \IndexAxiomSet$ 
are well-sorted, in the sense that both $\Delta \vdash e : s$ and $\Delta \vdash e' : s$
hold.

Given a set $\IndexAxiomSet$ of axioms, we generate the equality
judgment between index expressions $\Delta \vdash e \equiv e' : s$ by
a set of rules. The following rule lets us use substitution
instances of axioms:
\begin{displaymath}
  \inferrule*
  {(\Delta' \vdash e \stackrel{ax}\equiv e' : s) \in \IndexAxiomSet \\
    \Delta \vdash \sigma \Rightarrow \Delta'}
  {\Delta \vdash \sigma^*e \equiv \sigma^*e' : s}
\end{displaymath}
We also assume the standard congruence, reflexivity, symmetry and
transitivity rules for the equality judgment.

\begin{example}[Two-Dimensional Geometry]
  \label{ex:two-dim-geo-axioms}
  In \autoref{sec:motivating-examples} we assumed 
  %that 
  various equational axioms %hold 
  for indexing expressions standing for
  elements of geometric groups. Assuming the abelian group axioms for
  translations we can formalise this in our %general 
  framework:
  %We can now make this assumption formal
  %in our general framework. Semantically, translations form an abelian
  %group under addition, so we assume the abelian group axioms for
  %translations:
  \begin{displaymath}
    \begin{array}{l}
      t : \SynTransl{2} \vdash t + 0 \stackrel{ax}\equiv t : \SynTransl{2} \\
      t_1, t_2, t_3 : \SynTransl{2} \vdash t_1 + (t_2 + t_3) \stackrel{ax}\equiv (t_1 + t_2) + t_3 : \SynTransl{2} \\
      t : \SynTransl{2} \vdash t + (-t) \stackrel{ax}\equiv 0 : \SynTransl{2} \\
      t_1, t_2 : \SynTransl{2} \vdash t_1 + t_2 \stackrel{ax}\equiv t_2 + t_1 : \SynTransl{2} \\
    \end{array}
  \end{displaymath}
  Similarly, the sort of scale factors $\SynGL{1}$ forms an abelian
  group under multiplication, and the sorts $\SynGL{2}$ and
  $\SynOrth{2}$ form (non-abelian) multiplicative groups, so we assume
  the appropriate axioms. We also assume that the operations $\iota_O,
  \iota_1, \det$ and $\abs{\cdot}$ are group homomorphisms, and that
  expressions of the form $\iota_1(s)$ commute with group
  multiplication in the sort $\SynGL{2}$. The absolute value of the
  determinant of an orthgonal transformation is always $1$, so we also
  assume $\abs{\det(\iota_OO)} \stackrel{ax}\equiv 1$. Likewise, scaling
  maps have a determined determinant: $\det(\iota_1(s))
  \stackrel{ax}\equiv s \cdot s$.
\end{example}

The equality judgment $\Delta \vdash e \equiv e' : s$ on index
expressions generates the equality judgment $\Delta \vdash A \equiv
B \isType$ on types. The basic rule generating equality judgments on
types equates %states that %two 
applications of primitive types %are equal 
if
their %index expression 
arguments are equal:
\begin{displaymath}
  \inferrule*
  {\{ \Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j \leq n}}
  {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \equiv \tyPrim{X}{e'_1,...,e'_n} \isType}
\end{displaymath}
The rest of the rules for equality on types ensure that it is a
congruence relation 
and an equivalence relation.
%on types. %and that it is an equivalence relation
%(i.e.,~equality on types is reflexive, symmetric and transitive).
% For example, for universally quantified types we have
% the following congruence rule:
% \begin{displaymath}
%   \inferrule*
%   {\Delta, i : s \vdash A \equiv B \isType}
%   {\Delta \vdash \forall i\mathord:s.A \equiv \forall i\mathord:s.B \isType}
% \end{displaymath}
% The congruence rules for the other type formers are similar.

% FIXME: think about integrating this lemma into the running text
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e \equiv e' : s$ then $\Delta \vdash
%     \sigma^*e \equiv \sigma^*e' : s$; and
%   \item If $\Delta' \vdash A \equiv B \isType$ then $\Delta \vdash
%     \sigma^*A \equiv \sigma^* B \isType$.
%   \end{enumerate}
% \end{lemma}

%A pair of 
The simultaneous substitutions $\Delta \vdash \sigma \Rightarrow
\Delta'$ and $\Delta \vdash \sigma' \Rightarrow \Delta'$ are defined
to be equal if their component expressions are equal in the context
$\Delta$: i.e.,~ if $\Delta \vdash e_j \equiv e'_j : s_j$, for all
$j$. We write $\Delta \vdash \sigma \equiv \sigma' \Rightarrow
\Delta'$ when two simultaneous substitutions are equal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantics of Algebraically-Indexed Types}
\label{sec:semantics-algebraically-indexed-types}

%\fixme{Make sure that the semantics is motivated}
%Having defined the language of algebraically-indexed types, we now
%turn to their denotational interpretation. 
%We now give the denotational interpretation of algebraically indexed
%types.  In \autoref{sec:index-erasure-semantics} we define an
%\emph{index-erasure} interpretation of types that interprets every
%well-indexed type as a set, ignoring the indexing
%expressions. %Building on the index-erasure semantics, we 
%We then define in
%\autoref{sec:relational-semantics} the relational
%interpretation of types.

\autoref{sec:index-erasure-semantics} gives an \emph{index-erasure}
interpretation of types, interpreting every well-indexed type as a
set, ignoring the indexing expressions.
\autoref{sec:relational-semantics} gives the relational interpretation
of types.

% For both of our semantics of types, we state and prove two properties:
% types that are syntactically equal have equal denotations, and that
% substitution of index terms is interpreted via composition. These
% properties ensure that our semantics of types is well-behaved.

\subsubsection{The Index-Erasure Interpretation of Types}
\label{sec:index-erasure-semantics}

The defining feature of the index erasure interpretation is that 
semantics of a well-indexed type $\tyPrim{X}{e_1,...,e_n}$ is
determined solely by the primitive type $\tyPrimNm{X}$ and not by the
index expressions $e_1,...,e_n$. %Accordingly, 
We thus assume each
primitive type $\tyPrimNm{X} \in \PrimTypeSet$ is assigned a set
$\tyPrimSem{\tyPrimNm{X}}$ and %We 
extend this assignment to %every
well-indexed types by: % induction on the type structure:
\begin{displaymath}
  \begin{array}{@{}c@{\hspace{0em}}c@{}}
    \begin{array}{@{}l}
      \tySem{\tyUnit} \isDefinedAs \{*\} \\
      \tySem{A \tyProduct B} \isDefinedAs \tySem{A} \times \tySem{B} \\
      \tySem{A \tyArr B} \isDefinedAs \tySem{A} \to \tySem{B} \\
    \end{array}
    &
    \begin{array}{l}
      \tySem{A + B} \isDefinedAs \tySem{A} + \tySem{B} \\
      \tySem{\tyPrim{X}{e_1,...,e_n}} \isDefinedAs \tyPrimSem{\tyPrimNm{X}} \\
      \tySem{\forall i\mathord:s. A} \isDefinedAs \tySem{A} \\
      \tySem{\exists i\mathord:s. A} \isDefinedAs \tySem{A}
    \end{array}
  \end{array}
\end{displaymath}
% The interpretation of the unit type is a chosen one element set, and
% the interpretations of the function, tuple and sum types are simply
% the corresponding constructions on sets. 
Note that 
the interpretations of the
universal and existential quantifiers 
do indeed
ignore the indexing. %: the
%interpretation of the type $\forall i\mathord:s.A$ is exactly the
%interpretation of the type $A$, and likewise for $\exists
%i\mathord:s.A$.
We then have:

% The index-erasure interpretation completely ignores index expressions
% and type equality is defined as an extension of index
% equality. Therefore, it is straightforward to prove that equal types
% have equal denotations when interpreted in the index-erasure
% semantics, and that substitution of index terms has no effect on the
% index-erasure interpretation of types:
\begin{lemma}\label{lem:tyeqsubst-erasure}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$ then $\tySem{A} =
    \tySem{B}$; and
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then $\tySem{\sigma^*A} = \tySem{A}$.
  \end{enumerate}
\end{lemma}

\begin{example}[Two-Dimensional Geometry]
  \exref{ex:two-dim-geo-axioms}
%  The two-dimensional geometry instantiation of the general framework
  uses the assignment $\tyPrimSem{\tyPrimNm{vec}} = \mathbb{R}^2$ and
  $\tyPrimSem{\tyPrimNm{real}} = \mathbb{R}$.
\end{example}

\subsubsection{The Relational Interpretation of Types}
\label{sec:relational-semantics}

%We now define 
The relational semantics of the well-indexed type
$\Delta \vdash A \isType$ is a binary relation on the index-erasure
interpretation of $A$. We write $\Rel(X)$ for the set
of binary relations $R \subseteq X \times X$ on the set $X$.

For the unit, tuple, sum and function types we define the
relational interpretation as a standard logical relation. The
relational interpretations of primitive types with index arguments and
the universally quantified types require an interpretation of index
contexts. %We assign interpretations to index contexts 
These are given in terms of sets
of \emph{relational environments}.

The definition of relational environments is the most subtle part of
our framework. 

%The straightforward approach is to assume an
%interpretation of indexing expressions in which sorts are
%interpreted as 
%sets and index operations are functions, and then define the
%relational interpretation of a primtive type $\tyPrim{X}{e_1,...,e_n}$
%in terms of the interpretations of $e_1,...,e_n$. This approach
%suffices to prove free theorems and type isomorphisms. However, to
%prove non-definability results, like the one in
%\exref{ex:uninhabited-type}, we need a more refined interpretation
%that accounts for the definable programs permitted by the algebraic
%indexing. Here, we identify the properties we require of relational
%environments for the abstraction theorem to hold. In
%\autoref{sec:constr-rel-env}, we give two generic constructions of
%relational environments.

A relational environment for a context $\Delta$ is a %(dependently typed)
function $\rho$ that, for each primitive type $\tyPrimNm{X}$ and
instantiation of its arguments $\sigma$, assigns a binary relation
$\rho\ \tyPrimNm{X}\ \sigma$ on the index-erasure interpretation of
$\tyPrimNm{X}$:
\begin{displaymath}
  \rho : (\tyPrimNm{X} \in \PrimTypeSet) \to (\Delta \Rightarrow \primTyArity(\tyPrimNm{X})) \to \Rel(\tyPrimSem{\tyPrimNm{X}})
\end{displaymath}
%Every relation environment must respect index expression equality: for
%any $\tyPrimNm{X} \in \PrimTypeSet$ and pair of simultaneous
%substitutions $\Delta \vdash \sigma \Rightarrow
%\primTyArity(\tyPrimNm{X})$ and $\Delta \vdash \sigma' \Rightarrow
%\primTyArity(\tyPrimNm{X})$, if $\Delta \vdash \sigma \equiv \sigma'
%\Rightarrow \primTyArity(\tyPrimNm{X})$, then $\rho\ \tyPrimNm{X}\
%\sigma = \rho\ \tyPrimNm{X}\ \sigma'$.
Relational environments must respect index expression equality: for
all $\tyPrimNm{X} \in \PrimTypeSet$,
$\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$, and $\Delta \vdash \sigma' \Rightarrow
\primTyArity(\tyPrimNm{X})$, if $\Delta \vdash \sigma \equiv \sigma'
\Rightarrow \primTyArity(\tyPrimNm{X})$, then $\rho\ \tyPrimNm{X}\
\sigma = \rho\ \tyPrimNm{X}\ \sigma'$.
%
We write $\mathrm{RelEnv}(\Delta)$ for the set of all relational
environments for a context $\Delta$. Given %a relational environment
$\rho \in \mathrm{RelEnv}(\Delta)$ and %a simultaneous substitution
$\Delta \vdash \sigma \Rightarrow \Delta'$, we can derive the composed
relational environment (with an abuse of notation) $\rho \circ \sigma
\in \mathrm{RelEnv}(\Delta')$ as $(\rho \circ \sigma)\ \tyPrimNm{X}\
\sigma' = \rho\ \tyPrimNm{X}\ (\sigma' \circ \sigma)$.

We interpret index contexts $\Delta$ as certain
%sets of relation environments, i.e.,~
subsets of $\mathrm{RelEnv}(\Delta)$. Depending on the primitive
operations that we assume for our system, we may have different sets
of relational environments that enforce different invariants. 
% We
% require that the sets of relational environments are \emph{valid} in
% the following sense:

\begin{definition}
  \label{defn:valid-rel-env-family}
  An index context-indexed family of sets of relational environments
  $\{ \relEnv{E}(\Delta) \subseteq \mathrm{RelEnv}(\Delta) \}_\Delta$
  is \emph{substitutive} if:
  \begin{enumerate}
  \item it is closed under composition with simultaneous substitution:
    if $\rho \in \relEnv{E}(\Delta)$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then $\rho \circ \sigma \in
    \relEnv{E}(\Delta')$; and
%  \item If we have a pair of relation environments $\rho_1 \in
%    \relEnv{E}(\Delta', i\mathord:s')$ and $\rho_2 \in
%    \relEnv{E}(\Delta)$, along with a simultaneous substitution
%    $\Delta' \vdash \sigma \Rightarrow \Delta$, such that $\rho_1
%    \circ \pi_{i\mathord:s'} = \rho_2 \circ \sigma$, then there exists
%    a $\rho \in \relEnv{E}(\Delta, i\mathord:s')$ such that $\rho
%    \circ \sigma_{i\mathord:s'} = \rho_1$ and $\rho \circ
%    \pi_{i\mathord:s'} = \rho_2$.
  \item if $\rho_1 \in \relEnv{E}(\Delta', i\mathord:s)$ and $\rho_2
    \in \relEnv{E}(\Delta)$, and $\Delta \vdash \sigma \Rightarrow
    \Delta'$ is such that $\rho_1 \circ \pi_{i\mathord:s} = \rho_2
    \circ \sigma$, then there exists a $\rho \in \relEnv{E}(\Delta,
    i\mathord:s)$ such that $\rho \circ \sigma_{i\mathord:s} =
    \rho_1$ and $\rho \circ \pi_{i\mathord:s} = \rho_2$.
    % such that the outer edges of the
    % following diagram commute, for all primitive types $\tyPrimNm{X} \in
    % \mathit{PrimType}$:
    % % FIXME: check that these compositions are the right way round
    % % FIXME: re-do this as a set of equations
    % % FIXME: give a better English description of why this is needed
    % \begin{displaymath}
    %   \xymatrix{
    %   {\Delta \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar[d]_{- \circ \sigma}
    %   &
    %   {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[d]^{- \circ \sigma_{s'}} \ar@/^/[rdd]^{\rho_1 \tyPrimNm{X}}
    %   \\
    %   {\Delta' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar@/_/[rrd]_{\rho_2\ \tyPrimNm{X}}
    %   &
    %   {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar@{.>}[dr]_{\rho\ \tyPrimNm{X}}
    %   \\
    %   &
    %   &
    %   {\Rel(\tyPrimSem{\tyPrimNm{X}})}
    % }
    % \end{displaymath}
    % Then there exists a relation environment $\rho \in
    % \relEnv{E}(\Delta,i\mathord:s')$ (the dotted arrow) such that the
    % two triangles in the bottom right of the diagram commute.
    % FIXME: mention that we already know that the square commutes
  \end{enumerate}
\end{definition}
%
% For the general
% framework, we assume that, for each index context $\Delta$, we are
% given a set of relation environments $\relEnv{E}(\Delta)$. Note that
% this assignment of sets of relation environments to index contexts is
% not assumed to be compositional: it is not necessarily the case that
% the set of relational environments $\relEnv{E}(\Delta_1,\Delta_2)$ is
% defined in terms of $\relEnv{E}(\Delta_1)$ and
% $\relEnv{E}(\Delta_2)$. However, it must satisfy the following two
% properties:
%
\noindent
These conditions ensure that the relational interpretation of types we
define below behaves correctly with respect to simultaneous
substitution of index expressions (see
\lemref{lem:tyeqsubst-relational}, below).

% The second condition may
% seem mysterious at first, but it is essential for proving that the
% relational interpretation of universal quantification types behaves
% correctly with respect to application of simultaneous substitution.
%
Given a relational environment $\rho \in \relEnv{E}(\Delta)$, %we define
the set of extensions %$\extends{\rho}{i\mathord:s}$ 
of $\rho$ by %an
%additional index variable 
$i\mathord:s$ %to be 
is $\extends{\rho}{i\mathord:s} \isDefinedAs \{ \rho' \in
\relEnv{E}(\Delta,i\mathord:s) \sepbar \rho' \circ \pi_{i\mathord:s} =
\rho \}$. The set of extensions of a relational environment will be
used in interpreting the universal and existential type formers.  We
assign a relational interpretation to all well-indexed types $\Delta
\vdash A \isType$ by induction on their derivations, parameterised by
%relational environments 
$\rho \in \relEnv{E}(\Delta)$:
\begin{eqnarray*}
  \rsem{\tyUnit}{\relEnv{E}}\rho & \isDefinedAs & \{(*,*)\} \\
  \rsem{\tyPrim{X}{e_1,...,e_n}}{\relEnv{E}}\rho & \isDefinedAs & \rho\ {\tyPrimNm{X}}\ (e_1,...,e_n) \\
  \rsem{A \tyArr B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relArrow \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A \tyProduct B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relTimes \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A + B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relSum \rsem{B}{\relEnv{E}}\rho \\
  \rsem{\forall i\mathord:s.A}{\relEnv{E}}\rho & \isDefinedAs & \bigcap\{ \rsem{A}{\relEnv{E}}{\rho'} \sepbar \rho' \in \extends{\rho}{i\mathord:s} \} \\
  \rsem{\exists i\mathord:s.A}{\relEnv{E}}\rho & \isDefinedAs & \bigcup\{ \rsem{A}{\relEnv{E}}{\rho'} \sepbar \rho' \in \extends{\rho}{i\mathord:s} \}
\end{eqnarray*}
In this definition we have made use of the following %three
constructions on binary relations: if $R \in \Rel(X)$ and $S \in
\Rel(Y)$, then $R \relArrow S \in \Rel(X \to Y)$ is %defined as 
$\{(f_1,f_2) \sepbar \forall (a_1,a_2) \in R.\ (f_1a_1,f_2a_2) \in S
\}$, and %. With the same assumptions on $R$ and $S$, the relation 
$R
\relTimes S \in \Rel(X \times Y)$ is %defined as 
$\{((a_1,b_1),(a_2,b_2)) \sepbar (a_1,a_2) \in R \land (b_1,b_2) \in S
\}$, and %. Finally, the relation 
$R \relSum S \in \Rel(X + Y)$ is %defined as
$\{ (\mathrm{inl}\ x, \mathrm{inl}\ x') \sepbar (x,x') \in R \} \cup
\{ (\mathrm{inr}\ y, \mathrm{inr}\ y') \sepbar (y,y') \in S \}$.

% The following lemma states that the relation interpretation of types
% that we have defined in this section behaves well: the first part of
% the lemma states that two types that are judgmentally equal are given
% equal relational interpretations, and the second part states that
% substitution of index expressions in types can be interpreted by the
% composition of relational environments with simultaneous
% substitutions.
\begin{lemma}\label{lem:tyeqsubst-relational}
\par
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$, then for all $\rho \in
    \relEnv{E}(\Delta)$, $\rsem{A}{\relEnv{E}}{\rho} =
    \rsem{B}{\relEnv{E}}{\rho}$;
  \item If $\Delta' \vdash A \isType$ and $\relEnv{E}$ is
    substitutive, then for all $\Delta \vdash \sigma \Rightarrow
    \Delta'$ and $\rho \in \relEnv{E}(\Delta)$,
    $\rsem{\sigma^*A}{\relEnv{E}}\rho = \rsem{A}{\relEnv{E}}(\rho
    \circ \sigma)$.
  \end{enumerate}
\end{lemma}
\noindent
Note that the equations in both parts of
\lemref{lem:tyeqsubst-relational} are well-typed by virtue of the
corresponding parts of \lemref{lem:tyeqsubst-erasure}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Well-typed Programs and the Abstraction Theorem}
\label{sec:well-typed-programs}

We now present the rules for well-typed programs over the 
%collection of 
types %we defined 
in \autoref{sec:algebraically-indexed-types}. Each
well-typed program is assigned an index-erasure semantics, building on
the index-erasure semantics of types %we defined 
in \autoref{sec:index-erasure-semantics}. Our main result
(\thmref{thm:abstraction}) is that the index-erasure semantics of
every well-typed program is related to itself in the relational
interpretation of its type: this is the abstraction theorem for every
instantiation of our general framework.

Well-typed programs are defined with respect to well-indexed typing
contexts, which are in turn defined with respect to an index
context. Well-indexed typing contexts with respect to an index context
$\Delta$ are sequences of variable/type pairs with no repeated
variable names such that each type is well-indexed with respect to
$\Delta$. Formally, well-indexed typing contexts are 
given by
%defined by the following two rules:
\begin{mathpar}
  \inferrule*
  { }
  {\Delta \vdash \epsilon \isCtxt}

  \inferrule*
  {\Delta \vdash \Gamma \isCtxt \\ \Delta \vdash A \isType \\ x \not\in \Gamma}
  {\Delta \vdash \Gamma, x : A \isCtxt}
\end{mathpar}
Application of simultaneous substitutions extends to typing contexts
by applying the simultaneous substitution to each type.

%The typing rules for our framework define 
Well-typed programs 
are defined
with respect to an index context $\Delta$ and a type context $\Delta \vdash
\Gamma \isCtxt$. The judgment $\Delta; \Gamma \vdash M : A$ is defined
in \autoref{fig:programs}. The equational theory on types is
incorporated into the type system via the rule \TirName{TyEq}, which
allows for a program that has %is judged to have 
type $A$ to also have any
%other 
equal type $B$ as well.
\begin{figure*}[t]
  \centering
  {\small
  \begin{mathpar}
    \inferrule* [right=Var]
    {\Delta \vdash \Gamma \isCtxt \\ x : A \in \Gamma}
    {\Delta; \Gamma \vdash x : A}

    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash M : A \\ \Delta \vdash A \equiv B \isType}
    {\Delta; \Gamma \vdash M : B}

    \inferrule* [right=Unit]
    { }
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash M : A \\
      \Delta; \Gamma \vdash N : B}
    {\Delta; \Gamma \vdash (M, N) : A \tyProduct B}

    \inferrule* [right=Proj1]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_1 M : A}

    \inferrule* [right=Proj2]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_2 M : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \mathrm{inl}\ M : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash M : B}
    {\Delta; \Gamma \vdash \mathrm{inr}\ M : A + B}

    \inferrule* [right=Case]
    {\Delta; \Gamma \vdash M : A + B \\\\
      \Delta; \Gamma, x : A \vdash N_1 : C \\\\
      \Delta; \Gamma, y : B \vdash N_2 : C}
    {\Delta; \Gamma \vdash \textrm{case}\ M\ \textrm{of}\ \textrm{inl}\ x.N_1; \textrm{inr}\ y.N_2 : C}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, x : A \vdash M : B}
    {\Delta; \Gamma \vdash \lambda x.M : A \tyArr B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash M : A \tyArr B \\
      \Delta; \Gamma \vdash N : A}
    {\Delta; \Gamma \vdash M N : B}

    \inferrule* [right=UnivAbs]
    {\Delta, i \mathord: s; \pi_{i\mathord:s}^*\Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \Lambda i. M : \forall i\mathord:s. A}

    \inferrule* [right=UnivApp]
    {\Delta; \Gamma \vdash M : \forall i\mathord:s. A \\ \Delta \vdash e : s}
    {\Delta; \Gamma \vdash M [e] : (\id_\Delta, e)^*A}

    \inferrule* [right=ExPack]
    {\Delta; \Gamma \vdash M : (\id_\Delta, e)^*A \\ \Delta, i\mathord:s \vdash A \isType}
    {\Delta; \Gamma \vdash \langle[e], M\rangle: \exists i\mathord:s. A}

    \inferrule* [right=ExUnpack]
    {\Delta; \Gamma \vdash M : \exists i\mathord:s. A \\\\
      \Delta, i\mathord:s; \pi_{i\mathord:s}^*\Gamma, x : A \vdash N : \pi_{i\mathord:s}^*B}
    {\Delta; \Gamma \vdash \mathrm{let}\langle[i],x\rangle = M\ \mathrm{in}\ N : B}
  \end{mathpar}}
  
  \caption{Well-typed Programs}
  \label{fig:programs}
\end{figure*}

\paragraph{Index-Erasure Interpretation of Programs}

% FIXME: do we need to prove something about the effect
% of substitution on the erasure semantics of contexts?

We assign an index-erasure semantics to any well-indexed typing
context $\Delta \vdash \Gamma \isCtxt$ by induction:
$\ctxtSem{\epsilon} = \{*\}$ and $\ctxtSem{\Gamma, x : A} =
\ctxtSem{\Gamma} \times \tySem{A}$. For a well-typed program $\Delta;
\Gamma \vdash M : A$, we define the \emph{erasure interpretation} as a
function $\tmSem{M} : \ctxtSem{\Gamma} \to \tySem{A}$ that completely
ignores the indexing information. In light of
\lemref{lem:tyeqsubst-erasure}, we do this %we define this function is defined
directly on the syntax of well-typed programs, rather than on typing
derivations. The definition of $\tmSem{M}$ is completely standard,
except for the clauses for universal and existential types:
\begin{displaymath}
  \begin{array}{@{}l}
    \begin{array}{@{}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{\hspace{2em}}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{}}
      \tmSem{\Lambda i.\ M}\eta & \isDefinedAs & \tmSem{M}\eta
      &
      \tmSem{M[e]}\eta & \isDefinedAs & \tmSem{M}\eta \\
      \tmSem{\langle [e], M\rangle}\eta & \isDefinedAs & \tmSem{M}\eta
    \end{array} \\
    \tmSem{\mathrm{let}\langle[i], x\rangle = M\ \mathrm{in}\ N}\eta \isDefinedAs \tmSem{N}(\eta, \tmSem{M}\eta)
  \end{array}
\end{displaymath}

We use our index-erasure semantics to define when a pair of programs
are contextually equivalent with respect to syntactically defined
contexts, following Hofmann \cite{hofmann08correctness}.

\begin{definition}\label{defn:ctxt-equiv}
  Let $\Gamma_{\mathit{ops}}$ be a typing context with no free index
  variables that describes the types of the primitive operations, and
  let $\eta_{\mathit{ops}} \in \ctxtSem{\Gamma_{\mathit{ops}}}$ be an interpretation
  of these primitive operations.

  Two programs $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_1 : A$
  and $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_2 : A$ are
  \emph{contextually equivalent} ($\Delta; \Gamma_{\mathit{ops}},
  \Gamma \vdash M_1 \stackrel{ctx}\approx M_2 : A$) if for all
  programs $;\Gamma_{\mathit{ops}} \vdash T : (\forall \Delta. \Gamma
  \to A) \to \tyPrimNm{bool}$, it is the case that $\tmSem{T\ (\Lambda
    \Delta. \lambda \Gamma. M_1)}\eta_{\mathit{ops}} = \tmSem{T\
    (\Lambda \Delta. \lambda \Gamma. M_2)}\eta_{\mathit{ops}}$.
\end{definition}

\paragraph{The Abstraction Theorem}
%\label{sec:abstraction-theorem}

We now state the abstraction theorem for well-typed programs. To state
and prove this theorem for open programs, we extend the
relational interpretation of types to typing contexts. The relational
interpretation of contexts is defined by: % the following clauses: %, where
%we have used the relational lifting of cartesian product $-\relTimes-$
%defined in \autoref{sec:relational-semantics}.
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l@{\hspace{1.5em}}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l}
    \rsem{\epsilon}{\relEnv{E}}{\rho} & \{(*,*)\} &
    \rsem{\Gamma, x : A}{\relEnv{E}}{\rho} & \rsem{\Gamma}{\relEnv{E}}\rho \relTimes \rsem{A}{\relEnv{E}}\rho
  \end{array}
\end{displaymath}
% The relational interpretation of contexts inherits from the relational
% interpretation of types the property of interpreting the application
% of simultaneous substitutions as composition:
% \begin{lemma}\label{lem:ctxtsubst-rel}
%   If $\Delta' \vdash \Gamma \isCtxt$ and $\Delta \vdash \sigma
%   \Rightarrow \Delta'$, then for all $\rho \in \relEnv{E}(\Delta)$,
%   $\rsem{\sigma^*\Gamma}{\relEnv{E}}\rho =
%   \rsem{\Gamma}{\relEnv{E}}{(\rho \circ \sigma)}$.
% \end{lemma}

\begin{theorem}[Abstraction]\label{thm:abstraction}
  Assume $\relEnv{E}$ is substitutive. If $\Delta; \Gamma \vdash M :
  A$, then for all $\rho \in \relEnv{E}(\Delta)$ and $\eta_1, \eta_2
  \in \ctxtSem{\Gamma}$ such that $(\eta_1, \eta_2) \in
  \rsem{\Gamma}{\relEnv{E}}\rho$, we have $(\tmSem{M}\eta_1,
  \tmSem{M}\eta_2) \in \rsem{A}{\relEnv{E}}\rho$.
\end{theorem}

We refer to programs satisfying the conditions in the second part of
\thmref{thm:abstraction} as being in the \emph{quantifier-free}
fragment of our framework. These conditions are very similar to those
used in the fragment of System F covered by Hindley-Milner type
inference.

Semantic equivalence of programs is defined in terms of the relational
interpretation. As a consequence of \thmref{thm:abstraction}, semantic
equivalence is a sound approximation of contextual equivalence.
\begin{definition}\label{def:semantic-equality}
  Let $\Gamma_{\mathit{ops}}$ and $\eta_{\mathit{ops}}$ be a context
  of primitive operations and its interpretation as in
  \defref{defn:ctxt-equiv}. Let $\relEnv{E}_{\mathit{ops}}$ be a
  substitutive family of sets of relational environments such that for
  all $\Delta$ and $\rho \in \relEnv{E}_{\mathit{ops}}(\Delta)$,
  $(\eta_{\mathit{ops}}, \eta_{\mathit{ops}}) \in
  \rsem{\Gamma_{\mathit{ops}}}{\relEnv{E}_{\mathit{ops}}}\rho$.

  Two programs $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_1 : A$
  and $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_2 : A$ are
  \emph{semantically equal} ($\Delta; \Gamma_{\mathit{ops}}, \Gamma
  \vdash M_1 \stackrel{sem}\sim M_2 : A$) if for all $\rho \in
  \relEnv{E}_{\mathit{ops}}$, and all $(\eta_1,\eta_2) \in
  \rsem{\Gamma}{\relEnv{E}_{\mathit{ops}}}\rho$, we have
  $(\tmSem{M_1}(\eta_{\mathit{ops}},
  \eta_1),\tmSem{M_2}(\eta_{\mathit{ops}}, \eta_2)) \in
  \rsem{A}{\relEnv{E}_{\mathit{ops}}}\rho$.
\end{definition}

\begin{theorem}[Soundness]\label{thm:soundness}
  $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_1 \stackrel{sem}\sim M_2 : A$ implies
  $\Delta; \Gamma_{\mathit{ops}}, \Gamma \vdash M_1 \stackrel{ctx}\approx M_2 : A$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Construction of Relational Environments}
\label{sec:constr-rel-env}

\newcommand{\Gen}{\mathrm{Gen}}
\newcommand{\Free}{\mathrm{Free}}
\newcommand{\semSort}[1]{\llbracket #1 \rrbracket^{\mathcal{S}}}
\newcommand{\semIndexExp}[1]{\llbracket #1 \rrbracket^{\mathcal{I}}}

We give construction of families $\relEnv{E}$ of sets of
relational environments that allow us to derive useful consequences of
\thmref{thm:abstraction}. 
To satisfy the hypothesis of
\thmref{thm:abstraction} we still need to prove, for each
instantiation of our general framework, that the program-level
primitive operations preserve all the relations in our
constructions. This is the content of Lemmas
\ref{lem:geom-environments-1}, \ref{lem:geom-environments-2},
\ref{lem:monoid-ops-related}, \ref{lem:environments-information-flow}
and \ref{lem:metric-environments}.

%\paragraph{Model-based Relational Environments}
Our relational environments are defined in terms of
models. To each sort $s \in \SortSet$ we assign a carrier set
$\semSort{s}$. We extend this assignment to index contexts and other
sequences of sorts (e.g., type arities) using the cartesian product of
sets: $\semSort{i_1\mathord:s_1,...,i_n\mathord:s_n} = \semSort{s_1}
\times ... \times \semSort{s_n}$. For each index operation $\texttt{f}
\in \IndexOpSet$ with $\indexOpArity(\texttt{f}) = ([s_1,...,s_n],s)$,
we assume a function $\semIndexExp{\texttt{f}} : \semSort{s_1,...,s_n}
\to \semSort{s}$. For each well-sorted index expression $\Delta \vdash
e : s$, we assign a function $\semIndexExp{e} : \semSort{\Delta} \to
\semSort{s}$ by recursion on the structure of $e$. We further assume
that for each axiom $\Delta \vdash e \stackrel{ax}\equiv e' : s \in
\IndexAxiomSet$, we have $\semIndexExp{e} = \semIndexExp{e'}$. A
\emph{model} is a pair $\mathcal{M} = (\semSort{\cdot}_{\mathcal{M}},
\semIndexExp{\cdot}_{\mathcal{M}})$ satisfying all the axioms in
$\IndexAxiomSet$.

Now fix a model $\mathcal{M}$ and assume, for each primitive type
$\tyPrimNm{X}$, a relational interpretation parameterised by elements
from the model: $R_{\tyPrimNm{X}} :
\semSort{\primTyArity(\tyPrimNm{X})}_{\mathcal{M}} \to
\Rel(\tyPrimSem{\tyPrimNm{X}})$. Our family of sets of relational
environments is $\relEnv{E}_{\mathcal{M},R}(\Delta) = \{ \rho^\delta
\sepbar \delta \in \semSort{\Delta}_{\mathcal{M}} \}$, where
$\rho^\delta\ \tyPrimNm{X}\ (e_1,...,e_n) =
R_{\tyPrimNm{X}}(\semIndexExp{e_1}_{\mathcal{M}}\delta, ...,
\semIndexExp{e_n}_{\mathcal{M}}\delta)$.

\begin{theorem}
  The families $\relEnv{E}_{\mathcal{M},R}$ are substitutive.
\end{theorem}


%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
