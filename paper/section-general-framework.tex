\newcommand{\Gen}{\mathrm{Gen}}
\newcommand{\Free}{\mathrm{Free}}
\newcommand{\semSort}[1]{\llbracket #1 \rrbracket}
\newcommand{\semIndexExp}[1]{\llbracket #1 \rrbracket}
\newcommand{\semPrimType}[1]{\llbracket #1 \rrbracket}
\newcommand{\opsCtxt}{\Gamma_{\mathit{ops}}}
\newcommand{\opsEnv}{\eta_{\mathit{ops}}}
\newcommand{\ctxteq}[5]{{#1};{#2}\vdash{#3}\approx{#4}:{#5}}
\newcommand{\semeq}[5]{{#1};{#2}\models{#3}\sim{#4}:{#5}}
\section{A General Framework}
\label{sec:a-general-framework}

%In this section 
We now present our framework for algebraically indexed types and its
relational interpretation.  We define the syntax of algebraically
indexed types (\autoref{sec:algebraically-indexed-types}) and a syntax
for terms in a general programming language for algebraically indexed
types (\autoref{sec:well-typed-programs}). We give an index-erasure
semantics to types and terms (\autoref{sec:erasure-semantics}), and
based on this semantics define notions of contextual equivalence and
type isomorphism. We
then introduce a relational semantics for types parameterised by an appropriate
`model' of the algebraic theory (\autoref{sec:relational-semantics}),
prove the central Abstraction Theorem
and use the relational semantics
to define a notion of semantic equivalence that soundly approximates 
contextual equivalence (\autoref{sec:abstraction-theorem}).

We will use a type system for affine geometry as a running example
throughout, so that by the end of the section we have prepared enough
syntactic and semantic gadgets to let us prove invariance
and abstraction properties for geometric examples in
\autoref{sec:instantiations}.
%and semantics of algebraically indexed types, then their semantics
%and finally we present a general programming language for
%algebraically indexed types, together with an abstraction theorem.

\subsection{Algebraically-Indexed Types}
\label{sec:algebraically-indexed-types}

The index expressions and types of an instantiation of our general
framework are derived from the following data:
\begin{enumerate}
\item A collection $\SortSet$ of index sorts. We use the
  meta-syntactic variables $s,s_1,s_2,\ldots$ for arbitrary sorts taken
  from $\SortSet$.
\item A collection $\IndexOpSet$ of index operations, with a function
  $\indexOpArity : \IndexOpSet \to \SortSet^* \times \SortSet$. (We use
  the notation $A^*$ to denote the set of lists of elements of some
  set $A$.)
\item A collection $\PrimTypeSet$ of primitive types, with a function
  $\primTyArity : \PrimTypeSet \to \SortSet^*$, describing the sorts
  of the arguments of each primitive type.
\end{enumerate}

\begin{example*}[Geometry: syntax]
  \label{ex:two-dim-geo-operations}
  The two-dimensional geometry system has a sort for each of the
  geometric groups mentioned in \autoref{sec:motivating-examples}, so
  $\SortSet = \{\SynTransl{2}, \SynGL{2}, \SynOrth{2}, \SynGL{1} \}$.
  %For the index operations, 
  We have additive group structure on $\SynTransl{2}$, multiplicative
  group structure on $\SynGL{1}$, $\SynGL{2}$, and $\SynOrth{2}$,
  injections from $\SynOrth{2}$ and $\SynGL{1}$ into $\SynGL{2}$,
  determinant, and absolute value. Thus, $\IndexOpSet = \{ 0, +, -,
  1_G, -\cdot_G-, -^{-1_G}, \iota_O, \iota_1, \det, \abs{\cdot} \}$, where
  $G \in \{\SynGL{1}, \SynGL{2}, \SynOrth{2}\}$, and
  %  with the following assignment of arities:
  \begin{displaymath}
    \begin{array}{@{}l@{\hspace{0em}=\hspace{0em}}l@{\hspace{0.5em}}l@{\hspace{0em}=\hspace{0em}}l}
      \indexOpArity(0) & ([], \SynTransl{2}) &
      \indexOpArity(1_G) & ([], G) \\
      \indexOpArity(+) & ([\SynTransl{2}, \SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(\cdot_G) & ([G,G],G) \\
      \indexOpArity(-) & ([\SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(^{-1_G}) & ([G], G) \\
      \indexOpArity(\iota_O) & ([\SynOrth{2}], \SynGL{2}) &
      \indexOpArity(\iota_1) & ([\SynGL{1}], \SynGL{2}) \\
      \indexOpArity(\det) & ([\SynGL{2}], \SynGL{1}) &
      \indexOpArity(\abs{\cdot}) & ([\SynGL{1}], \SynGL{1})
    \end{array}
  \end{displaymath}
  The intended interpretations of the top three pairs of operations
  are group unit, group combination and group negation,
  respectively. 
  When we discuss equational theories on index expressions 
in \autoref{sec:type-equality} 
we will impose the (abelian) group laws. For this example, 
we also have $\PrimTypeSet = \{ \tyPrimNm{vec},
  \tyPrimNm{real} \}$, with $\primTyArity(\tyPrimNm{vec}) =
           [\SynGL{2}, \SynTransl{2}]$ and
           $\primTyArity(\tyPrimNm{real}) = [\SynGL{1}]$.
\qed
\end{example*}

We assume a countably infinite collection of index variable names $i,
i_1, i_2$, \emph{etc}. \emph{Index contexts} $\Delta = i_1 \mathord: s_1,
\ldots, i_n \mathord: s_n$ are lists of variable/sort pairs such that
all the variable names are distinct.
\begin{figure*}[t]
  \centering
  % \textbf{Index contexts}\\

  % $\Delta = i_1 \mathord: s_1, ..., i_n \mathord: s_n$, where each $s_i \in \SortSet$ and no variable name is repeated.

  % \bigskip

  {\small
  \textbf{Well-sorted index expressions}
  \begin{mathpar}
    \inferrule* [right=IVar]
    {i : s \in \Delta}
    {\Delta \vdash i : s}
    
    \inferrule* [right=IOp]
    {\indexOp{f} \in \mathit{IndexOp} \\
      \indexOpArity(\indexOp{f}) = ([s_1,\ldots,s_n], s) \\
      \{\Delta \vdash e_j : s_j\}_{1 \leq j \leq n}}
    {\Delta \vdash \indexOp{f}(e_1, \ldots, e_n) : s}
  \end{mathpar}

  \smallskip

  \textbf{Well-indexed types}
  \begin{mathpar}
    \inferrule* [right=TyPrim]
    {\tyPrimNm{X} \in \mathit{PrimType} \\\\
      \primTyArity(\tyPrimNm{X}) = [s_1,\ldots,s_n] \\
      \{\Delta \vdash e_j : s_j\}_{1\leq j \leq n}}
    {\Delta \vdash \tyPrim{X}{e_1,\ldots,e_n} \isType}

    \inferrule* [right=TyUnit]
    { }
    {\Delta \vdash \tyUnit \isType}

    \inferrule* [right=TyArr]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyArr B \isType}

    \inferrule* [right=TyTuple]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyProduct B \isType}

    \inferrule* [right=TySum]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A + B \isType}
    
    \inferrule* [right=TyForall] %FIXME: macroize forall
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \forall i \mathord: s. A \isType}

    \inferrule* [right=TyEx]
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \exists i \mathord: s. A \isType}
  \end{mathpar}}
  \caption{Index expressions and types}
  \label{fig:indexes-and-types}
\end{figure*}
%Given the above data, 
The rules in \autoref{fig:indexes-and-types}
generate two judgements: well-sorted index expressions $\Delta \vdash
e : s$ and well-indexed types $\Delta \vdash A \isType$. Since index
variables may appear in types, types are judged to be well-indexed
with respect to an index context $\Delta$. The rules for well-sorted
index expressions are particularly simple: either an index expression
is a variable that appears in the context (rule \TirName{IVar}), or it
is an application of an index operation taken from $\IndexOpSet$ to
other index expressions (rule \TirName{IOp}). 
The rules for well-indexed types include the usual ones
%rules 
for
%constructing types of 
the simply-typed $\lambda$-calculus with unit, sum and tuple types
(rules \TirName{TyUnit}, \TirName{TyArr}, \TirName{TyTuple} and
\TirName{TySum}). 
We use $\tyPrimNm{bool}$ as an abbreviation for $\tyPrimNm{unit} + \tyPrimNm{unit}$.
The rule \TirName{TyPrim} %allows us to 
forms, from a primitive type $\tyPrimNm{X}$ and appropriately sorted
index expressions $e_1,\ldots,e_n$, the well-indexed type
$\tyPrim{X}{e_1,\ldots,e_n}$. The rule \TirName{TyForall} 
%permits the formation of 
forms universally quantified types, where the universal
quantification ranges over all index expressions of some
sort. Existential types, %are constructed 
formed using the \TirName{TyEx} rule,
%and 
allow for abstraction by hiding. %FIXME: think about the
%introduction of existentials more, perhaps forward ref to their use

\subsubsection{Substitution of Index Expressions}
\label{sec:simultaneous-substitution}

It %will be technically 
is convenient to express substitution of index
expressions %in our framework 
in terms of simultaneous substitutions.
Given a pair of index contexts $\Delta$ and $\Delta' = i_1 \mathord:
s_1, \ldots, i_n \mathord: s_n$, a (simultaneous) \emph{substitution}
$\Delta \vdash \sigma \Rightarrow \Delta'$ is a sequence of
expressions $\sigma = (e_1,\ldots,e_n)$ such that $\Delta \vdash e_j :
s_j$ for all $1 \leq j \leq n$. Given a substitution
$\Delta \vdash \sigma = (e_1,\ldots,e_n) \Rightarrow \Delta'$ and a
variable $i_j \mathord: s_j$ in $\Delta'$, we write $\sigma(i_j)$ for
the index expression $e_j$. We write $\Delta \Rightarrow \Delta'$ for
the set of all substitutions $\sigma$ such that $\Delta
\vdash \sigma \Rightarrow \Delta'$.
%
%It will be useful to 
We can think of any sequence of sorts as an index
context. In particular, we will make use of substitutions
of the form $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$, since these are exactly sequences of
index arguments suitable for the primitive type $\tyPrimNm{X}$. By
further abuse of notation, we write $\Delta \Rightarrow
\primTyArity(\tyPrimNm{X})$ for the set of all 
substitutions $\sigma$ such that $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$.

For a substitution $\Delta \vdash \sigma \Rightarrow
\Delta'$, where $\Delta' = i_1\mathord:s_1,\ldots,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
either $\Delta$ or $\Delta'$, we can form the \emph{lifted}
substitution $\Delta,i\mathord:s \vdash
\sigma_{i\mathord:s} = (\sigma(i_1), \ldots, \sigma(i_n), i) \Rightarrow
\Delta',i\mathord:s$. %Note that we have implicity used the fact that
%well-sortedness of index expressions is preserved by addition of extra
%items to the context.
%
Application of a substitution $\Delta \vdash \sigma
\Rightarrow \Delta'$ to a well-sorted index expression $\Delta' \vdash
e : s$ yields a well-sorted index expression $\Delta \vdash \sigma^*e
: s$. The expression $\sigma^*e$ is defined on variables as $\sigma^*i
\isDefinedAs \sigma(i)$, and on operation symbols as
$\sigma^*(\indexOp{f}(e_1,\ldots,e_n)) \isDefinedAs
\indexOp{f}(\sigma^*e_1, \ldots, \sigma^*e_n)$.  %Similarly, 
Given
%a well-indexed type 
$\Delta' \vdash A \isType$, 
%can apply $\sigma$ to $A$ to produce a new well-indexed type 
we have $\Delta \vdash \sigma^*A
\isType$. The key clauses defining $\sigma^*A$ are for primitive types
and the universal and existential quantifiers:
\begin{displaymath}
  \begin{array}{c}
    \sigma^*(\tyPrim{X}{e_1,\ldots,e_n}) \isDefinedAs \tyPrim{X}{\sigma^*e_1,\ldots,\sigma^*e_n}
    \\
    \begin{array}{c@{\hspace{2em}}c}
      \sigma^*(\forall i\mathord:s.A) \isDefinedAs \forall i\mathord:s.\sigma_{i\mathord:s}^*A
      &
      \sigma^*(\exists i\mathord:s.A) \isDefinedAs \exists i\mathord:s. \sigma_{i\mathord:s}^*A
    \end{array}
  \end{array}
\end{displaymath}
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e : s$, then $\Delta \vdash \sigma^*e : s$; and
%   \item If $\Delta' \vdash A \isType$, then $\Delta \vdash \sigma^*A
%     \isType$.
%   \end{enumerate}
% \end{lemma}
The \emph{identity} substitution $\Delta \vdash
\id_\Delta \Rightarrow \Delta$ is %just the sequence of variables in
%$\Delta$: 
$\id_\Delta = (i_1,\ldots,i_n)$ where $\Delta =
i_1\mathord:s_1,\ldots,i_n\mathord:s_n$. The \emph{composition} of 
two substitutions 
$\Delta \vdash \sigma \Rightarrow \Delta'$
and $\Delta' \vdash \sigma' \Rightarrow \Delta''$, where $\sigma' =
(e'_1,\ldots,e'_n)$, is defined as $\Delta \vdash \sigma' \circ \sigma
\isDefinedAs (\sigma^*e'_1, \ldots, \sigma^*e'_n) \Rightarrow \Delta''$.
%
Given a context $\Delta = i_1\mathord:s_1,\ldots,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
$\Delta$, we define the \emph{projection} substitution
$\Delta, i\mathord:s \vdash \pi_{i\mathord:s} \Rightarrow \Delta$ as
$\pi_{i\mathord:s} = (i_1,\ldots,i_n)$. %The subscript on
%$\pi_{i\mathord:s}$ is the variable/sort pair that is being discarded.

\subsubsection{Index Expression Equality and Type Equality}
\label{sec:type-equality}

Much of the power of indexing types by the expressions of an algebraic
theory comes from the equations of the theory. 
%In the %two-dimensional geometry example of 
For example, in 
\autoref{sec:motivating-examples} the types
$\tyPrim{vec}{B,t_1 + t_2}$ and $\tyPrim{vec}{B, t_2 + t_1}$ are
considered equal by the type system
%due to the commutativity of the $+$ operation.
because $+$ is commutative.
%
In the general framework, the equations between types are derived from
a set $\IndexAxiomSet$ of axioms $\Delta \vdash e \stackrel{ax}\equiv
e' : s$ that %We assume that all axioms $(\Delta \vdash e
%\stackrel{ax}\equiv e' : s)$ % \in \IndexAxiomSet$ 
are well-sorted, in the sense that both $\Delta \vdash e : s$ and $\Delta \vdash e' : s$
hold.

Given a set $\IndexAxiomSet$ of axioms, we generate the equality
judgment between index expressions $\Delta \vdash e \equiv e' : s$ by
a set of rules. The following rule lets us use substitution
instances of axioms:
\begin{displaymath}
  \inferrule*
  {(\Delta' \vdash e \stackrel{ax}\equiv e' : s) \in \IndexAxiomSet \\
    \Delta \vdash \sigma \Rightarrow \Delta'}
  {\Delta \vdash \sigma^*e \equiv \sigma^*e' : s}
\end{displaymath}
We also assume the standard congruence, reflexivity, symmetry and
transitivity rules for the equality judgment.

\begin{example*}[Geometry: axioms]
  \label{ex:two-dim-geo-axioms}
  In \autoref{sec:motivating-examples} we assumed 
  %that 
  various equational axioms %hold 
  for indexing expressions standing for
  elements of geometric groups. Assuming the abelian group axioms for
  translations we can formalise this in our %general 
  framework:
  %We can now make this assumption formal
  %in our general framework. Semantically, translations form an abelian
  %group under addition, so we assume the abelian group axioms for
  %translations:
  \begin{displaymath}
    \begin{array}{l}
      t : \SynTransl{2} \vdash t + 0 \stackrel{ax}\equiv t : \SynTransl{2} \\
      t_1, t_2, t_3 : \SynTransl{2} \vdash t_1 + (t_2 + t_3) \stackrel{ax}\equiv (t_1 + t_2) + t_3 : \SynTransl{2} \\
      t : \SynTransl{2} \vdash t + (-t) \stackrel{ax}\equiv 0 : \SynTransl{2} \\
      t_1, t_2 : \SynTransl{2} \vdash t_1 + t_2 \stackrel{ax}\equiv t_2 + t_1 : \SynTransl{2} \\
    \end{array}
  \end{displaymath}
  Similarly, the sort of scale factors $\SynGL{1}$ forms an abelian
  group under multiplication, and the sorts $\SynGL{2}$ and
  $\SynOrth{2}$ form (non-abelian) multiplicative groups, so we assume
  the appropriate axioms. We also assume that the operations $\iota_O,
  \iota_1, \det$ and $\abs{\cdot}$ are group homomorphisms, and that
  expressions of the form $\iota_1(s)$ commute with group
  multiplication in the sort $\SynGL{2}$. The absolute value of the
  determinant of an orthgonal transformation is always $1$, so we also
  assume $\abs{\det(\iota_OO)} \stackrel{ax}\equiv 1$. Similarly,
  scaling maps have a determinant expressible in terms of other
  operations: $\det(\iota_1(s)) \stackrel{ax}\equiv s \cdot s$. We
  also assume the axiom $|s^2| \stackrel{ax}\equiv s^2$.  \qed
\end{example*}

The equality judgment $\Delta \vdash e \equiv e' : s$ on index
expressions generates the equality judgment $\Delta \vdash A \equiv
B \isType$ on types. The basic rule generating equality judgments on
types equates %states that %two 
applications of primitive types %are equal 
if
their %index expression 
arguments are equal:
\begin{displaymath}
  \inferrule*
  {\{ \Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j \leq n}}
  {\Delta \vdash \tyPrim{X}{e_1,\ldots,e_n} \equiv \tyPrim{X}{e'_1,\ldots,e'_n} \isType}
\end{displaymath}
The rest of the rules for equality on types ensure that it is a
congruence relation 
and an equivalence relation.
%on types. %and that it is an equivalence relation
%(i.e.,~equality on types is reflexive, symmetric and transitive).
% For example, for universally quantified types we have
% the following congruence rule:
% \begin{displaymath}
%   \inferrule*
%   {\Delta, i : s \vdash A \equiv B \isType}
%   {\Delta \vdash \forall i\mathord:s.A \equiv \forall i\mathord:s.B \isType}
% \end{displaymath}
% The congruence rules for the other type formers are similar.

% FIXME: think about integrating this lemma into the running text
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e \equiv e' : s$ then $\Delta \vdash
%     \sigma^*e \equiv \sigma^*e' : s$; and
%   \item If $\Delta' \vdash A \equiv B \isType$ then $\Delta \vdash
%     \sigma^*A \equiv \sigma^* B \isType$.
%   \end{enumerate}
% \end{lemma}

%A pair of 
The substitutions $\Delta \vdash \sigma \Rightarrow
\Delta'$ and $\Delta \vdash \sigma' \Rightarrow \Delta'$ are defined
to be equal, and written  $\Delta \vdash \sigma \equiv \sigma' \Rightarrow
\Delta'$, if their component expressions are equal in the context
$\Delta$: i.e.,~ if $\Delta \vdash e_j \equiv e'_j : s_j$, for all
$j$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Well-typed terms}
\label{sec:well-typed-programs}

We now present the rules for well-typed terms over the 
collection of 
types we defined 
in \autoref{sec:algebraically-indexed-types}. 

%Each
%well-typed program is assigned an index-erasure semantics, building on
%the index-erasure semantics of types %we defined 
%in \autoref{sec:index-erasure-semantics}. Our main result
%(\thmref{thm:abstraction}) is that the index-erasure semantics of
%every well-typed program is related to itself in the relational
%interpretation of its type: this is the abstraction theorem for every
%instantiation of our general framework.

Well-typed terms are defined with respect to well-indexed typing
contexts, which are in turn defined with respect to an index
context. Well-indexed typing contexts with respect to an index context
$\Delta$ are sequences of variable/type pairs with no repeated
variable names such that each type is well-indexed with respect to
$\Delta$. Formally, well-indexed typing contexts are 
given by
%defined by the following two rules:
\begin{mathpar}
  \inferrule*
  { }
  {\Delta \vdash \epsilon \isCtxt}

  \inferrule*
  {\Delta \vdash \Gamma \isCtxt \\ \Delta \vdash A \isType \\ x \not\in \Gamma}
  {\Delta \vdash \Gamma, x : A \isCtxt}
\end{mathpar}
Application of substitutions extends to typing contexts
by applying the substitution to each type.

%The typing rules for our framework define 
Well-typed terms
are defined
with respect to an index context $\Delta$ and a type context $\Delta \vdash
\Gamma \isCtxt$. The judgment $\Delta; \Gamma \vdash M : A$ is defined
in \autoref{fig:programs}. The equational theory on types is
incorporated into the type system via the rule \TirName{TyEq}, which
allows a term that has %is judged to have 
type $A$ to also have any
%other 
equal type $B$ as well.
\begin{figure*}[t]
  \centering
  {\small
  \begin{mathpar}
    \inferrule* [right=Var]
    {\Delta \vdash \Gamma \isCtxt \\ x : A \in \Gamma}
    {\Delta; \Gamma \vdash x : A}

    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash M : A \\ \Delta \vdash A \equiv B \isType}
    {\Delta; \Gamma \vdash M : B}

    \inferrule* [right=Unit]
    {\Delta \vdash \Gamma \isCtxt}
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash M : A \\
      \Delta; \Gamma \vdash N : B}
    {\Delta; \Gamma \vdash (M, N) : A \tyProduct B}

    \inferrule* [right=Proj1]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_1 M : A}

    \inferrule* [right=Proj2]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_2 M : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \mathrm{inl}\ M : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash M : B}
    {\Delta; \Gamma \vdash \mathrm{inr}\ M : A + B}

    \inferrule* [right=Case]
    {\Delta; \Gamma \vdash M : A + B \\\\
      \Delta; \Gamma, x : A \vdash N_1 : C \\\\
      \Delta; \Gamma, y : B \vdash N_2 : C}
    {\Delta; \Gamma \vdash \textrm{case}\ M\ \textrm{of}\ \textrm{inl}\ x.N_1; \textrm{inr}\ y.N_2 : C}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, x : A \vdash M : B}
    {\Delta; \Gamma \vdash \lambda x.M : A \tyArr B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash M : A \tyArr B \\
      \Delta; \Gamma \vdash N : A}
    {\Delta; \Gamma \vdash M N : B}

    \inferrule* [right=UnivAbs]
    {\Delta, i \mathord: s; \pi_{i\mathord:s}^*\Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \Lambda i. M : \forall i\mathord:s. A}

    \inferrule* [right=UnivApp]
    {\Delta; \Gamma \vdash M : \forall i\mathord:s. A \\ \Delta \vdash e : s}
    {\Delta; \Gamma \vdash M [e] : (\id_\Delta, e)^*A}

    \inferrule* [right=ExPack]
    {\Delta; \Gamma \vdash M : (\id_\Delta, e)^*A \\ \Delta \vdash e : s \\ \Delta, i\mathord:s \vdash A \isType}
    {\Delta; \Gamma \vdash \langle[e], M\rangle: \exists i\mathord:s. A}

    \inferrule* [right=ExUnpack]
    {\Delta; \Gamma \vdash M : \exists i\mathord:s. A \\\\
      \Delta, i\mathord:s; \pi_{i\mathord:s}^*\Gamma, x : A \vdash N : \pi_{i\mathord:s}^*B}
    {\Delta; \Gamma \vdash \mathrm{let}\langle[i],x\rangle = M\ \mathrm{in}\ N : B}
  \end{mathpar}}
  
  \caption{Well-typed terms}
  \label{fig:programs}
\end{figure*}

For any particular theory we assume that there is a closed
typing context $\opsCtxt$ that describes the types of the primitive operations.
\begin{example*}[Geometry: operations]
For geometry $\opsCtxt$ would collect together the types of primitive operations as 
listed in \autoref{fig:real-ops} and \autoref{fig:vec-ops}.
\qed
\end{example*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Index-Erasure Semantics}
\label{sec:erasure-semantics}
%\fixme{Make sure that the semantics is motivated}
Having defined the syntax of algebraically indexed types and terms,
we turn to their denotational interpretation.  We first define an
\emph{index-erasure} interpretation of types and terms that interprets
every well-indexed type as a set, ignoring the indexing
expressions, and which interprets open terms as functions that map environments
to final values.
%Building on the index-erasure semantics, we
%We then define in
%\autoref{sec:relational-semantics} the relational
%interpretation of types.

% For both of our semantics of types, we state and prove two properties:
% types that are syntactically equal have equal denotations, and that
% substitution of index terms is interpreted via composition. These
% properties ensure that our semantics of types is well-behaved.

\paragraph{Interpretation of Types.}
%\label{sec:index-erasure-semantics}

The defining feature of the index erasure interpretation is that 
semantics of a well-indexed type $\tyPrim{X}{e_1,\ldots,e_n}$ is
determined solely by the primitive type $\tyPrimNm{X}$ and not by the
index expressions $e_1,\ldots,e_n$. %Accordingly, 
We thus assume each
primitive type $\tyPrimNm{X} \in \PrimTypeSet$ is assigned a set
$\tyPrimSem{\tyPrimNm{X}}$ and %We 
extend this assignment to %every
well-indexed types by induction on the type structure:
\begin{displaymath}
  \begin{array}{@{}c@{\hspace{0em}}c@{}}
    \begin{array}{@{}l}
      \tySem{\tyUnit} \isDefinedAs \{*\} \\
      \tySem{A \tyProduct B} \isDefinedAs \tySem{A} \times \tySem{B} \\
      \tySem{A \tyArr B} \isDefinedAs \tySem{A} \to \tySem{B} \\
    \end{array}
    &
    \begin{array}{l}
      \tySem{A + B} \isDefinedAs \tySem{A} + \tySem{B} \\
      \tySem{\tyPrim{X}{e_1,\ldots,e_n}} \isDefinedAs \tyPrimSem{\tyPrimNm{X}} \\
      \tySem{\forall i\mathord:s. A} \isDefinedAs \tySem{A} \\
      \tySem{\exists i\mathord:s. A} \isDefinedAs \tySem{A}
    \end{array}
  \end{array}
\end{displaymath}
(We will overload the
notation $\tmSem\cdot$ for all index-erasure interpretations, 
and reserve notation $\llbracket\cdot\rrbracket$ for the
index-observing relational semantics defined later.)
% The interpretation of the unit type is a chosen one element set, and
% the interpretations of the function, tuple and sum types are simply
% the corresponding constructions on sets. 
%: the
%interpretation of the type $\forall i\mathord:s.A$ is exactly the
%interpretation of the type $A$, and likewise for $\exists
%i\mathord:s.A$.

The index-erasure interpretation completely ignores index expressions
and quantifiers, and type equality is defined as an extension of index
equality. Therefore, it is straightforward to prove that equal types
have equal denotations when interpreted in the index-erasure
semantics, and that substitution of index terms has no effect on the
index-erasure interpretation of types:
\begin{lemma}\label{lem:tyeqsubst-erasure}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$ then $\tySem{A} =
    \tySem{B}$; and
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then $\tySem{\sigma^*A} = \tySem{A}$.
  \end{enumerate}
\end{lemma}

\paragraph{Interpretation of Terms.}

% FIXME: do we need to prove something about the effect
% of substitution on the erasure semantics of contexts?

We assign an index-erasure semantics to any well-indexed typing
context $\Delta \vdash \Gamma \isCtxt$ by induction:
$\ctxtSem{\epsilon} = \{*\}$ and $\ctxtSem{\Gamma, x : A} =
\ctxtSem{\Gamma} \times \tySem{A}$. For a well-typed term $\Delta;
\Gamma \vdash M : A$, we define the \emph{erasure interpretation} as a
function $\tmSem{M} : \ctxtSem{\Gamma} \to \tySem{A}$ that completely
ignores the indexing information. In light of
\lemref{lem:tyeqsubst-erasure}, we do this %we define this function is defined
directly on the syntax of well-typed terms, rather than on typing
derivations. The definition of $\tmSem{M}$ is completely standard,
except for the clauses for universal and existential types:
\begin{displaymath}
  \begin{array}{@{}l}
    \begin{array}{@{}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{\hspace{2em}}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{}}
      \tmSem{\Lambda i.\ M}\eta & \isDefinedAs & \tmSem{M}\eta
      &
      \tmSem{M[e]}\eta & \isDefinedAs & \tmSem{M}\eta \\
      \tmSem{\langle [e], M\rangle}\eta & \isDefinedAs & \tmSem{M}\eta
    \end{array} \\
    \tmSem{\mathrm{let}\langle[i], x\rangle = M\ \mathrm{in}\ N}\eta \isDefinedAs \tmSem{N}(\eta, \tmSem{M}\eta)
  \end{array}
\end{displaymath}

For any particular theory we assume that there is an
interpretation of the primitive operations $\opsEnv \in \ctxtSem{\opsCtxt}$.

\begin{example*}[Geometry: interpretation]
  The two-dimensional geometry instantiation of the general framework
  uses the assignment $\tyPrimSem{\tyPrimNm{vec}} = \mathbb{R}^2$ and
  $\tyPrimSem{\tyPrimNm{real}} = \mathbb{R}$.
  We assume that $\opsEnv$ gives the usual interpretation to scalar
  and vector operations from
  \autoref{fig:real-ops} and \autoref{fig:vec-ops}.
\qed
\end{example*}



\paragraph{Contextual Equivalence.}
We use our index-erasure semantics to define when a pair of terms are
contextually equivalent with respect to syntactically defined
contexts, following Hofmann \cite{hofmann08correctness}.  Given an
index context $\Delta = i_1\mathord:s_1,...,i_n\mathord:s_n$, we write
$\forall \Delta.A$ for $\forall i_1\mathord:s_1.\dots\forall
i_n\mathord:s_n.A$, and similarly for $\Lambda\Delta.M$ and $\lambda
\Gamma.M$.
\begin{definition}[Contextual Equivalence]\label{defn:ctxt-equiv}
Two terms $\Delta; \opsCtxt, \Gamma \vdash M_1, M_2 : A$
are \emph{contextually equivalent}, written $\ctxteq\Delta\Gamma{M_1}{M_2}A$, if 
  for all
  contexts $\cdot;\opsCtxt \vdash C : (\forall \Delta. \Gamma
  \to A) \to \tyPrimNm{bool}$, it is the case that $\tmSem{C\ (\Lambda
    \Delta. \lambda \Gamma. M_1)}\opsEnv = \tmSem{C\
    (\Lambda \Delta. \lambda \Gamma. M_2)}\opsEnv$.
\end{definition}


\paragraph{Type Isomorphism.}
We say that well-indexed types $\Delta \vdash A \isType$ and $\Delta\vdash B \isType$
are isomorphic, and write $\Delta\vdash A \cong
B$, if there exist maps between them that are mutually inverse with
respect to contextual equivalence, i.e., if there are terms $\Delta\vdash I
: A \to B$ and $\Delta\vdash J : B\to A$ such that $\ctxteq{\Delta}{x:A}{J(I(x))}{x}{A}$ 
and $\ctxteq{\Delta}{y:B}{I(J(y))} y B$.
%\[
%x:A\vdash J(I(x))\stackrel{ctx}\approx x : A
%\text{ and }y:B\vdash I(J(y))\stackrel{ctx}\approx y : B.
%\]
That $\cong$ is a congruence with respect to the type formation rules
of \autoref{fig:indexes-and-types} is straightforward. We can also
derive isomorphisms that are independent of the indexing theory, such
as $\Delta\vdash A\times B \cong B \times A$, and $\Delta\vdash\forall
i\mathord:s.(A\to B)\cong A\to\forall i\mathord:s.B$ for $i$ not free in $A$.

\subsection{The Relational Interpretation of Types}
\label{sec:relational-semantics}

%We now define 
The relational semantics of the well-indexed type
$\Delta \vdash A \isType$ is a binary relation on the index-erasure
interpretation of $A$. We write $\Rel(X)$ for the set
of binary relations $R \subseteq X \times X$ on the set $X$.

For the unit, tuple, sum and function types we define the
relational interpretation as a standard logical relation. The
relational interpretations of primitive types with index arguments and
the universally quantified types require an interpretation of index
contexts.

A \emph{relational environment} $\rho$ assigns to each index variable $i:s$
in the context $\Delta$ a value drawn from an interpretation of
the sort $s$ that soundly models the equational theory associated with $s$. We call
such an interpretation a \emph{model}: it assigns to each index operation in the equational 
theory a corresponding operation in the interpretation, so that index expressions 
can be interpreted by recursion on their structure. 

For example, the sort $\SynTransl{2}$ of translations can be modelled by
any abelian group. An obvious candidate here is the additive group over 
$\mathbb R^2$, which we will use to obtain invariance under translation;
but we could use the additive group $\mathbb Q$, or even a finite group such as the 
two-element group $\mathbb Z_2$. 

\paragraph{Models.}
A \emph{model} 
%$\mathcal{M}$ 
assigns to each sort $s \in \SortSet$ a
carrier set $\semSort s$, and assigns to each operation $\texttt{f}
\in \IndexOpSet$ with $\indexOpArity(\texttt{f}) =
([s_1,\ldots,s_n],s)$, a function $\semIndexExp{\texttt{f}} :
\semSort{s_1}\times\cdots\times\semSort{s_n} \to \semSort{s}$.

An index context $\Delta = (i_1\mathord:s_1,\ldots,i_n\mathord:s_n)$ is
interpreted as cartesian product,x i.e., $\semSort{\Delta} \isDefinedAs \semSort{s_1}
\times\cdots \times \semSort{s_n}$. 
For each well-sorted index expression $\Delta \vdash
e : s$, we assign a function $\semIndexExp{e} : \semSort{\Delta} \to
\semSort{s}$ by recursion on the structure of~$e$:
\begin{align*}
\semIndexExp{i} \rho & \isDefinedAs \rho(i) &
\semIndexExp{\indexOp{f}(e_1, \ldots, e_n)} \rho & \isDefinedAs \semIndexExp{\indexOp{f}}(
\semIndexExp{e_1}\rho,\ldots,\semIndexExp{e_n}\rho)
\end{align*}

Finally, a model
% $\mathcal{M}$
must be sound, that is, for each axiom $\Delta \vdash e \stackrel{ax}\equiv e' : s \in
\IndexAxiomSet$, we have $\semIndexExp{e} = \semIndexExp{e'}$. 

\begin{example*}[Geometry: affine model]
We define the model
% $\mathcal{M}$ 
of the indexing theory for the two-dimensional
geometry example as follows. Each of the sorts is interpreted just as
its semantic counterpart: 
%$\semSort{\SynTransl{2}}M = \Transl{2}$, $
%\semSort{\SynGL{2}}M = \GL{2}$, $ \semSort{\SynOrth{2}}M = \Orth{2}$,
%and $ \semSort{\SynGL{1}}M = \GL{1}$.
\begin{align*}
\semSort{\SynTransl{2}} & = \Transl{2}
&\semSort{\SynGL{2}} & = \GL{2} &
\semSort{\SynOrth{2}} & = \Orth{2}
&\semSort{\SynGL{1}} & = \GL{1}
\end{align*}
Each of the index operations (e.g.,~the group structure and
determinant) is interpreted by the intended semantic operation, and
clearly satisfies the axioms in \exref{ex:two-dim-geo-axioms}. 
\qed
\end{example*}

Given $\rho \in \semSort{\Delta}$ and a substitution
$\Delta \vdash \sigma \Rightarrow \Delta'$ with $\sigma = (e_1,\ldots,e_n)$, 
we can derive the composed
relational environment $\rho \circ \sigma
\in \semSort{\Delta'}$ as $\rho \circ \sigma \isDefinedAs (\semIndexExp{e_1}\rho,\ldots,\semIndexExp{e_n}\rho)$.

%A
%\emph{model} is a pair $\mathcal{M} = (\semSort{\cdot}_{\mathcal{M}},
%\semIndexExp{\cdot}_{\mathcal{M}})$ satisfying all the axioms in
%$\IndexAxiomSet$.

\paragraph{Relational interpretation of primitive types.}
Having fixed a model
% $\mathcal{M}$ 
we next choose a relational interpretation 
%$\mathcal{R}$ 
of
primitive types: for each each primitive type
$\tyPrimNm{X}$, its relational interpretation is parameterised by elements
from the model: $\semPrimType{\tyPrimNm{X}} :
\semSort{\primTyArity(\tyPrimNm{X})} \to \Rel(\tyPrimSem{\tyPrimNm{X}})$. 

\begin{example*}[Geometry: change of basis interpretation]
Given the model of geometric groups described above,
for the relational interpretation  of $\tyPrim{vec}{B,t}$ and
$\tyPrim{real}{s}$, we use $\semPrimType{\tyPrimNm{vec}}(B,\vec{t}) = \{
(\vec{v}, B\vec{v} + \vec{t}) \sepbar \vec{v} \in \mathbb{R}^2 \}$ and
$\semPrimType{\tyPrimNm{real}}(k) = \{ (x, kx) \sepbar x \in \mathbb{R} \}$.
\qed
\end{example*}

\paragraph{Relational interpretation of types.}
We assign a relational interpretation to all well-indexed types $\Delta
\vdash A \isType$ by induction on their derivations, parameterised by
relational environments 
$\rho \in \semSort{\Delta}$:
\begin{eqnarray*}
%  \rsem{\Delta \vdash A \isType}M R & : & \semSort\Delta  \to \Rel(\tyPrimSem{A})\\
  \rsem{\tyUnit} \rho & \isDefinedAs & \{(*,*)\} \\
  \rsem{\tyPrim{X}{e_1,\ldots,e_n}}\rho & \isDefinedAs & 
  \semPrimType{\tyPrimNm{X}} (\semIndexExp{e_1}\rho, \ldots,
  \semIndexExp{e_n}\rho)\\
  \rsem{A \tyArr B} \rho & \isDefinedAs & \rsem{A}\rho \relArrow \rsem{B} \rho \\
  \rsem{A \tyProduct B}\rho & \isDefinedAs & \rsem{A} \rho \relTimes \rsem{B} \rho \\
  \rsem{A + B} \rho & \isDefinedAs & \rsem{A} \rho \relSum \rsem{B} \rho \\
  \rsem{\forall i\mathord:s.A} \rho & \isDefinedAs & 
  \bigcap\{ \rsem{A} {(\rho,m)} \sepbar m \in \semSort{s} \} \\
  \rsem{\exists i\mathord:s.A} \rho & \isDefinedAs & 
  \bigcup\{ \rsem{A} {(\rho,m)} \sepbar m \in \semSort{s} \}
\end{eqnarray*}
In this definition we have used the following standard %three
constructions on binary relations: if $R \in \Rel(X)$ and $S \in
\Rel(Y)$, then $R \relArrow S \in \Rel(X \to Y)$ is %defined as 
$\{(f_1,f_2) \sepbar \forall (a_1,a_2) \in R.\ (f_1a_1,f_2a_2) \in S
\}$, and %. With the same assumptions on $R$ and $S$, the relation 
$R
\relTimes S \in \Rel(X \times Y)$ is %defined as 
$\{((a_1,b_1),(a_2,b_2)) \sepbar (a_1,a_2) \in R \land (b_1,b_2) \in S
\}$, and %. Finally, the relation 
$R \relSum S \in \Rel(X + Y)$ is %defined as
$\{ (\mathrm{inl}\ x, \mathrm{inl}\ x') \sepbar (x,x') \in R \} \cup
\{ (\mathrm{inr}\ y, \mathrm{inr}\ y') \sepbar (y,y') \in S \}$.

The following lemma states that the relational interpretation of types
that we have defined in this section behaves well: the first part of
the lemma states that two types that are judgmentally equal are given
equal relational interpretations, and the second part states that
substitution of index expressions in types can be interpreted by the
composition of relational environments with 
substitutions.
\begin{lemma}\label{lem:tyeqsubst-relational}
\par
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$, then $\rsem{A} =  \rsem{B}$;
  \item If $\Delta' \vdash A \isType$ then for all $\Delta \vdash \sigma \Rightarrow
    \Delta'$ and $\rho \in \semSort{\Delta}$,
    $\rsem{\sigma^*A} \rho = \rsem{A}(\rho \circ \sigma)$.
  \end{enumerate}
\end{lemma}
\noindent
Note that the equations in both parts of
\lemref{lem:tyeqsubst-relational} are well-typed by virtue of the
corresponding parts of \lemref{lem:tyeqsubst-erasure}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Abstraction Theorem and Semantic Equivalence}
\label{sec:abstraction-theorem}

Our main result
(\thmref{thm:abstraction}) is that the index-erasure semantics of
every well-typed term is related to itself in the relational
interpretation of its type: this is the Abstraction Theorem for every
instantiation of our general framework.

\paragraph{The Abstraction Theorem.}
%\label{sec:abstraction-theorem}

We now state the Abstraction Theorem for well-typed terms. To state
and prove this theorem for open terms, we extend the
relational interpretation of types to typing contexts. The relational
interpretation of contexts is defined by: % the following clauses: %, where
%we have used the relational lifting of cartesian product $-\relTimes-$
%defined in \autoref{sec:relational-semantics}.
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l@{\hspace{1.5em}}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l}
    \rsem{\epsilon} {\rho} & \{(*,*)\} &
    \rsem{\Gamma, x : A} {\rho} & \rsem{\Gamma} \rho \relTimes \rsem{A} \rho
  \end{array}
\end{displaymath}

The relational interpretation of contexts inherits from the relational
interpretation of types the property of interpreting the application
of substitutions as composition:
\begin{lemma}\label{lem:ctxtsubst-rel}
  If $\Delta' \vdash \Gamma \isCtxt$ and $\Delta \vdash \sigma
  \Rightarrow \Delta'$, then for all $\rho \in \semSort{\Delta}$,
we have 
  $\rsem{\sigma^*\Gamma} \rho =
  \rsem{\Gamma}(\rho \circ \sigma)$.
\end{lemma}

Given a particular choice of model and relational interpretation of
primitive types, we can then prove the following.
\begin{theorem}[Abstraction]\label{thm:abstraction}
  If $\Delta; \Gamma \vdash M :
  A$, then for all $\rho \in \semSort{\Delta}$ and $\eta_1, \eta_2
  \in \ctxtSem{\Gamma}$ such that $(\eta_1, \eta_2) \in
  \rsem{\Gamma} \rho$, we have $(\tmSem{M}\eta_1,
  \tmSem{M}\eta_2) \in \rsem{A} \rho$.
\end{theorem}
\begin{proof}
By induction on the typing derivation, making use of
Lemma~\ref{lem:tyeqsubst-relational} (part 1) for rule \TirName{TyEq},
Lemma~\ref{lem:tyeqsubst-relational} (part 2) for rules \TirName{UnivApp} and \TirName{ExPack},
and Lemma~\ref{lem:ctxtsubst-rel} for rules \TirName{UnivAbs} and \TirName{ExUnpack}. 
The details can be found in the Coq development.
\end{proof}

Semantic equivalence of terms is defined in terms of the relational
interpretation. As a consequence of \thmref{thm:abstraction}, semantic
equivalence is a sound approximation of contextual equivalence.

  Let $\opsCtxt$ be the context of primitive operations and $\opsEnv$  its interpretation 
%as in
%  \defref{defn:ctxt-equiv}.
Fix a model and relational interpretation of primitive types so that
  $(\opsEnv, \opsEnv) \in  \rsem{\opsCtxt} *$.

\begin{definition}[Semantic equivalence]\label{def:semantic-equality}
  Two terms $\Delta; \opsCtxt, \Gamma \vdash M_1 , M_2 : A$
  are
  \emph{semantically equal},
  written $\semeq \Delta\Gamma{M_1}{M_2} A$, if for all $\rho \in
  \semSort{\Delta}$, and all $(\eta_1,\eta_2) \in
  \rsem{\Gamma} \rho$, we have
  $(\tmSem{M_1}(\opsEnv,
  \eta_1),\tmSem{M_2}(\opsEnv, \eta_2)) \in
  \rsem{A}\rho$.
\end{definition}

\begin{theorem}[Soundness]\label{thm:soundness}
If $\semeq \Delta\Gamma {M_1}{M_2} A$ then
$\ctxteq \Delta \Gamma {M_1}{M_2}A$.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
