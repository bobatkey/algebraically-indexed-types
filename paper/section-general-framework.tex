\section{A General Framework}
\label{sec:a-general-framework}

We now present a general framework for discussing
algebraically-indexed types and representation independence. We define
the syntax of algebraically-indexed types, then their semantics and
finally we present a general programming language for
algebraically-indexed types, with an abstraction theorem.

\subsection{Algebraically-Indexed Types}
\label{sec:algebraically-indexed-types}

The index expressions and types of an instantiation of our general
framework are derived from the following data:
\begin{enumerate}
\item A collection $\SortSet$ of index sorts. We will use the
  meta-syntactic variables $s,s_1,s_2,...$ and so on to stand for
  arbitrary sorts taken from $\SortSet$.
\item A collection $\IndexOpSet$ of index operations, with a function
  $\indexOpArity : \IndexOpSet \to \SortSet^* \times \SortSet$ (we use
  the notation $A^*$ to denote the set of lists of elements of some
  set $A$).
\item A collection $\PrimTypeSet$ of primitive types, with a function
  $\primTyArity : \PrimTypeSet \to \SortSet^*$, describing the sorts
  of the arguments of each primitive type.
\end{enumerate}

\begin{example}[Two-Dimensional Geometry]
  The two-dimensional geometry system has a sort for each of the
  geometric groups that we mentioned in
  \autoref{sec:motivating-examples}. Thus, $\SortSet = \{\SynTransl_2,
  \SynGL_2, \SynOrth_2, \SynGL_1 \}$. For the index operations, we
  have additive group structure on $\SynTransl_2$, multiplicative
  group structure on $\SynGL_1$, $\SynGL_2$ and $\SynOrth_2$,
  injections from $\SynOrth_2$ and $\SynGL_1$ into $\SynGL_2$,
  determinant and absolute value. Thus, $\IndexOpSet = \{ 0, +, -,
  1_G, -\cdot_G-, -^{-1_G}, \iota_O, \iota_1, \det, |\cdot| \}$, where
  $G \in \{\SynGL_1, \SynGL_2, \SynOrth_1\}$, with the following
  assignment of arities:
  \begin{displaymath}
    \begin{array}{@{}l@{\hspace{0em}=\hspace{0em}}l@{\hspace{0.5em}}l@{\hspace{0em}=\hspace{0em}}l}
      \indexOpArity(0) & ([], \SynTransl_2) &
      \indexOpArity(1_G) & ([], G) \\
      \indexOpArity(+) & ([\SynTransl_2, \SynTransl_2], \SynTransl_2) &
      \indexOpArity(\cdot_G) & ([G,G],G) \\
      \indexOpArity(-) & ([\SynTransl_2], \SynTransl_2) &
      \indexOpArity(^{-1_G}) & ([G], G) \\
      \indexOpArity(\iota_o) & ([\SynOrth_2], \SynGL_2) &
      \indexOpArity(\iota_1) & ([\SynGL_1], \SynGL_2) \\
      \indexOpArity(\det) & ([\SynGL_2], \SynGL_1) &
      \indexOpArity(|\cdot|) & ([\SynGL_1], \SynGL_1)
    \end{array}
  \end{displaymath}
  The intended interpretations of the top three pairs of operations
  are group unit, group combination and group negation,
  respectively. When we introduce equational theories for index
  expressions in \autoref{sec:type-equality} below, we will impose the
  (abelian) group laws. For this example, we have $\PrimTypeSet = \{
  \tyPrimNm{vec}, \tyPrimNm{real} \}$, with
  $\primTyArity(\tyPrimNm{vec}) = [\SynGL_2, \SynTransl_2]$ and
  $\primTyArity(\tyPrimNm{real}) = [\SynGL_1]$.
\end{example}

% \begin{example}[Logical Information Flow]
%   \fixme{Do this}
% \end{example}

% \begin{example}[Units of Measure]
%   To instantiate our general framework as Kennedy's original units
%   of measure system, we would take the following settings. For the
%   collection of sorts we take $\SortSet = \{ \mathsf{unit} \}$. For
%   the collection of index operations, we take $\mathit{IndexOp} = \{1,
%   -\cdot-, -^{-1}\}$, with:
%   \begin{eqnarray*}
%     \indexOpArity{(1)} &=& ([],\mathsf{unit}) \\
%     \indexOpArity{(-\cdot-)} & = & ([\mathsf{unit},\mathsf{unit}],\mathsf{unit}) \\
%     \indexOpArity{(-^{-1})} & = & ([\mathsf{unit}],\mathsf{unit})
%   \end{eqnarray*}
%   The intended interpretation of these operations is group unit, group
%   multiplication and group inverse, respectively. When we discuss
%   equational theories for index expressions in
%   \autoref{sec:type-equality} below, we will impose the abelian group
%   laws on these operations.

%   The primitive types for the units of measure example are taken to be
%   $\PrimTypeSet = \{ \mathsf{num} \}$, with
%   $\primTyArity(\mathsf{num}) = [\mathsf{unit}]$.
% \end{example}

We assume a countably infinite collection of index variable names $i,
i_1, i_2,$ and so on. \emph{Index contexts} $\Delta = i_1 \mathord:
s_1, ..., i_n \mathord: s_n$ are lists of index expression
variable/sort pairs, such that all the index variable names are
distinct.

\begin{figure*}[t]
  \centering
  \textbf{Index contexts}\\

  $\Delta = i_1 \mathord: s_1, ..., i_n \mathord: s_n$, where each $s_i \in \SortSet$ and no variable name is repeated.

  \bigskip

  \textbf{Well-sorted index expressions}
  \begin{mathpar}
    \inferrule* [right=IVar]
    {i : s \in \Delta}
    {\Delta \vdash i : s}
    
    \inferrule* [right=IOp]
    {\indexOp{f} \in \mathit{IndexOp} \\
      \indexOpArity(\indexOp{f}) = ([s_1,...,s_n], s) \\
      \{\Delta \vdash e_j : s_j\}_{1 \leq j \leq n}}
    {\Delta \vdash \indexOp{f}(e_1, ..., e_n) : s}
  \end{mathpar}

  \bigskip

  \textbf{Well-indexed types}
  \begin{mathpar}
    \inferrule* [right=TyPrim]
    {\tyPrimNm{X} \in \mathit{PrimType} \\\\
      \primTyArity(\tyPrimNm{X}) = [s_1,...,s_n] \\
      \{\Delta \vdash e_j : s_j\}_{1\leq j \leq n}}
    {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \isType}

    \inferrule* [right=TyUnit]
    { }
    {\Delta \vdash \tyUnit \isType}

    \inferrule* [right=TyArr]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyArr B \isType}

    \inferrule* [right=TyTuple]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyProduct B \isType}

    \inferrule* [right=TySum]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A + B \isType}
    
    \inferrule* [right=TyForall] %FIXME: macroize forall
    {\Delta, i : s \vdash A \isType}
    {\Delta \vdash \forall i \mathord: s. A \isType}
  \end{mathpar}
  \caption{Index expressions and types}
  \label{fig:indexes-and-types}
\end{figure*}

Given the above data, the rules in \autoref{fig:indexes-and-types}
generate two judgements: well-sorted index expressions $\Delta \vdash
e : s$ and well-indexed types $\Delta \vdash A \isType$. Since index
variables may appear in types, types are judged to be well-indexed
with respect to an index context $\Delta$. The rules for well-sorted
index expressions are particularly simple: either an index expression
is a variable that appears in the context (rule \TirName{IVar}), or it
is an application of an index operation taken from $\IndexOpSet$ to
other index expressions (rule \TirName{IOp}). The rules for
well-indexed types include the usual rules for constructing types of
the simply-typed $\lambda$-calculus with unit, sum and tuple types
(rules \TirName{TyUnit}, \TirName{TyArr}, \TirName{TyTuple} and
\TirName{TySum}). The rule \TirName{TyPrim} allows us to form, from a
a primitive type $\tyPrimNm{X}$ and appropriately sorted index
expressions $e_1,...,e_n$, the well-indexed type
$\tyPrim{X}{e_1,...,e_n}$. The rule \TirName{TyForall} permits the
formation of universally quantified types, where the universal
quantification ranges over all index expressions of some sort.

\subsubsection{Simultaneous Substitution of Index Expressions}
\label{sec:simultaneous-substitution}

It will be technically convenient to express substitution of index
expressions in our framework in terms of simultaneous substitutions.
Given a pair of index contexts $\Delta$ and $\Delta' = i_1 \mathord:
s_1, ..., i_n \mathord: s_n$, a \emph{simultaneous substitution}
$\Delta \vdash \sigma \Rightarrow \Delta'$ is a sequence of
expressions $\sigma = (e_1,...,e_n)$ such that for each $1 \leq j \leq
n$, $\Delta \vdash e_j : s_j$. Given a simultaneous substitution
$\Delta \vdash \sigma = (e_1,...,e_n) \Rightarrow \Delta'$ and a
variable $i_j \mathord: s_j$ in $\Delta'$, we write $\sigma(i_j)$ for
the index expression $e_j$.

It will be useful to think of any sequence of sorts as an index
context. In particular, we will make use of simultaneous substitutions
of the form $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$, since these are exactly sequences of
index arguments suitable for the primitive type $\tyPrimNm{X}$.

We write $\Delta \Rightarrow \Delta'$ for the set of all simultaneous
substitutions $\sigma$ such that $\Delta \vdash \sigma \Rightarrow
\Delta'$. The \emph{identity} simultaneous substitution $\Delta \vdash
\id_\Delta \Rightarrow \Delta$ is just the sequence of variables in
$\Delta$: $\id_\Delta = (i_1,...,i_n)$ where $\Delta =
i_1\mathord:s_1,...,i_n\mathord:s_n$. We will also define composition
of simultaneous substitutions below, but first we must define the
application of a simultaneous substitutions to index expressions.

Application of a simultaneous substitution $\Delta \vdash \sigma
\Rightarrow \Delta'$ to a well-sorted index expression $\Delta' \vdash
e : s$ yields a well-sorted index expression $\Delta \vdash \sigma^*e
: s$. The expression $\sigma^*e$ is defined by the following two
clauses:
\begin{mathpar}
  \sigma^*i \isDefinedAs \sigma(i)

  \sigma^*(\indexOp{f}(e_1,...,e_n)) \isDefinedAs \indexOp{f}(\sigma^*e_1, ..., \sigma^*e_n)
\end{mathpar}
Similarly, given a well-indexed type $\Delta' \vdash A \isType$, we
can apply $\sigma$ to $A$ to produce a new type $\sigma^*A$. The
application of a simultaneous substitution to a type is defined
by the following clauses:
\begin{mathpar}
  \sigma^*(\tyPrim{X}{e_1,...,e_n}) \isDefinedAs \tyPrim{X}{\sigma^*e_1,...,\sigma^*e_n}

  \sigma^*\tyUnit \isDefinedAs \tyUnit

  \sigma^*(A \tyArr B) \isDefinedAs \sigma^*A \tyArr \sigma^*B

  \sigma^*(A \tyProduct B) \isDefinedAs \sigma^*A \tyProduct \sigma^*B

  \sigma^*(A + B) \isDefinedAs \sigma^*A + \sigma^*B

  \sigma^*(\forall i\mathord:s.A) \isDefinedAs \forall i\mathord:s.\sigma_{i\mathord:s}^*A
\end{mathpar}
\begin{lemma}
  Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
  substitution.
  \begin{enumerate}
  \item If $\Delta' \vdash e : s$, then $\Delta \vdash \sigma^*e : s$; and
  \item If $\Delta' \vdash A \isType$, then $\Delta \vdash \sigma^*A
    \isType$.
  \end{enumerate}
\end{lemma}

The \emph{composition} of two simultaneous substitutions $\Delta
\vdash \sigma \Rightarrow \Delta'$ and $\Delta' \vdash \sigma'
\Rightarrow \Delta''$, where $\sigma' = (e'_1,...,e'_n)$, is defined
as $\Delta \vdash \sigma' \circ \sigma \isDefinedAs (\sigma^*e'_1,
..., \sigma^*e'_n) \Rightarrow \Delta''$.

Given a context $\Delta = i_1\mathord:s_1,...,i_n\mathord:s_n$, and a
variable/type pair $i\mathord:s$ such that $i$ does not appear in
$\Delta$, we define the \emph{projection} simultaneous substitution
$\pi_{i\mathord:s} : \Delta,i\mathord:s \Rightarrow \Delta$ as
$\pi_{i\mathord:s} = (i_1,...,i_n)$. The subscript on
$\pi_{i\mathord:s}$ is the variable/type pair that is being discarded.

For a simultaneous substitution $\Delta \vdash \sigma \Rightarrow
\Delta'$ where $\Delta' = i_1\mathord:s_1,...,i_n\mathord:s_n$ and a
variable/type pair $i\mathord:s$ such that $i$ does not appear in
either $\Delta$ or $\Delta'$, then we can form the \emph{lifted}
simultaneous substitution $\Delta,i\mathord:s \vdash
\sigma_{i\mathord:s} = (\sigma(i_1), ..., \sigma(i_n), i) \Rightarrow
\Delta',i\mathord:s$. Note that we have implicity used the fact that
well-sortedness of index expressions is preserved by addition of extra
items to the context.

\subsubsection{Index Expression Equality and Type Equality}
\label{sec:type-equality}

Much of the power of indexing types by the expressions of an algebraic
theory comes from the equations of the theory. In the two-dimensional
geometry example, the types $\tyPrim{vec}{B,t_1 + t_2}$ and
$\tyPrim{vec}{B, t_2 + t_1}$ are considered equal by the type system,
due to the commutativity of the $+$ operation.

In the general framework, the equations between types are derived from
a set $\IndexAxiomSet$ of axioms $\Delta \vdash e \stackrel{ax}\equiv
e' : s$. We assume that all axioms $(\Delta \vdash e
\stackrel{ax}\equiv e' : s) \in \IndexAxiomSet$ are well-sorted:
meaning that both $\Delta \vdash e : s$ and $\Delta \vdash e' : s$.

Given a set $\IndexAxiomSet$ of axioms, we generate the judgmental
equality between index expressions $\Delta \vdash e \equiv e' : s$ by
the following rules, which allow us to use substitution instances of
axioms, and ensure that judgmental equality is a congruence relation
with respect to the index operations in $\IndexOpSet$:
\begin{mathpar}
  \inferrule*
  {(\Delta' \vdash e \stackrel{ax}\equiv e' : s) \in \IndexAxiomSet \\
    \Delta \vdash \sigma \Rightarrow \Delta'}
  {\Delta \vdash \sigma^*e \equiv \sigma^*e' : s}

  \inferrule*
  {\{\Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j\leq n}}
  {\Delta \vdash \indexOp{f}(e_1, ..., e_n) \equiv \indexOp{f}(e'_1, ..., e'_n) : s}
\end{mathpar}
We also assume the standard reflexivity, symmetry and transitivity
rules for the judgmental equality.

\begin{example}[Two-Dimensional Geometry]
  Translations form an abelian group under addition, so we assume the
  abelian group axioms for translations:
  \begin{displaymath}
    \begin{array}{l}
      t : \SynTransl_2 \vdash t + 1 \stackrel{ax}\equiv t : \SynTransl_2 \\
      t_1, t_2, t_3 : \SynTransl_2 \vdash t_1 + (t_2 + t_3) \stackrel{ax}\equiv (t_1 + t_2) + t_3 : \SynTransl_2 \\
      t : \SynTransl_2 \vdash t + (-t) \stackrel{ax}\equiv 1 : \SynTransl_2 \\
      t_1, t_2 : \SynTransl_2 \vdash t_1 + t_2 \stackrel{ax}\equiv t_2 + t_1 : \SynTransl_2 \\
    \end{array}
  \end{displaymath}
  Similarly, the sort of scale factors $\SynGL_1$ forms an abelian
  group under multiplication, and the sorts $\SynGL_2$ and
  $\SynOrth_2$ form (non-abelian) multiplicative groups, so we assume
  the appropriate axioms. We also assume that the operations $\iota_O,
  \iota_1, \det$ and $|\cdot|$ are group homomorphisms, and that
  expressions of the form $\iota_1(s)$ commute with group
  multiplication in the sort $\SynGL_2$. The absolute value of the
  determinant of orthgonal transformations is always $1$, so we also
  assume $|\det(\iota_OO)| \stackrel{ax}\equiv 1$. Likewise, scaling
  maps have a determined determinant: $\det(\iota_1(s))
  \stackrel{ax}\equiv s \cdot s$.
\end{example}

% \begin{example}[Logical Information Flow]
%   \fixme{Do this}
% \end{example}

% \begin{example}[Units of Measure]
%   For the units of measure system, seen as an instantiation of our
%   general framework, the set $\IndexAxiomSet$ consists of the abelian
%   group axioms:
%   \begin{displaymath}
%     \begin{array}{l}
%       u : \mathsf{unit} \vdash u \cdot 1 \stackrel{ax}\equiv u : \mathsf{unit} \\
%       u_1, u_2, u_3 : \mathsf{unit} \vdash u_1 \cdot (u_2 \cdot u_3) \stackrel{ax}\equiv (u_1 \cdot u_2) \cdot u_3 : \mathsf{unit} \\
%       u_1, u_2 : \mathsf{unit} \vdash u_1 \cdot u_2 \stackrel{ax}\equiv u_2 \cdot u_1 : \mathsf{unit} \\
%       u : \mathsf{unit} \vdash u \cdot u^{-1} \stackrel{ax}\equiv 1 : \mathsf{unit} \\
%     \end{array}
%   \end{displaymath}
% \end{example}

The judgmental equality $\Delta \vdash e \equiv e' : s$ on index
expressions generates the judgmental equality $\Delta \vdash A \equiv
B \isType$ on types. The basic rule generating judgmental equality on
types states that two applications of primitive types are equal if
their index expression arguments are equal:
\begin{displaymath}
  \inferrule*
  {\{ \Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j \leq n}}
  {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \equiv \tyPrim{X}{e'_1,...,e'_n} \isType}
\end{displaymath}
The rest of the rules for judgmental equality on types ensure that it
is a congruence relation on types, and that it is an equivalence
relation (i.e.~judgmental equality on types is reflexive, symmetric
and transitive).
% For example, for universally quantified types we have
% the following congruence rule:
% \begin{displaymath}
%   \inferrule*
%   {\Delta, i : s \vdash A \equiv B \isType}
%   {\Delta \vdash \forall i\mathord:s.A \equiv \forall i\mathord:s.B \isType}
% \end{displaymath}
% The congruence rules for the other type formers are similar.

\begin{lemma}
  Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
  substitution.
  \begin{enumerate}
  \item If $\Delta' \vdash e \equiv e' : s$ then $\Delta \vdash
    \sigma^*e \equiv \sigma^*e' : s$; and
  \item If $\Delta' \vdash A \equiv B \isType$ then $\Delta \vdash
    \sigma^*A \equiv \sigma^* B \isType$.
  \end{enumerate}
\end{lemma}

A pair of simultaneous substitutions $\Delta \vdash \sigma, \sigma'
\Rightarrow \Delta'$ are defined to be judgmentally equal if their
component expressions are judgmentally equal in the context $\Delta$:
i.e.~ if $\Delta \vdash e_j \equiv e'_j : s_j$, for all $j$. We write
$\Delta \vdash \sigma \equiv \sigma' \Rightarrow \Delta'$ when two
simultaneous substitutions are judgmentally equal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantics of Algebraically-Indexed Types}
\label{sec:semantics-algebraically-indexed-types}

Having defined the language of algebraically-indexed types, we now
turn to their denotational interpretation. In
\autoref{sec:index-erasure-semantics} we define an
\emph{index-erasure} interpretation of types that interprets every
well-indexed type as a set, ignoring the indexing expressions. Building on
the index-erasure semantics, we define in
\autoref{sec:relational-semantics} the \emph{relational}
interpretation of types.

% For both of our semantics of types, we state and prove two properties:
% types that are syntactically equal have equal denotations, and that
% substitution of index terms is interpreted via composition. These
% properties ensure that our semantics of types is well-behaved.

\subsubsection{The Index-Erasure Interpretation of Types}
\label{sec:index-erasure-semantics}

The defining feature of the index erasure interpretation is that the
semantics of a well-indexed type $\tyPrim{X}{e_1,...,e_n}$ is
determined solely by the primitive type $\tyPrimNm{X}$ and not by the
index expressions $e_1,...,e_n$. Accordingly, we assume that each
primitive type $\tyPrimNm{X} \in \PrimTypeSet$ is assigned a set
$\tyPrimSem{\tyPrimNm{X}}$. We extend this assignment to every
well-indexed type by induction on the type structure:
\begin{displaymath}
  \begin{array}{@{\hspace{0em}}c@{\hspace{0em}}c}
    \begin{array}{@{}l}
      \tySem{\tyUnit} \isDefinedAs \{*\} \\
      \tySem{A \tyProduct B} \isDefinedAs \tySem{A} \times \tySem{B} \\
      \tySem{A \tyArr B} \isDefinedAs \tySem{A} \to \tySem{B} \\
    \end{array}
    &
    \begin{array}{l}
      \tySem{A + B} \isDefinedAs \tySem{A} + \tySem{B} \\
      \tySem{\tyPrim{X}{e_1,...,e_n}} \isDefinedAs \tyPrimSem{\tyPrimNm{X}} \\
      \tySem{\forall i\mathord:s. A} \isDefinedAs \tySem{A}
    \end{array}
  \end{array}
\end{displaymath}
The interpretation of the unit type is a chosen one element set, and
the interpretations of the function, tuple and sum types are simply
the corresponding constructions on sets. The interpretation of the
universal quantifier ignores the indexing: the interpretation of the
type $\forall i\mathord:s.A$ is exactly the interpretation of the type
$A$.

% The index-erasure interpretation completely ignores index expressions
% and type equality is defined as an extension of index
% equality. Therefore, it is straightforward to prove that equal types
% have equal denotations when interpreted in the index-erasure
% semantics, and that substitution of index terms has no effect on the
% index-erasure interpretation of types:
\begin{lemma}\label{lem:tyeqsubst-erasure}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$ then $\tySem{A} =
    \tySem{B}$; and
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then $\tySem{\sigma^*A} = \tySem{A}$.
  \end{enumerate}
\end{lemma}

\begin{example}[Two-Dimensional Geometry]
  The two-dimensional geometry instantiation of the general framework
  uses the assignment $\tyPrimSem{\tyPrimNm{vec}} = \mathbb{R}^2$ and
  $\tyPrimSem{\tyPrimNm{real}} = \mathbb{R}$.
\end{example}

% \begin{example}[Logical Information Flow]
%   \fixme{do this}
% \end{example}

\subsubsection{The Relational Interpretation of Types}
\label{sec:relational-semantics}

We now define the relational semantics of each well-indexed type
$\Delta \vdash A \isType$ as some binary relation on the index-erasure
interpretation of $A$. For a set $X$, we write $\Rel(X)$ for the set
of binary relations $R \subseteq X \times X$ on $X$.

For the unit, tuple, sum and function types we will define the
relational interpretation as a standard logical relation. The
relational interpretations of primitive types with index arguments and
the universally quantified types requires an interpretation of index
contexts. We assign interpretations to index contexts in terms of
\emph{relational environments}, which we now define.

A relation environment for a context $\Delta$ is a
(dependently typed) function that, for each primitive type
$\tyPrimNm{X}$ and instantiation of its arguments $\sigma$, assigns a
binary relation $\rho\ \tyPrimNm{X}\ \sigma$ on the index-erasure
interpretation of $\tyPrimNm{X}$:
\begin{displaymath}
  \rho : (\tyPrimNm{X} \in \PrimTypeSet) \to (\Delta \Rightarrow \primTyArity(\tyPrimNm{X})) \to \Rel(\tyPrimSem{\tyPrimNm{X}})
\end{displaymath}
Every relation environment must respect index expression equality: for
any $\tyPrimNm{X} \in \PrimTypeSet$ and pair of simultaneous
substitutions $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$ and $\Delta \vdash \sigma' \Rightarrow
\primTyArity(\tyPrimNm{X})$ such that $\Delta \vdash \sigma \equiv
\sigma' \Rightarrow \primTyArity(\tyPrimNm{X})$, then $\rho\
\tyPrimNm{X}\ \sigma = \rho\ \tyPrimNm{X}\ \sigma'$.

% FIXME: an example?

We write $\mathrm{RelEnv}(\Delta)$ for the set of all relation
environments for a context $\Delta$. Given a relational environment
$\rho \in \mathrm{RelEnv}(\Delta')$ and a simultaneous substitution
$\Delta \vdash \sigma \Rightarrow \Delta'$, we can derive the composed
relational environment (with an abuse of notation) $\rho \circ \sigma
\in \mathrm{RelEnv}(\Delta)$ as $(\rho \circ \sigma)\ \tyPrimNm{X}\
\sigma' = \rho\ \tyPrimNm{X}\ (\sigma' \circ \sigma)$.

% FIXME: fix the notation here for interpretation of index contexts:
% should use some sort of semantic brackets

As we stated above, index contexts $\Delta$ are interpreted as certain
sets of relation environments, i.e.~ subsets of
$\mathrm{RelEnv}(\Delta)$. Depending on the primitive operations that
we assume for our system, we may have different sets of relational
environments that enforce different invariants. For the general
framework, we assume that, for each index context $\Delta$, we are
given a set of relation environments $\relEnv{E}(\Delta)$. Note that
this assignment of sets of relation environments to index contexts is
not assumed to be compositional: it is not necessarily the case that
the set of relational environments $\relEnv{E}(\Delta_1,\Delta_2)$ is
defined in terms of $\relEnv{E}(\Delta_1)$ and
$\relEnv{E}(\Delta_2)$. However, it must satisfy the following two
properties:
\begin{enumerate}
\item Closure under simultaneous substitutions: if $\rho \in
  \relEnv{E}(\Delta)$ and $\Delta' \vdash \sigma \Rightarrow \Delta$,
  then $\rho \circ \sigma \in \relEnv{E}(\Delta')$.
\item If we have a pair of relation environments $\rho_1 \in
  \relEnv{E}(\Delta', i\mathord:s')$ and $\rho_2 \in
  \relEnv{E}(\Delta)$, along with an simultaneous substitution $\sigma
  : \Delta' \Rightarrow \Delta$, such that $\rho_1 \circ
  \pi_{i\mathord:s'} = \rho_2 \circ \sigma$, then there exists a $\rho
  \in \relEnv{E}(\Delta, i\mathord:s')$ such that $\rho \circ
  \sigma_{i\mathord:s'} = \rho_1$ and $\rho \circ \pi_{i\mathord:s'} =
  \rho_2$.
  % such that the outer edges of the
  % following diagram commute, for all primitive types $\tyPrimNm{X} \in
  % \mathit{PrimType}$:
  % %FIXME: check that these compositions are the right way round
  % %FIXME: re-do this as a set of equations
  % %FIXME: give a better English description of why this is needed
  % \begin{displaymath}
  %   \xymatrix{
  %     {\Delta \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar[d]_{- \circ \sigma}
  %     &
  %     {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[d]^{- \circ \sigma_{s'}} \ar@/^/[rdd]^{\rho_1 \tyPrimNm{X}}
  %     \\
  %     {\Delta' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar@/_/[rrd]_{\rho_2\ \tyPrimNm{X}}
  %     &
  %     {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar@{.>}[dr]_{\rho\ \tyPrimNm{X}}
  %     \\
  %     &
  %     &
  %     {\Rel(\tyPrimSem{\tyPrimNm{X}})}
  %   }
  % \end{displaymath}
  % Then there exists a relation environment $\rho \in
  % \relEnv{E}(\Delta,i\mathord:s')$ (the dotted arrow) such that the
  % two triangles in the bottom right of the diagram commute.
  % FIXME: mention that we already know that the square commutes
\end{enumerate}

Both of these conditions ensure that the relational interpretation of
types that we define below behaves correctly with respect to
simultaneous substitution of index expressions
(\lemref{lem:tyeqsubst-relational}, below).

% The second condition may
% seem mysterious at first, but it is essential for proving that the
% relational interpretation of universal quantification types behaves
% correctly with respect to application of simultaneous substitution.

% \begin{example}
%   The construction of relational environments is the most subtle part
%   of our development. \fixme{complete this part}
% \end{example}

% \begin{example}[Units of Measure]
%   We give two examples of assignments of sets of relational
%   environments to index contexts in the units of measure example. The
%   second example is a refinment of the first. FIXME: some general
%   words about relational environments in these cases.
%   \begin{enumerate}
%   \item FIXME: assign a positive scaling factor to each variable in an
%     index context, extend homomorphically to all index expressions,
%     and then use this to define a scaling relation
%   \item FIXME: given an index context, assume a subgroup and a
%     homomorphism into the scaling factors
%   \end{enumerate}
% \end{example}

Given a relation environment $\rho \in \relEnv{E}(\Delta)$, we define
the set of extensions $\extends{\rho}{i\mathord:s}$ of $\rho$ by an
additional index variable $i\mathord:s$ to be
$\extends{\rho}{i\mathord:s} \isDefinedAs \{ \rho' \in
\relEnv{E}(\Delta,i\mathord:s) \sepbar \rho' \circ \pi^*_{i\mathord:s}
= \rho \}$. The set of extensions of a relational environment will be
used in the interpretation of the universal quantification type.

We assign a relational interpretation to all well-indexed types
$\Delta \vdash A \isType$ by induction on their derivations,
parameterised by relational environments $\rho \in
\relEnv{E}(\Delta)$:
\begin{eqnarray*}
  \rsem{\tyUnit}{\relEnv{E}}\rho & \isDefinedAs & \{(*,*)\} \\
  \rsem{\tyPrim{X}{e_1,...,e_n}}{\relEnv{E}}\rho & \isDefinedAs & \rho\ {\tyPrimNm{X}}\ (e_1,...,e_n) \\
  \rsem{A \tyArr B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relArrow \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A \tyProduct B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relTimes \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A + B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relSum \rsem{B}{\relEnv{E}}\rho \\
  \rsem{\forall i\mathord:s.A}{\relEnv{E}}\rho & \isDefinedAs & \bigcap\{ \rsem{A}{\relEnv{E}}\rho' \sepbar \rho' \in \extends{\rho}{i\mathord:s} \}
\end{eqnarray*}
In this definition we have made use of the following three
constructions on binary relations. If $R \in \Rel(X)$ and $S \in
\Rel(Y)$, then $R \relArrow S \in \Rel(X \to Y)$ is defined as $\{
(f_1,f_2) \sepbar \forall (a_1,a_2) \in R.\ (f_1a_1,f_2a_2) \in S
\}$. With the same assumptions on $R$ and $S$, the relation $R
\relTimes S \in \Rel(X \times Y)$ is defined as $\{
((a_1,b_1),(a_2,b_2)) \sepbar (a_1,a_2) \in R \land (b_1,b_2) \in S
\}$. Finally, the relation $R \relSum S \in \Rel(X + Y)$ is defined as
$\{ (\mathrm{inl}\ x, \mathrm{inl}\ x') \sepbar (x,x') \in R \} \cup
\{ (\mathrm{inr}\ y, \mathrm{inr}\ y') \sepbar (y,y') \in S \}$.

% The following lemma states that the relation interpretation of types
% that we have defined in this section behaves well: the first part of
% the lemma states that two types that are judgmentally equal are given
% equal relational interpretations, and the second part states that
% substitution of index expressions in types can be interpreted by the
% composition of relational environments with simultaneous
% substitutions.
\begin{lemma}\label{lem:tyeqsubst-relational}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$, then for all $\rho \in
    \relEnv{E}(\Delta)$, $\rsem{A}{\relEnv{E}}{\rho} =
    \rsem{B}{\relEnv{E}}{\rho}$;
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then for all $\rho \in \relEnv{E}(\Delta)$,
    $\rsem{\sigma^*A}{\relEnv{E}}\rho = \rsem{A}{\relEnv{E}}(\rho
    \circ \sigma)$.
  \end{enumerate}
\end{lemma}

Note that both parts of \lemref{lem:tyeqsubst-relational} depend on
\lemref{lem:tyeqsubst-erasure} to be ``well-typed''.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Well-typed Programs}
\label{sec:well-typed-programs}

We now present the rules for well-typed programs over the collection
of types we generated in
\autoref{sec:algebraically-indexed-types}. Each well-type program is
assigned an index-erasure semantics, building on the index-erasure
semantics of types we defined in
\autoref{sec:index-erasure-semantics}. Our main result
(\thmref{thm:abstraction}) is that the index-erasure semantics of
every well-typed program is related to itself in the relational
interpretation of its type: this is the abstraction theorem for every
calculus in our general framework.

Well-typed programs are defined with respect to well-indexed typing
contexts, which are in turn defined with respect to an index
context. Well-indexed typing contexts with respect to an index context
$\Delta$ are sequences of variable/type pairs with no repeated
variable names such that each type is well-indexed with respect to
$\Delta$. Formally, well-indexed typing contexts are defined by the
following two rules:
\begin{mathpar}
  \inferrule*
  { }
  {\Delta \vdash \epsilon \isCtxt}

  \inferrule*
  {\Delta \vdash \Gamma \isCtxt \\ \Delta \vdash A \isType \\ x \not\in \Gamma}
  {\Delta \vdash \Gamma, x : A \isCtxt}
\end{mathpar}
Application of simultaneous substitutions extends to typing contexts
by applying the simultaneous substitution to each type.

The typing rules for our system define the well-typed programs with
respect to an index context $\Delta$ and a type context $\Delta \vdash
\Gamma \isCtxt$. The judgment $\Delta; \Gamma \vdash M : A$ is defined
in \autoref{fig:programs}. The equational theory on types is
incorporated into the type system via the rule \TirName{TyEq}, which
allows for a program that is judged to have type $A$ to also have any
other equal type $B$.
\begin{figure*}[t]
  \centering
  \begin{mathpar}
    \inferrule* [right=Var]
    {\Delta \vdash \Gamma \isCtxt \\ x : A \in \Gamma}
    {\Delta; \Gamma \vdash x : A}

    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash M : A \\ \Delta \vdash A \equiv B \isType}
    {\Delta; \Gamma \vdash M : B}

    \inferrule* [right=Unit]
    { }
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash M : A \\
      \Delta; \Gamma \vdash N : B}
    {\Delta; \Gamma \vdash (M, N) : A \tyProduct B}

    \inferrule* [right=Proj1]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_1 M : A}

    \inferrule* [right=Proj2]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_2 M : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \mathrm{inl}\ M : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash M : B}
    {\Delta; \Gamma \vdash \mathrm{inr}\ M : A + B}

    \inferrule* [right=Case]
    {\Delta; \Gamma \vdash M : A + B \\
      \Delta; \Gamma, x : A \vdash N_1 : C \\
      \Delta; \Gamma, y : B \vdash N_2 : C}
    {\Delta; \Gamma \vdash \textrm{case}\ M\ \textrm{of}\ \textrm{inl}\ x.N_1; \textrm{inr}\ y.N_2 : C}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, x : A \vdash M : B}
    {\Delta; \Gamma \vdash \lambda x.M : A \tyArr B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash M : A \tyArr B \\
      \Delta; \Gamma \vdash N : A}
    {\Delta; \Gamma \vdash M N : B}

    \inferrule* [right=UnivAbs]
    {\Delta, i : s; \pi_{i\mathord:s}^*\Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \Lambda i. M : \forall i\mathord:s. A}

    \inferrule* [right=UnivApp]
    {\Delta; \Gamma \vdash M : \forall i\mathord:s. A \\ \Delta \vdash e : s}
    {\Delta; \Gamma \vdash M [e] : (\id_\Delta, e)^*A}
  \end{mathpar}
  
  \caption{Well-typed Programs}
  \label{fig:programs}
\end{figure*}

\subsubsection{The Index-Erasure Interpretation of Programs}
\label{sec:erasure-semantics-programs}

% FIXME: do we need to prove something about the effect
% of substitution on the erasure semantics of contexts?

We assign an index-erasure semantics to any well-indexed typing
context $\Delta \vdash \Gamma \isCtxt$ by induction on its structure:
$\ctxtSem{\epsilon} = \{*\}$ and $\ctxtSem{\Gamma, x : A} =
\ctxtSem{\Gamma} \times \tySem{A}$. For a well-typed program $\Delta;
\Gamma \vdash M : A$, we define the \emph{erasure interpretation} as a
function $\tmSem{e} : \ctxtSem{\Gamma} \to \tySem{A}$, completely
ignoring the indexing information. In light of
\lemref{lem:tyeqsubst-erasure}, we define this function directly on
the syntax of well-typed programs, rather than on the typing
derivations. We define $\tmSem{e}$ by the following clauses:
\begin{displaymath}
  \begin{array}{@{\hspace{0em}}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l}
    \tmSem{x}\eta & \isDefinedAs & \eta_x \\
    \tmSem{(M,N)}\eta & \isDefinedAs & (\tmSem{M}\eta, \tmSem{N}\eta) \\
    \tmSem{\pi_1M}\eta & \isDefinedAs & \pi_1(\tmSem{M}\eta) \\
    \tmSem{\pi_2M}\eta & \isDefinedAs & \pi_2(\tmSem{M}\eta) \\
    \tmSem{\mathrm{inl}\ M}\eta & \isDefinedAs & \mathrm{inl}\ (\tmSem{M}\eta) \\
    \tmSem{\mathrm{inr}\ M}\eta & \isDefinedAs & \mathrm{inr}\ (\tmSem{M}\eta) \\
    \left\llbracket
      \begin{array}{l}
        \textrm{case}\ M\ \textrm{of}\\
        \textrm{inl}\ x.N_1;\\
        \textrm{inr}\ y.N_2
      \end{array}\right\rrbracket^{\mathit{tm}}\eta & \isDefinedAs &
    \left\{
      \begin{array}{ll}
        \tmSem{N_1}(\eta,a) & \textrm{if }\tmSem{M}\eta = \mathrm{inl}(a) \\
        \tmSem{N_2}(\eta,b) & \textrm{if }\tmSem{M}\eta = \mathrm{inr}(b)
      \end{array}
    \right. \\
    \tmSem{\lambda x. M}\eta & \isDefinedAs & \lambda v. \tmSem{M}(\eta, v) \\
    \tmSem{M N}\eta & \isDefinedAs & (\tmSem{M}\eta) (\tmSem{N}\eta) \\
    \tmSem{\Lambda i.\ M}\eta & \isDefinedAs & \tmSem{M}\eta \\
    \tmSem{M[e]}\eta & \isDefinedAs & \tmSem{M}\eta    
  \end{array}
\end{displaymath}
In the above, we have written $\eta_x$ to denote the appropriate
projection from $\eta$ to get the value in the environment
corresponding to the variable $x$ in the context.

\subsubsection{The Abstraction Theorem}
\label{sec:abstraction-theorem}

We now state and prove the abstraction theorem for well-typed programs
in our system. To state and prove this theorem for open programs, we
first need to extend the relational interpretation of types to typing
contexts. The relational interpretation of contexts is defined by the
following clauses, where we have used the relational lifting of
cartesian product $-\relTimes-$ defined in
\autoref{sec:relational-semantics}.
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l@{\hspace{1.5em}}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l}
    \rsem{\epsilon}{\relEnv{E}}{\rho} & \{(*,*)\} &
    \rsem{\Gamma, x : A}{\relEnv{E}}{\rho} & \rsem{\Gamma}{\relEnv{E}}\rho \relTimes \rsem{A}{\relEnv{E}}\rho
  \end{array}
\end{displaymath}
% The relational interpretation of contexts inherits from the relational
% interpretation of types the property of interpreting the application
% of simultaneous substitutions as composition:
\begin{lemma}\label{lem:ctxtsubst-rel}
  If $\Delta \vdash' \Gamma \isCtxt$ and $\sigma : \Delta \Rightarrow
  \Delta'$, then for all $\rho \in \relEnv{E}(\Delta)$,
  $\rsem{\sigma^*\Gamma}{\relEnv{E}}\rho =
  \rsem{\Gamma}{\relEnv{E}}{(\rho \circ \sigma)}$.
\end{lemma}

\begin{theorem}[Abstraction]\label{thm:abstraction}
  If $\Delta; \Gamma \vdash M : A$, then for all $\rho \in
  \relEnv{E}(\Delta)$ and $\eta_1, \eta_2 \in \ctxtSem{\Gamma}$ such
  that $(\eta_1, \eta_2) \in \rsem{\Gamma}{\relEnv{E}}\rho$, we have
  $(\tmSem{M}\eta_1, \tmSem{M}\eta_2) \in \rsem{A}{\relEnv{E}}\rho$.
\end{theorem}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
