\section{A General Framework}
\label{sec:a-general-framework}

We now present a general framework for discussing
algebraically-indexed types and representation independence. We define
the syntax of algebraically-indexed types, then their semantics and
finally we present a general programming language for
algebraically-indexed types, with an abstraction theorem.

\subsection{Algebraically-Indexed Types}
\label{sec:algebraically-indexed-types}

The index expressions and types of an instantiation of our general
framework are derived from the following data:
\begin{enumerate}
\item A collection $\SortSet$ of index sorts. We will use the
  meta-syntactic variables $s,s_1,s_2,...$ and so on to stand for
  arbitrary sorts taken from $\SortSet$.
\item A collection $\IndexOpSet$ of index operations, with a function
  $\indexOpArity : \IndexOpSet \to \SortSet^* \times \SortSet$ (we use
  the notation $A^*$ to denote the set of lists of elements of some
  set $A$).
\item A collection $\PrimTypeSet$ of primitive types, with a function
  $\primTyArity : \PrimTypeSet \to \SortSet^*$, describing the sorts
  of the arguments of each primitive type.
\end{enumerate}

\begin{example}[Two-Dimensional Geometry]
  \label{ex:two-dim-geo-operations}
  The two-dimensional geometry system has a sort for each of the
  geometric groups that we mentioned in
  \autoref{sec:motivating-examples}. Thus, $\SortSet =
  \{\SynTransl{2}, \SynGL{2}, \SynOrth{2}, \SynGL{1} \}$. For the
  index operations, we have additive group structure on
  $\SynTransl{2}$, multiplicative group structure on $\SynGL{1}$,
  $\SynGL{2}$ and $\SynOrth{2}$, injections from $\SynOrth{2}$ and
  $\SynGL{1}$ into $\SynGL{2}$, determinant, and absolute value. Thus,
  $\IndexOpSet = \{ 0, +, -, 1_G, -\cdot_G-, -^{-1_G}, \iota_O,
  \iota_1, \det, |\cdot| \}$, where $G \in \{\SynGL{1}, \SynGL{2},
  \SynOrth{2}\}$, with the following assignment of arities:
  \begin{displaymath}
    \begin{array}{@{}l@{\hspace{0em}=\hspace{0em}}l@{\hspace{0.5em}}l@{\hspace{0em}=\hspace{0em}}l}
      \indexOpArity(0) & ([], \SynTransl{2}) &
      \indexOpArity(1_G) & ([], G) \\
      \indexOpArity(+) & ([\SynTransl{2}, \SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(\cdot_G) & ([G,G],G) \\
      \indexOpArity(-) & ([\SynTransl{2}], \SynTransl{2}) &
      \indexOpArity(^{-1_G}) & ([G], G) \\
      \indexOpArity(\iota_o) & ([\SynOrth{2}], \SynGL{2}) &
      \indexOpArity(\iota_1) & ([\SynGL{1}], \SynGL{2}) \\
      \indexOpArity(\det) & ([\SynGL{2}], \SynGL{1}) &
      \indexOpArity(|\cdot|) & ([\SynGL{1}], \SynGL{1})
    \end{array}
  \end{displaymath}
  The intended interpretations of the top three pairs of operations
  are group unit, group combination and group negation,
  respectively. When we introduce equational theories for index
  expressions in \autoref{sec:type-equality} below, we will impose the
  (abelian) group laws. For this example, we have $\PrimTypeSet = \{
  \tyPrimNm{vec}, \tyPrimNm{real} \}$, with
  $\primTyArity(\tyPrimNm{vec}) = [\SynGL{2}, \SynTransl{2}]$ and
  $\primTyArity(\tyPrimNm{real}) = [\SynGL{1}]$.
\end{example}

We assume a countably infinite collection of index variable names $i,
i_1, i_2,\ldots$. \emph{Index contexts} $\Delta = i_1 \mathord: s_1,
..., i_n \mathord: s_n$ are lists of variable/sort pairs, such that
all the variable names are distinct.

\begin{figure*}[t]
  \centering
  % \textbf{Index contexts}\\

  % $\Delta = i_1 \mathord: s_1, ..., i_n \mathord: s_n$, where each $s_i \in \SortSet$ and no variable name is repeated.

  % \bigskip

  {\small
  \textbf{Well-sorted index expressions}
  \begin{mathpar}
    \inferrule* [right=IVar]
    {i : s \in \Delta}
    {\Delta \vdash i : s}
    
    \inferrule* [right=IOp]
    {\indexOp{f} \in \mathit{IndexOp} \\
      \indexOpArity(\indexOp{f}) = ([s_1,...,s_n], s) \\
      \{\Delta \vdash e_j : s_j\}_{1 \leq j \leq n}}
    {\Delta \vdash \indexOp{f}(e_1, ..., e_n) : s}
  \end{mathpar}

  \bigskip

  \textbf{Well-indexed types}
  \begin{mathpar}
    \inferrule* [right=TyPrim]
    {\tyPrimNm{X} \in \mathit{PrimType} \\\\
      \primTyArity(\tyPrimNm{X}) = [s_1,...,s_n] \\
      \{\Delta \vdash e_j : s_j\}_{1\leq j \leq n}}
    {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \isType}

    \inferrule* [right=TyUnit]
    { }
    {\Delta \vdash \tyUnit \isType}

    \inferrule* [right=TyArr]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyArr B \isType}

    \inferrule* [right=TyTuple]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A \tyProduct B \isType}

    \inferrule* [right=TySum]
    {\Delta \vdash A \isType \\ \Delta \vdash B \isType}
    {\Delta \vdash A + B \isType}
    
    \inferrule* [right=TyForall] %FIXME: macroize forall
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \forall i \mathord: s. A \isType}

    \inferrule* [right=TyEx]
    {\Delta, i \mathord: s \vdash A \isType}
    {\Delta \vdash \exists i \mathord: s. A \isType}
  \end{mathpar}}
  \caption{Index expressions and types}
  \label{fig:indexes-and-types}
\end{figure*}

Given the above data, the rules in \autoref{fig:indexes-and-types}
generate two judgements: well-sorted index expressions $\Delta \vdash
e : s$ and well-indexed types $\Delta \vdash A \isType$. Since index
variables may appear in types, types are judged to be well-indexed
with respect to an index context $\Delta$. The rules for well-sorted
index expressions are particularly simple: either an index expression
is a variable that appears in the context (rule \TirName{IVar}), or it
is an application of an index operation taken from $\IndexOpSet$ to
other index expressions (rule \TirName{IOp}). The rules for
well-indexed types include the usual rules for constructing types of
the simply-typed $\lambda$-calculus with unit, sum and tuple types
(rules \TirName{TyUnit}, \TirName{TyArr}, \TirName{TyTuple} and
\TirName{TySum}). The rule \TirName{TyPrim} allows us to form, from a
a primitive type $\tyPrimNm{X}$ and appropriately sorted index
expressions $e_1,...,e_n$, the well-indexed type
$\tyPrim{X}{e_1,...,e_n}$. The rule \TirName{TyForall} permits the
formation of universally quantified types, where the universal
quantification ranges over all index expressions of some
sort. Existential types are constructed using the \TirName{TyEx}
rule, and allow for abstraction by hiding. %FIXME: think about the introduction of existentials more, perhaps forward ref to their use

\subsubsection{Simultaneous Substitution of Index Expressions}
\label{sec:simultaneous-substitution}

It will be technically convenient to express substitution of index
expressions in our framework in terms of simultaneous substitutions.
Given a pair of index contexts $\Delta$ and $\Delta' = i_1 \mathord:
s_1, ..., i_n \mathord: s_n$, a \emph{simultaneous substitution}
$\Delta \vdash \sigma \Rightarrow \Delta'$ is a sequence of
expressions $\sigma = (e_1,...,e_n)$ such that for each $1 \leq j \leq
n$, $\Delta \vdash e_j : s_j$. Given a simultaneous substitution
$\Delta \vdash \sigma = (e_1,...,e_n) \Rightarrow \Delta'$ and a
variable $i_j \mathord: s_j$ in $\Delta'$, we write $\sigma(i_j)$ for
the index expression $e_j$. We write $\Delta \Rightarrow \Delta'$ for
the set of all simultaneous substitutions $\sigma$ such that $\Delta
\vdash \sigma \Rightarrow \Delta'$.

It will be useful to think of any sequence of sorts as an index
context. In particular, we will make use of simultaneous substitutions
of the form $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$, since these are exactly sequences of
index arguments suitable for the primitive type $\tyPrimNm{X}$. With
further abuse of notation, we write $\Delta \Rightarrow
\primTyArity(\tyPrimNm{X})$ for the set of all simultaneous
substitutions $\sigma$ such that $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$.

For a simultaneous substitution $\Delta \vdash \sigma \Rightarrow
\Delta'$, where $\Delta' = i_1\mathord:s_1,...,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
either $\Delta$ or $\Delta'$, then we can form the \emph{lifted}
simultaneous substitution $\Delta,i\mathord:s \vdash
\sigma_{i\mathord:s} = (\sigma(i_1), ..., \sigma(i_n), i) \Rightarrow
\Delta',i\mathord:s$. Note that we have implicity used the fact that
well-sortedness of index expressions is preserved by addition of extra
items to the context.

Application of a simultaneous substitution $\Delta \vdash \sigma
\Rightarrow \Delta'$ to a well-sorted index expression $\Delta' \vdash
e : s$ yields a well-sorted index expression $\Delta \vdash \sigma^*e
: s$. The expression $\sigma^*e$ is defined on variables as $\sigma^*i
\isDefinedAs \sigma(i)$, and on operation symbols as
$\sigma^*(\indexOp{f}(e_1,...,e_n)) \isDefinedAs
\indexOp{f}(\sigma^*e_1, ..., \sigma^*e_n)$.  Similarly, given a
well-indexed type $\Delta' \vdash A \isType$, we can apply $\sigma$ to
$A$ to produce a new well-indexed type $\Delta \vdash \sigma^*A
\isType$. The key clauses defining $\sigma^*A$ are for primitive types
and the universal and existential quantifiers:
\begin{displaymath}
  \begin{array}{c}
    \sigma^*(\tyPrim{X}{e_1,...,e_n}) \isDefinedAs \tyPrim{X}{\sigma^*e_1,...,\sigma^*e_n}
    \\
    \begin{array}{c@{\hspace{2em}}c}
      \sigma^*(\forall i\mathord:s.A) \isDefinedAs \forall i\mathord:s.\sigma_{i\mathord:s}^*A
      &
      \sigma^*(\exists i\mathord:s.A) \isDefinedAs \exists i\mathord:S. \sigma_{i\mathord:s}^*A
    \end{array}
  \end{array}
\end{displaymath}
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e : s$, then $\Delta \vdash \sigma^*e : s$; and
%   \item If $\Delta' \vdash A \isType$, then $\Delta \vdash \sigma^*A
%     \isType$.
%   \end{enumerate}
% \end{lemma}

The \emph{identity} simultaneous substitution $\Delta \vdash
\id_\Delta \Rightarrow \Delta$ is just the sequence of variables in
$\Delta$: $\id_\Delta = (i_1,...,i_n)$ where $\Delta =
i_1\mathord:s_1,...,i_n\mathord:s_n$. The \emph{composition} of two
simultaneous substitutions $\Delta \vdash \sigma \Rightarrow \Delta'$
and $\Delta' \vdash \sigma' \Rightarrow \Delta''$, where $\sigma' =
(e'_1,...,e'_n)$, is defined as $\Delta \vdash \sigma' \circ \sigma
\isDefinedAs (\sigma^*e'_1, ..., \sigma^*e'_n) \Rightarrow \Delta''$.

Given a context $\Delta = i_1\mathord:s_1,...,i_n\mathord:s_n$, and a
variable/sort pair $i\mathord:s$ such that $i$ does not appear in
$\Delta$, we define the \emph{projection} simultaneous substitution
$\pi_{i\mathord:s} : \Delta,i\mathord:s \Rightarrow \Delta$ as
$\pi_{i\mathord:s} = (i_1,...,i_n)$. The subscript on
$\pi_{i\mathord:s}$ is the variable/sort pair that is being discarded.

\subsubsection{Index Expression Equality and Type Equality}
\label{sec:type-equality}

Much of the power of indexing types by the expressions of an algebraic
theory comes from the equations of the theory. In the two-dimensional
geometry example of \autoref{sec:motivating-examples}, the types
$\tyPrim{vec}{B,t_1 + t_2}$ and $\tyPrim{vec}{B, t_2 + t_1}$ are
considered equal by the type system, due to the commutativity of the
$+$ operation.

In the general framework, the equations between types are derived from
a set $\IndexAxiomSet$ of axioms $\Delta \vdash e \stackrel{ax}\equiv
e' : s$. We assume that all axioms $(\Delta \vdash e
\stackrel{ax}\equiv e' : s) \in \IndexAxiomSet$ are well-sorted,
meaning that both $\Delta \vdash e : s$ and $\Delta \vdash e' : s$
hold.

Given a set $\IndexAxiomSet$ of axioms, we generate the equality
judgment between index expressions $\Delta \vdash e \equiv e' : s$ by
the following rules. The first allows us to use substitution instances
of axioms. The second ensures that equality is a congruence relation
with respect to the index operations in $\IndexOpSet$:
\begin{mathpar}
  \inferrule*
  {(\Delta' \vdash e \stackrel{ax}\equiv e' : s) \in \IndexAxiomSet \\
    \Delta \vdash \sigma \Rightarrow \Delta'}
  {\Delta \vdash \sigma^*e \equiv \sigma^*e' : s}

  \inferrule*
  {\{\Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j\leq n}}
  {\Delta \vdash \indexOp{f}(e_1, ..., e_n) \equiv \indexOp{f}(e'_1, ..., e'_n) : s}
\end{mathpar}
We also assume the standard reflexivity, symmetry and transitivity
rules for the equality judgment.

\begin{example}[Two-Dimensional Geometry]
  \label{ex:two-dim-geo-axioms}
  In \autoref{sec:motivating-examples}, we assumed that various
  equational axioms hold for the indexing expressions standing for
  elements of geometric groups. We can now make this assumption formal
  in our general framework. Semantically, translations form an abelian
  group under addition, so we assume the abelian group axioms for
  translations:
  \begin{displaymath}
    \begin{array}{l}
      t : \SynTransl{2} \vdash t + 1 \stackrel{ax}\equiv t : \SynTransl{2} \\
      t_1, t_2, t_3 : \SynTransl{2} \vdash t_1 + (t_2 + t_3) \stackrel{ax}\equiv (t_1 + t_2) + t_3 : \SynTransl{2} \\
      t : \SynTransl{2} \vdash t + (-t) \stackrel{ax}\equiv 1 : \SynTransl{2} \\
      t_1, t_2 : \SynTransl{2} \vdash t_1 + t_2 \stackrel{ax}\equiv t_2 + t_1 : \SynTransl{2} \\
    \end{array}
  \end{displaymath}
  Similarly, the sort of scale factors $\SynGL{1}$ forms an abelian
  group under multiplication, and the sorts $\SynGL{2}$ and
  $\SynOrth{2}$ form (non-abelian) multiplicative groups, so we assume
  the appropriate axioms. We also assume that the operations $\iota_O,
  \iota_1, \det$ and $|\cdot|$ are group homomorphisms, and that
  expressions of the form $\iota_1(s)$ commute with group
  multiplication in the sort $\SynGL{2}$. The absolute value of the
  determinant of an orthgonal transformation is always $1$, so we also
  assume $|\det(\iota_OO)| \stackrel{ax}\equiv 1$. Likewise, scaling
  maps have a determined determinant: $\det(\iota_1(s))
  \stackrel{ax}\equiv s \cdot s$.
\end{example}

The equality judgment $\Delta \vdash e \equiv e' : s$ on index
expressions generates the equality judgment $\Delta \vdash A \equiv
B \isType$ on types. The basic rule generating equality judgments on
types states that two applications of primitive types are equal if
their index expression arguments are equal:
\begin{displaymath}
  \inferrule*
  {\{ \Delta \vdash e_j \equiv e'_j : s_j\}_{1\leq j \leq n}}
  {\Delta \vdash \tyPrim{X}{e_1,...,e_n} \equiv \tyPrim{X}{e'_1,...,e'_n} \isType}
\end{displaymath}
The rest of the rules for equality on types ensure that it is a
congruence relation on types, and that it is an equivalence relation
(i.e.,~equality on types is reflexive, symmetric and transitive).
% For example, for universally quantified types we have
% the following congruence rule:
% \begin{displaymath}
%   \inferrule*
%   {\Delta, i : s \vdash A \equiv B \isType}
%   {\Delta \vdash \forall i\mathord:s.A \equiv \forall i\mathord:s.B \isType}
% \end{displaymath}
% The congruence rules for the other type formers are similar.

% FIXME: think about integrating this lemma into the running text
% \begin{lemma}
%   Let $\Delta \vdash \sigma \Rightarrow \Delta'$ be a simultaneous
%   substitution.
%   \begin{enumerate}
%   \item If $\Delta' \vdash e \equiv e' : s$ then $\Delta \vdash
%     \sigma^*e \equiv \sigma^*e' : s$; and
%   \item If $\Delta' \vdash A \equiv B \isType$ then $\Delta \vdash
%     \sigma^*A \equiv \sigma^* B \isType$.
%   \end{enumerate}
% \end{lemma}

A pair of simultaneous substitutions $\Delta \vdash \sigma \Rightarrow
\Delta'$ and $\Delta \vdash \sigma' \Rightarrow \Delta'$ are defined
to be equal if their component expressions are equal in the context
$\Delta$: i.e.,~ if $\Delta \vdash e_j \equiv e'_j : s_j$, for all
$j$. We write $\Delta \vdash \sigma \equiv \sigma' \Rightarrow
\Delta'$ when two simultaneous substitutions are equal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Semantics of Algebraically-Indexed Types}
\label{sec:semantics-algebraically-indexed-types}

\fixme{Make sure that the semantics is motivated}
Having defined the language of algebraically-indexed types, we now
turn to their denotational interpretation. In
\autoref{sec:index-erasure-semantics} we define an
\emph{index-erasure} interpretation of types that interprets every
well-indexed type as a set, ignoring the indexing expressions. Building on
the index-erasure semantics, we define in
\autoref{sec:relational-semantics} the \emph{relational}
interpretation of types.

% For both of our semantics of types, we state and prove two properties:
% types that are syntactically equal have equal denotations, and that
% substitution of index terms is interpreted via composition. These
% properties ensure that our semantics of types is well-behaved.

\subsubsection{The Index-Erasure Interpretation of Types}
\label{sec:index-erasure-semantics}

The defining feature of the index erasure interpretation is that the
semantics of a well-indexed type $\tyPrim{X}{e_1,...,e_n}$ is
determined solely by the primitive type $\tyPrimNm{X}$ and not by the
index expressions $e_1,...,e_n$. Accordingly, we assume that each
primitive type $\tyPrimNm{X} \in \PrimTypeSet$ is assigned a set
$\tyPrimSem{\tyPrimNm{X}}$. We extend this assignment to every
well-indexed type by induction on the type structure:
\begin{displaymath}
  \begin{array}{@{\hspace{0em}}c@{\hspace{0em}}c}
    \begin{array}{@{}l}
      \tySem{\tyUnit} \isDefinedAs \{*\} \\
      \tySem{A \tyProduct B} \isDefinedAs \tySem{A} \times \tySem{B} \\
      \tySem{A \tyArr B} \isDefinedAs \tySem{A} \to \tySem{B} \\
    \end{array}
    &
    \begin{array}{l}
      \tySem{A + B} \isDefinedAs \tySem{A} + \tySem{B} \\
      \tySem{\tyPrim{X}{e_1,...,e_n}} \isDefinedAs \tyPrimSem{\tyPrimNm{X}} \\
      \tySem{\forall i\mathord:s. A} \isDefinedAs \tySem{A} \\
      \tySem{\exists i\mathord:s. A} \isDefinedAs \tySem{A}
    \end{array}
  \end{array}
\end{displaymath}
% The interpretation of the unit type is a chosen one element set, and
% the interpretations of the function, tuple and sum types are simply
% the corresponding constructions on sets. 
The interpretations of the
universal and existential quantifiers ignore the indexing: the
interpretation of the type $\forall i\mathord:s.A$ is exactly the
interpretation of the type $A$, and likewise for $\exists
i\mathord:s.A$.

% The index-erasure interpretation completely ignores index expressions
% and type equality is defined as an extension of index
% equality. Therefore, it is straightforward to prove that equal types
% have equal denotations when interpreted in the index-erasure
% semantics, and that substitution of index terms has no effect on the
% index-erasure interpretation of types:
\begin{lemma}\label{lem:tyeqsubst-erasure}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$ then $\tySem{A} =
    \tySem{B}$; and
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then $\tySem{\sigma^*A} = \tySem{A}$.
  \end{enumerate}
\end{lemma}

\begin{example}[Two-Dimensional Geometry]
  The two-dimensional geometry instantiation of the general framework
  uses the assignment $\tyPrimSem{\tyPrimNm{vec}} = \mathbb{R}^2$ and
  $\tyPrimSem{\tyPrimNm{real}} = \mathbb{R}$.
\end{example}

\subsubsection{The Relational Interpretation of Types}
\label{sec:relational-semantics}

We now define the relational semantics of each well-indexed type
$\Delta \vdash A \isType$ as some binary relation on the index-erasure
interpretation of $A$. For a set $X$, we write $\Rel(X)$ for the set
of binary relations $R \subseteq X \times X$ on $X$.

For the unit, tuple, sum and function types we will define the
relational interpretation as a standard logical relation. The
relational interpretations of primitive types with index arguments and
the universally quantified types require an interpretation of index
contexts. We assign interpretations to index contexts in terms of sets
of \emph{relational environments}.

The definition of relational environments is the most subtle part of
our development. The straightforward approach would be to assume some
interpretation of the indexing expressions, where sorts are
interpreted as sets and index operations as functions, and then define
the relational interpretation of a primtive type
$\tyPrim{X}{e_1,...,e_n}$ in terms of the interpretations of
$e_1,...,e_n$. This approach suffices to prove free theorems and type
isomorphisms for instantiations of our general framework. However, in
order to prove non-definability results (like, for example, the one in
\exref{ex:uninhabited-type}), we choose a more refined interpretation
that accounts more precisely for the definable programs permitted by
the algebraic indexing. In this section, we set out the general
requirements that we require of relational environments in order for
the abstraction theorem to hold. In \autoref{sec:constr-rel-env}, we
give a general construction of relational environments that will allow
us to prove several non-definability results.

A relational environment for a context $\Delta$ is a (dependently typed)
function $\rho$ that, for each primitive type $\tyPrimNm{X}$ and
instantiation of its arguments $\sigma$, assigns a binary relation
$\rho\ \tyPrimNm{X}\ \sigma$ on the index-erasure interpretation of
$\tyPrimNm{X}$:
\begin{displaymath}
  \rho : (\tyPrimNm{X} \in \PrimTypeSet) \to (\Delta \Rightarrow \primTyArity(\tyPrimNm{X})) \to \Rel(\tyPrimSem{\tyPrimNm{X}})
\end{displaymath}
Every relation environment must respect index expression equality: for
any $\tyPrimNm{X} \in \PrimTypeSet$ and pair of simultaneous
substitutions $\Delta \vdash \sigma \Rightarrow
\primTyArity(\tyPrimNm{X})$ and $\Delta \vdash \sigma' \Rightarrow
\primTyArity(\tyPrimNm{X})$, if $\Delta \vdash \sigma \equiv \sigma'
\Rightarrow \primTyArity(\tyPrimNm{X})$, then $\rho\ \tyPrimNm{X}\
\sigma = \rho\ \tyPrimNm{X}\ \sigma'$.

We write $\mathrm{RelEnv}(\Delta)$ for the set of all relation
environments for a context $\Delta$. Given a relational environment
$\rho \in \mathrm{RelEnv}(\Delta')$ and a simultaneous substitution
$\Delta \vdash \sigma \Rightarrow \Delta'$, we can derive the composed
relational environment (with an abuse of notation) $\rho \circ \sigma
\in \mathrm{RelEnv}(\Delta)$ as $(\rho \circ \sigma)\ \tyPrimNm{X}\
\sigma' = \rho\ \tyPrimNm{X}\ (\sigma' \circ \sigma)$.

As we stated above, index contexts $\Delta$ are interpreted as certain
sets of relation environments, i.e.,~subsets of
$\mathrm{RelEnv}(\Delta)$. Depending on the primitive operations that
we assume for our system, we may have different sets of relational
environments that enforce different invariants. We require that the
sets of relational environments are \emph{valid} in the following
sense:

\begin{definition}
  \label{defn:valid-rel-env-family}
  A family of sets of relational environments $\relEnv{E}(\Delta)
  \subseteq \mathrm{RelEnv}(\Delta)$ is \emph{valid} if the following
  two properties are satisfied:
  \begin{enumerate}
  \item Closure under simultaneous substitutions: if $\rho \in
    \relEnv{E}(\Delta)$ and $\Delta' \vdash \sigma \Rightarrow \Delta$,
    then $\rho \circ \sigma \in \relEnv{E}(\Delta')$.
  \item If we have a pair of relation environments $\rho_1 \in
    \relEnv{E}(\Delta', i\mathord:s')$ and $\rho_2 \in
    \relEnv{E}(\Delta)$, along with a simultaneous substitution
    $\Delta' \vdash \sigma \Rightarrow \Delta$, such that $\rho_1
    \circ \pi_{i\mathord:s'} = \rho_2 \circ \sigma$, then there exists
    a $\rho \in \relEnv{E}(\Delta, i\mathord:s')$ such that $\rho
    \circ \sigma_{i\mathord:s'} = \rho_1$ and $\rho \circ
    \pi_{i\mathord:s'} = \rho_2$.
    % such that the outer edges of the
    % following diagram commute, for all primitive types $\tyPrimNm{X} \in
    % \mathit{PrimType}$:
    % % FIXME: check that these compositions are the right way round
    % % FIXME: re-do this as a set of equations
    % % FIXME: give a better English description of why this is needed
    % \begin{displaymath}
    %   \xymatrix{
    %   {\Delta \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar[d]_{- \circ \sigma}
    %   &
    %   {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[d]^{- \circ \sigma_{s'}} \ar@/^/[rdd]^{\rho_1 \tyPrimNm{X}}
    %   \\
    %   {\Delta' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar[r]^(.45){- \circ \pi_{i\mathord:s'}} \ar@/_/[rrd]_{\rho_2\ \tyPrimNm{X}}
    %   &
    %   {\Delta,i\mathord:s' \Rightarrow \primTyArity(\tyPrimNm{X})} \ar@{.>}[dr]_{\rho\ \tyPrimNm{X}}
    %   \\
    %   &
    %   &
    %   {\Rel(\tyPrimSem{\tyPrimNm{X}})}
    % }
    % \end{displaymath}
    % Then there exists a relation environment $\rho \in
    % \relEnv{E}(\Delta,i\mathord:s')$ (the dotted arrow) such that the
    % two triangles in the bottom right of the diagram commute.
    % FIXME: mention that we already know that the square commutes
  \end{enumerate}
\end{definition}

% For the general
% framework, we assume that, for each index context $\Delta$, we are
% given a set of relation environments $\relEnv{E}(\Delta)$. Note that
% this assignment of sets of relation environments to index contexts is
% not assumed to be compositional: it is not necessarily the case that
% the set of relational environments $\relEnv{E}(\Delta_1,\Delta_2)$ is
% defined in terms of $\relEnv{E}(\Delta_1)$ and
% $\relEnv{E}(\Delta_2)$. However, it must satisfy the following two
% properties:

These conditions ensure that the relational interpretation of types
that we define below behaves correctly with respect to simultaneous
substitution of index expressions (see
\lemref{lem:tyeqsubst-relational}, below). 

% The second condition may
% seem mysterious at first, but it is essential for proving that the
% relational interpretation of universal quantification types behaves
% correctly with respect to application of simultaneous substitution.

Given a relation environment $\rho \in \relEnv{E}(\Delta)$, we define
the set of extensions $\extends{\rho}{i\mathord:s}$ of $\rho$ by an
additional index variable $i\mathord:s$ to be
$\extends{\rho}{i\mathord:s} \isDefinedAs \{ \rho' \in
\relEnv{E}(\Delta,i\mathord:s) \sepbar \rho' \circ \pi_{i\mathord:s} =
\rho \}$. The set of extensions of a relational environment will be
used in the interpretation of the universal and existential type
formers.

We assign a relational interpretation to all well-indexed types
$\Delta \vdash A \isType$ by induction on their derivations,
parameterised by relational environments $\rho \in
\relEnv{E}(\Delta)$:
\begin{eqnarray*}
  \rsem{\tyUnit}{\relEnv{E}}\rho & \isDefinedAs & \{(*,*)\} \\
  \rsem{\tyPrim{X}{e_1,...,e_n}}{\relEnv{E}}\rho & \isDefinedAs & \rho\ {\tyPrimNm{X}}\ (e_1,...,e_n) \\
  \rsem{A \tyArr B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relArrow \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A \tyProduct B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relTimes \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A + B}{\relEnv{E}}\rho & \isDefinedAs & \rsem{A}{\relEnv{E}}\rho \relSum \rsem{B}{\relEnv{E}}\rho \\
  \rsem{\forall i\mathord:s.A}{\relEnv{E}}\rho & \isDefinedAs & \bigcap\{ \rsem{A}{\relEnv{E}}{\rho'} \sepbar \rho' \in \extends{\rho}{i\mathord:s} \} \\
  \rsem{\exists i\mathord:s.A}{\relEnv{E}}\rho & \isDefinedAs & \bigcup\{ \rsem{A}{\relEnv{E}}{\rho'} \sepbar \rho' \in \extends{\rho}{i\mathord:s} \}
\end{eqnarray*}
In this definition we have made use of the following three
constructions on binary relations. If $R \in \Rel(X)$ and $S \in
\Rel(Y)$, then $R \relArrow S \in \Rel(X \to Y)$ is defined as $\{
(f_1,f_2) \sepbar \forall (a_1,a_2) \in R.\ (f_1a_1,f_2a_2) \in S
\}$. With the same assumptions on $R$ and $S$, the relation $R
\relTimes S \in \Rel(X \times Y)$ is defined as $\{
((a_1,b_1),(a_2,b_2)) \sepbar (a_1,a_2) \in R \land (b_1,b_2) \in S
\}$. Finally, the relation $R \relSum S \in \Rel(X + Y)$ is defined as
$\{ (\mathrm{inl}\ x, \mathrm{inl}\ x') \sepbar (x,x') \in R \} \cup
\{ (\mathrm{inr}\ y, \mathrm{inr}\ y') \sepbar (y,y') \in S \}$.

% The following lemma states that the relation interpretation of types
% that we have defined in this section behaves well: the first part of
% the lemma states that two types that are judgmentally equal are given
% equal relational interpretations, and the second part states that
% substitution of index expressions in types can be interpreted by the
% composition of relational environments with simultaneous
% substitutions.
\begin{lemma}\label{lem:tyeqsubst-relational}
  \begin{enumerate}
  \item If $\Delta \vdash A \equiv B \isType$, then for all $\rho \in
    \relEnv{E}(\Delta)$, $\rsem{A}{\relEnv{E}}{\rho} =
    \rsem{B}{\relEnv{E}}{\rho}$;
  \item If $\Delta' \vdash A \isType$ and $\Delta \vdash \sigma
    \Rightarrow \Delta'$, then for all $\rho \in \relEnv{E}(\Delta)$,
    $\rsem{\sigma^*A}{\relEnv{E}}\rho = \rsem{A}{\relEnv{E}}(\rho
    \circ \sigma)$.
  \end{enumerate}
\end{lemma}

Note that the equations in both parts of
\lemref{lem:tyeqsubst-relational} are well-typed by virtue of the
corresponding parts of \lemref{lem:tyeqsubst-erasure}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Well-typed Programs and the Abstraction Theorem}
\label{sec:well-typed-programs}

We now present the rules for well-typed programs over the collection
of types we defined in \autoref{sec:algebraically-indexed-types}. Each
well-type program is assigned an index-erasure semantics, building on
the index-erasure semantics of types we defined in
\autoref{sec:index-erasure-semantics}. Our main result
(\thmref{thm:abstraction}) is that the index-erasure semantics of
every well-typed program is related to itself in the relational
interpretation of its type: this is the abstraction theorem for every
calculus that instantiates our general framework.

Well-typed programs are defined with respect to well-indexed typing
contexts, which are in turn defined with respect to an index
context. Well-indexed typing contexts with respect to an index context
$\Delta$ are sequences of variable/type pairs with no repeated
variable names such that each type is well-indexed with respect to
$\Delta$. Formally, well-indexed typing contexts are defined by the
following two rules:
\begin{mathpar}
  \inferrule*
  { }
  {\Delta \vdash \epsilon \isCtxt}

  \inferrule*
  {\Delta \vdash \Gamma \isCtxt \\ \Delta \vdash A \isType \\ x \not\in \Gamma}
  {\Delta \vdash \Gamma, x : A \isCtxt}
\end{mathpar}
Application of simultaneous substitutions extends to typing contexts
by applying the simultaneous substitution to each type.

The typing rules for our system define the well-typed programs with
respect to an index context $\Delta$ and a type context $\Delta \vdash
\Gamma \isCtxt$. The judgment $\Delta; \Gamma \vdash M : A$ is defined
in \autoref{fig:programs}. The equational theory on types is
incorporated into the type system via the rule \TirName{TyEq}, which
allows for a program that is judged to have type $A$ to also have any
other equal type $B$.
\begin{figure*}[t]
  \centering
  {\tiny
  \begin{mathpar}
    \inferrule* [right=Var]
    {\Delta \vdash \Gamma \isCtxt \\ x : A \in \Gamma}
    {\Delta; \Gamma \vdash x : A}

    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash M : A \\ \Delta \vdash A \equiv B \isType}
    {\Delta; \Gamma \vdash M : B}

    \inferrule* [right=Unit]
    { }
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash M : A \\
      \Delta; \Gamma \vdash N : B}
    {\Delta; \Gamma \vdash (M, N) : A \tyProduct B}

    \inferrule* [right=Proj1]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_1 M : A}

    \inferrule* [right=Proj2]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_2 M : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \mathrm{inl}\ M : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash M : B}
    {\Delta; \Gamma \vdash \mathrm{inr}\ M : A + B}

    \inferrule* [right=Case]
    {\Delta; \Gamma \vdash M : A + B \\
      \Delta; \Gamma, x : A \vdash N_1 : C \\
      \Delta; \Gamma, y : B \vdash N_2 : C}
    {\Delta; \Gamma \vdash \textrm{case}\ M\ \textrm{of}\ \textrm{inl}\ x.N_1; \textrm{inr}\ y.N_2 : C}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, x : A \vdash M : B}
    {\Delta; \Gamma \vdash \lambda x.M : A \tyArr B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash M : A \tyArr B \\
      \Delta; \Gamma \vdash N : A}
    {\Delta; \Gamma \vdash M N : B}

    \inferrule* [right=UnivAbs]
    {\Delta, i \mathord: s; \pi_{i\mathord:s}^*\Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \Lambda i. M : \forall i\mathord:s. A}

    \inferrule* [right=UnivApp]
    {\Delta; \Gamma \vdash M : \forall i\mathord:s. A \\ \Delta \vdash e : s}
    {\Delta; \Gamma \vdash M [e] : (\id_\Delta, e)^*A}

    \inferrule* [right=ExPack]
    {\Delta; \Gamma \vdash M : (\id_\Delta, e)^*A \\ \Delta, i\mathord:s \vdash A \isType}
    {\Delta; \Gamma \vdash \langle[e], M\rangle: \exists i\mathord:s. A}

    \inferrule* [right=ExUnpack]
    {\Delta; \Gamma \vdash M : \exists i\mathord:s. A \\
      \Delta, i\mathord:s; \pi_{i\mathord:s}^*\Gamma, x : A \vdash N : \pi_{i\mathord:s}^*B}
    {\Delta; \Gamma \vdash \mathrm{let}\langle[i],x\rangle = M\ \mathrm{in}\ N : B}
  \end{mathpar}}
  
  \caption{Well-typed Programs}
  \label{fig:programs}
\end{figure*}

\paragraph{Index-Erasure Interpretation of Programs}

% FIXME: do we need to prove something about the effect
% of substitution on the erasure semantics of contexts?

We assign an index-erasure semantics to any well-indexed typing
context $\Delta \vdash \Gamma \isCtxt$ by induction on its structure:
$\ctxtSem{\epsilon} = \{*\}$ and $\ctxtSem{\Gamma, x : A} =
\ctxtSem{\Gamma} \times \tySem{A}$. For a well-typed program $\Delta;
\Gamma \vdash M : A$, we define the \emph{erasure interpretation} as a
function $\tmSem{M} : \ctxtSem{\Gamma} \to \tySem{A}$, that completely
ignores the indexing information. In light of
\lemref{lem:tyeqsubst-erasure}, we define this function directly on
the syntax of well-typed programs, rather than on the typing
derivations. The definition of $\tmSem{M}$ is completely standard,
except for the clauses for universal and existential types:
\begin{displaymath}
  \begin{array}{@{}l}
    \begin{array}{@{}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{\hspace{2em}}l@{\hspace{0.5em}}c@{\hspace{0.5em}}l@{}}
      \tmSem{\Lambda i.\ M}\eta & \isDefinedAs & \tmSem{M}\eta
      &
      \tmSem{M[e]}\eta & \isDefinedAs & \tmSem{M}\eta \\
      \tmSem{\langle [e], M\rangle}\eta & \isDefinedAs & \tmSem{M}\eta
    \end{array} \\
    \tmSem{\mathrm{let}\langle[i], x\rangle = M\ \mathrm{in}\ N}\eta \isDefinedAs \tmSem{N}(\eta, \tmSem{M}\eta)
  \end{array}
\end{displaymath}

\paragraph{The Abstraction Theorem}
%\label{sec:abstraction-theorem}

We now state the abstraction theorem for well-typed programs. To state
and prove this theorem for open programs, we must extend the
relational interpretation of types to typing contexts. The relational
interpretation of contexts is defined by the following clauses, where
we have used the relational lifting of cartesian product $-\relTimes-$
defined in \autoref{sec:relational-semantics}.
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l@{\hspace{1.5em}}l@{\hspace{0.1em}\isDefinedAs\hspace{0.1em}}l}
    \rsem{\epsilon}{\relEnv{E}}{\rho} & \{(*,*)\} &
    \rsem{\Gamma, x : A}{\relEnv{E}}{\rho} & \rsem{\Gamma}{\relEnv{E}}\rho \relTimes \rsem{A}{\relEnv{E}}\rho
  \end{array}
\end{displaymath}
% The relational interpretation of contexts inherits from the relational
% interpretation of types the property of interpreting the application
% of simultaneous substitutions as composition:
\begin{lemma}\label{lem:ctxtsubst-rel}
  If $\Delta' \vdash \Gamma \isCtxt$ and $\Delta \vdash \sigma
  \Rightarrow \Delta'$, then for all $\rho \in \relEnv{E}(\Delta)$,
  $\rsem{\sigma^*\Gamma}{\relEnv{E}}\rho =
  \rsem{\Gamma}{\relEnv{E}}{(\rho \circ \sigma)}$.
\end{lemma}

\begin{theorem}[Abstraction]\label{thm:abstraction}
  If $\Delta; \Gamma \vdash M : A$, then for all $\rho \in
  \relEnv{E}(\Delta)$ and $\eta_1, \eta_2 \in \ctxtSem{\Gamma}$ such
  that $(\eta_1, \eta_2) \in \rsem{\Gamma}{\relEnv{E}}\rho$, we have
  $(\tmSem{M}\eta_1, \tmSem{M}\eta_2) \in \rsem{A}{\relEnv{E}}\rho$.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A General Construction of Relational Environments}
\label{sec:constr-rel-env}

\newcommand{\Free}{\mathrm{Free}}
\newcommand{\semSort}[1]{\llbracket #1 \rrbracket^{\mathcal{S}}}
\newcommand{\semIndexExp}[1]{\llbracket #1 \rrbracket^{\mathcal{I}}}

We now give a general construction of valid families of sets of
relational environments (in the sense of
\defref{defn:valid-rel-env-family}) that will allow us to derive
useful consequences of \thmref{thm:abstraction}. In particular, we
wish to show that certain types are uninhabited. To motivate this,
consider the following type, which makes use of vectors indexed by
translations, as in \autoref{sec:affine-vector-ops}:
\begin{displaymath}
  \forall t\mathord:\SynTransl{2}.\ \tyPrim{vec}{t + t} \to \tyPrim{vec}{t}
\end{displaymath}
In \exref{ex:uninhabited-type} we claimed that this type is
uninhabited. Intuitively, it is clear why: given the operations on
vectors we presented in \autoref{sec:affine-vector-ops}, there is no
way of cancelling the additional $t$ in the argument type to get the
result type. More generally, the operations on vectors only allow us
to combine indexes according to the group operations. Thus, if the
index of the result type of a function does not lie within the free
abelian group generated by the indexes of the input types, then there
is no way of writing a program with the given type. We now develop
this idea to generate a family of sets of relational environments that
is valid in the sense of \defref{defn:valid-rel-env-family}. The key
idea is to assign different relational interpretations to types with
indexes that lie outside some fintely generated of index expressions.

\paragraph{Some Universal Algebra}
We make use of some concepts of universal algebra, which now recall.

A \emph{model} for our indexing expressions and their equality is
defined as follows. For each sort $s \in \SortSet$ we assume a carrier
set $\semSort{s}$. We extend this assignment to index contexts and
other sequences of sorts (e.g., type arities) using the cartesian
product of sets: $\semSort{i_1\mathord:s_1,...,i_n\mathord:s_n} =
\semSort{s_1} \times ... \times \semSort{s_n}$. For each index
operation $\texttt{f} \in \IndexOpSet$ with $\indexOpArity(\texttt{f})
= ([s_1,...,s_n],s)$, we assume a function $\semIndexExp{\texttt{f}} :
\semSort{s_1,...,s_n} \to \semSort{s}$. For each well-sorted index
expression $\Delta \vdash e : s$, we assign a function
$\semIndexExp{e} : \semSort{\Delta} \to \semSort{s}$ by recursion on
the structure of $e$. We further assume that for each axiom $\Delta
\vdash e \stackrel{ax}\equiv e' : s \in \IndexAxiomSet$, we have
$\semIndexExp{e} = \semIndexExp{e'}$. A \emph{model} is a pair
$\mathcal{M} = (\semSort{\cdot}_{\mathcal{M}},
\semIndexExp{\cdot}_{\mathcal{M}})$ such that all the axioms in
$\IndexAxiomSet$ are satisfied.

Given a pair of models $\mathcal{M}_1 = (\semSort{\cdot}_1,
\semIndexExp{\cdot}_1)$ and $\mathcal{M}_2 = (\semSort{\cdot}_2,
\semIndexExp{\cdot}_2)$, a \emph{homomorphism} $h : \mathcal{M}_1 \to
\mathcal{M}_2$ is a family of functions $\{ h_s : \semSort{s}_1 \to
\semSort{s}_2 \}_{s \in \SortSet}$ such that for each $\texttt{f} \in
\IndexOpSet$, we have $h_s(\semIndexExp{\texttt{f}}_1 (x_1,...,x_n)) =
\semIndexExp{\texttt{f}}_2(h_{s_1}x_1, ..., h_{s_n}x_n)$.

Let $A = \{ A_s \}_{s \in \SortSet}$ be a family of finite sets
indexed by sorts. We construct an index context $\Delta_A$ which has
variables $a\mathord:s$ for each $a \in A_s$. The \emph{free} model
over $A$, denoted $\Free(A)$, is defined by setting
$\semSort{s}_{\Free(A)} = \{e \sepbar \Delta_A \vdash e :
s\}/\mathord\equiv$, where we quotient by the equality judgment
defined in \autoref{sec:type-equality}. The free model has
$\semIndexExp{\texttt{f}}_{\Free(A)}(e_1,..,e_n) =
\texttt{f}(e_1,...,e_n)$.

\paragraph{Relational Environments} We now fix some model
$\mathcal{M}$ that will provide the underlying interpretation of index
expressions. As we indicated above, we wish to discriminate between
index expressions that are generated from some finite set of ``input''
expressions and those that are not. Accordingly, we assume that for
each primitive type $\tyPrimNm{X}$ we have two ways of assigning a
relational meaning to that type. When the index arguments of the type
are within the generated set, we will use a function $R_{\tyPrimNm{X}}
\in \semSort{\primTyArity(\tyPrimNm{X})}_{\mathcal{M}} \to
\Rel(\tyPrimSem{\tyPrimNm{X}})$ that assigns a relational meaning to
every element in the interpretation of the type's argument sorts. When
the index arguments are not within the generated set we default to a
constant relational meaning $R^\bullet_{\tyPrimNm{X}} \in
\Rel(\tyPrimSem{\tyPrimNm{X}})$.

We now use $R_{\tyPrimNm{X}}$ and $R^\bullet_{\tyPrimNm{X}}$ to
construct the relational environments that we are interested in.  Fix
an index context $\Delta$. Let $A = \{ A_s \}_{s \in \SortSet}$ be a
sort-indexed family of finite sets of expressions such that if $e \in
A_s$, then $\Delta \vdash e : s$. Let $h : \Free(A) \to \mathcal{M}$
be a homomorphism. For each $A$ and $h$ we have a relational
environment for the context $\Delta$:
\begin{displaymath}
  \rho^A_h\ \tyPrimNm{X}\ (e_1,...,e_n) = \left\{
    \begin{array}{@{}l@{\hspace{0.5em}}l}
      R^\bullet_{\tyPrimNm{X}} & \textrm{if any }e_i \not\in \Free(A) \\
      R_{\tyPrimNm{X}}(h(e_1),...,h(e_n)) & \textrm{if all }e_i \in \Free(A)
    \end{array}
  \right.
\end{displaymath}
Collecting all these relational environments together yields a family
of relational environments, parameterised by our choice of model,
$\mathcal{M}$, and relational interpretations of primitive types
$R^\bullet,R$:
\begin{displaymath}
  \relEnv{E}_{\mathcal{M},R,R^\bullet}(\Delta) = \{ \rho^A_h \sepbar \forall s.A_s \subseteq \semSort{s}_{\Free(\Delta)}, h : \Free(A) \to \mathcal{M} \}
\end{displaymath}

\begin{theorem}
  The family $\relEnv{E}_{\mathcal{M},R,R^\bullet}$ of sets of
  relation environments is valid in the sense of
  \defref{defn:valid-rel-env-family}.
\end{theorem}

Note that we still need to prove for each instantiation of our general
framework that the program-level primitive operations preserve all the
relations, in order to fulfil the hypothesis of
\thmref{thm:abstraction}. \fixme{This is the content of lemma X, lemma
  Y, lemma Z, below}.

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
