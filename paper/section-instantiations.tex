\section{Geometric Consequences of Abstraction}
\label{sec:instantiations}
We now instantiate our general framework %of the previous section 
with
the indexing theory of \autoref{sec:motivating-examples}, and present
more general and formally-justified theorems for free, type
isomorphisms, and non-definability results.

%\begin{example}[Two-dimensional Geometry] 

We define the ``standard'' model of the indexing theory for the
two-dimensional geometry example as follows. Each of the sorts is
interpreted just as its semantic counterpart: $\semSort{\SynTransl{2}}
= \Transl{2}$, $ \semSort{\SynGL{2}} = \GL{2}$, $
\semSort{\SynOrth{2}} = \Orth{2}$, and $ \semSort{\SynGL{1}} =
\GL{1}$.
%  \begin{displaymath}
%    \begin{array}{@{}llll}
%      \semSort{\SynTransl{2}} = \Transl{2}
%      &
%      \semSort{\SynGL{2}} = \GL{2}
%      &
%      \semSort{\SynOrth{2}} = \Orth{2}
%      &
%      \semSort{\SynGL{1}} = \GL{1}
%    \end{array}
%  \end{displaymath}
  Each of the index operations (e.g.,~the group structure and
  determinant) is interpreted by the intended semantic operation, and
  clearly satisfy the axioms in \exref{ex:two-dim-geo-axioms}. The
  assignment of relations for the primitive types $\tyPrimNm{vec}$ and
  $\tyPrimNm{real}$ is given by: % the following definitions:
  \begin{displaymath}
    \begin{array}{ll}
      R^{\bullet}_{\tyPrimNm{vec}} = \{( \vec{0}, \vec{0} ) \}&
      R_{\tyPrimNm{vec}}(B,\vec{t}) = \{ (\vec{v}, B\vec{v} + \vec{t}) \sepbar \vec{v} \in \mathbb{R}^2 \} \\
      R^{\bullet}_{\tyPrimNm{real}} = \{(0,0)\} &
      R_{\tyPrimNm{real}}(k) = \{ (x, kx) \sepbar x \in \mathbb{R} \}
    \end{array}
  \end{displaymath}
  The definitions of $R_{\tyPrimNm{vec}}$ and $R_{\tyPrimNm{real}}$
  %are as expected. % given the informal definitions we gave in
formalise the informal ones from~\autoref{sec:motivating-examples}, and 
  the definitions of %We have set
  $R^\bullet_{\tyPrimNm{vec}}$ and $R^\bullet_{\tyPrimNm{real}}$ 
  %to relate $\vec{0}$ and $0$ to themselves to 
  account for the
  polymorphic zero constants we have assumed.
%\end{example}

%\begin{lemma}
%  The thing about $\Gamma_\Geom$.
%\end{lemma}

\subsection{Theorems for Free}
\label{sec:theorems-for-free}

Consider the type of the area %of a triangle 
function from
\exref{ex:area-of-triangle-1}:
\begin{displaymath}
  \begin{array}{@{}l}
    \mathrm{area} : \forall B\mathord:\SynGL{2}, t\mathord:\SynTransl{2}.\ \\
    \hspace{0.8cm}\tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{real}{|\det B|}
  \end{array}
\end{displaymath}
By \thmref{thm:abstraction}, we can derive the following free theorem. For all $B \in \GL{2}$, $\vec{t} \in \Transl{2}$, and $\vec{x}, \vec{y}, \vec{z} \in \mathbb{R}^2$, we have 
\begin{displaymath}
  |\det B|(\tmSem{\mathrm{area}}\ \vec{x}\ \vec{y}\ \vec{z}) = \tmSem{\mathrm{area}}\ (B\vec{x} + \vec{t})\ (B\vec{y} + \vec{t})\ (B\vec{z} + \vec{t})
\end{displaymath}
Thus, directly from the type of the $\mathrm{area}$ function, we can
see that its index-erasure semantics is (a) invariant under
translations, and (b) if the inputs are subjected to a linear
transformation $B$, the output varies with the absolute value of the
determinant of $B$.



% Wadler's influential ``Theorems for Free!''  \cite{wadler89theorems}
% emphasised a particular aspect of Reynolds' theory of relational
% parametricity: the fact that we can read off theorems about a program
% simply by looking at the relational interpretation of its type. We now
% state some free theorems that are derivable in each of the three main
% examples we introduced in \autoref{sec:motivating-examples}.

\subsection{Type Isomorphisms}
\label{sec:types-indexed-abelian-groups}
We say that two types $A$ and $B$ are isomorphic, and write $A \cong
B$, if there exist maps between them that are mutually inverse with
respect to contextual equivalence, i.e., if there are terms $\vdash I
: A \to B$ and $\vdash J : B\to A$ such that $x:A\vdash
J(I(x))\stackrel{ctx}\approx x : A$ and $y:B\vdash
I(J(y))\stackrel{ctx}\approx y : B$.
%\[
%x:A\vdash J(I(x))\stackrel{ctx}\approx x : A
%\text{ and }y:B\vdash I(J(y))\stackrel{ctx}\approx y : B.
%\]
That $\cong$ is a congruence relation on types is straightforward. We
can also derive isomorphisms that are independent of the indexing
theory, such as $A\times B \cong B \times A$, and $\forall
i\mathord:s.A\to B\cong A\to\forall i\mathord:s.B$ for $i$ not free in
$A$.

Types indexed by abelian groups induce a particularly rich theory of
type isomorphisms; previous work on
units-of-measure~\cite{kennedy97relational} relates these to
Buckingham's theorem from dimensional analysis. Here we consider the
additive abelian groups of translations and the multiplicative abelian
group of scalings.

\paragraph{Translations} 
Consider first the group $\Transl{2}$ of translations from
\autoref{sec:type-system-geom-intro} and 
\autoref{sec:affine-vector-ops}. For any quantifier-free type $A$
we have: % the isomorphism:
\begin{eqnarray*}
\forall t\mathord:\SynTransl{2}.\tyPrim{vec}{t}\to A
& \cong &
A[0/t]
\end{eqnarray*}
where $A[0/t]$ denotes substitution of the identity translation $0$
for index variable $t$ in type $A$. This isomorphism formalises the
equivalence between \emph{coordinate-free} geometry, expressed by a
polymorphic type whose first argument can be thought of as the
\emph{origin} with respect to which $A$ is specified, and a
\emph{coordinate-based} geometry, expressed by the type $A[0/t]$, in
which the origin is fixed at $(0,0)$. It is sometimes said that an
affine space is a vector space that's forgotten its origin; we have
captured this in a type isomorphism.

\exref{ex:type-iso} is a special case of this isomorphism; another instance is the
type of vector addition:
\begin{eqnarray*}
\forall t_1\mathord:\SynTransl{2}.\forall t_2\mathord:\SynTransl{2}.\tyPrim{vec}{t_1}\to\tyPrim{vec}{t_2}\to\tyPrim{vec}{t_1+t_2}\\
\cong\quad
\forall t_1\mathord:\SynTransl{2}.\tyPrim{vec}{t_1}\to\tyPrim{vec}{t_1}\quad\cong\quad
\tyPrim{vec}{0}
\end{eqnarray*}
\noindent
\newcommand{\transup}[1]{\uparrow_{#1}}
\newcommand{\transdn}[1]{\downarrow_{#1}}
The maps associated with this isomorphism are 
$I = \lambda x. x\ [0]\ 0$ and $J = \lambda y. \Lambda t.\lambda v. \transdn A (y)$,
%\begin{eqnarray*}
%I = \lambda x. x\ [0]\ 0 & \text{ and } &
%J = \lambda y. \Lambda t.\ \lambda v. \trans A v t(y)
%\end{eqnarray*}
where terms $\transdn A : A\to A[0/t]$ and $\transup A : A[0/t] \to A$ are defined by induction over the syntax of $A$:
\begin{eqnarray*}
\transdn{1} & = & \lambda x. x\\ 
\transdn{A_1\times A_2} & = & \lambda p. (\transdn{A_1}(\pi_1 p),\transdn{A_2}(\pi_2 p))\\ 
\transdn{A_1 + A_2} & = & \lambda x.
\textrm{case}\ x\ \textrm{of}\ \textrm{inl}\ y.\textrm{inl}(\transdn{A_1}y)); \textrm{inr}\ y.\textrm{inr}(\transdn{A_2}y)\\ 
\transdn{A_1\to A_2} & = & \lambda f. \lambda x. (\transdn{A_2} (f(\transup{A_1}(x))))\\ 
\transdn{\tyPrim{vec}{e}} & = & \lambda x. x - kv\\ 
\transup{\tyPrim{vec}{e}} & = & \lambda x. x + kv\\ & & \text{ if }e \equiv k t + e'\text{ for
  some }k\in\setOfIntegers \text{ and }e'\text{ with }t\notin e'\\
\end{eqnarray*}
To show $I(J(y))$ is contextually equivalent to $y$ is an easy
induction on $A$ using the fact that the vector $0$
is an identity for vector addition. To show $J(I(x))$ is contextually
equivalent to $x$ we must apply the abstraction theorem and use
the fact that $\tmSem{\transup A}$ and $\tmSem{\transdn A}$ 
considered as relations are simply instances of $\rsem A{}{}$.
%\[
%$\rsem A {t \mapsto v} {} = \{ (x, \tmSem{\transup A (x)}) \mid x \in
%\tySem A\}$.
%\]

\paragraph{Scalings}
Now consider the group $\GL{1}$ of scalings. This time, we can treat
the real-valued argument to a function as a `unit of measure' with
which to scale the result. 
%The small fly in the ointment is that the
Although the argument might be zero, and this cannot be used for scaling,
%Nevertheless, 
we still can obtain the following slightly more complicated
isomorphism:
\begin{eqnarray*}
\forall s\mathord:\SynGL{1}.\tyPrim{real}{s}\to A
& \cong &
A[1/s]\times \forall s\mathord:\SynGL{1}.A
\end{eqnarray*}
The type of $\mathrm{areaCircle}$ from the introduction is one instance:
\begin{eqnarray*}
\forall s\mathord:\SynGL{1}.\tyPrim{real}{s}\to\tyPrim{real}{s\cdot
  s}\\ \quad\cong\quad \tyPrim{real}{1}\times(\forall
s\mathord:\SynGL{1}.\tyPrim{real}{s\cdot s})\\ \quad\cong\quad
\tyPrim{real}{1}\times 1\quad\cong\quad \tyPrim{real}{1}
\end{eqnarray*}
%where %the isomorphism 
The abstraction theorem is used to prove
$\forall s\mathord:\SynGL{1}.\tyPrim{real}{s\cdot s}\cong 1$.
% is proved using
%the abstraction theorem.

%\begin{enumerate}
%\item Two cases: when we have a total ``division'' operation, and when
%  we don't.
%\item Type isomorphisms, based on Smith Normal Form
% \item Non-definability results, based on the non-compositional
%   relational environments
% \item Alteration of the non-definability results in the light of
%   addition of a square root operation
% \item Mention the variation we can obtain by changing some types,
%   e.g. the type of $\mathrm{abs}$. Also, the complex numbers example.
%\end{enumerate}

\subsection{Indefinability}

\fixme{Copy the stuff over from the other file}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
