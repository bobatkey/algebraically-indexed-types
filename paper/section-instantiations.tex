\section{Geometric Consequences of Abstraction}
\label{sec:instantiations}
We now instantiate our general framework %of the previous section with
the indexing theory of \autoref{sec:motivating-examples}, and present
more general and formally-justified free theorems, type isomorphisms,
and non-definability results.  For the free theorems and isomorphisms,
we use the model and relational interpretation of primitive types
described in \autoref{sec:relational-semantics}, namely that of
affine transformations for vectors and scaling for scalars.

%\begin{example}[Two-dimensional Geometry] 

\subsection{Free Theorems}
\label{sec:theorems-for-free}

Consider the type of the triangle area %of a triangle 
function from
\exref{ex:area-of-triangle-1}:
\begin{displaymath}
  \begin{array}{@{}l}
    \mathrm{area} : \forall B\mathord:\SynGL{2}, t\mathord:\SynTransl{2}.\ \\
    \hspace{0.8cm}\tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{real}{\abs{\det B}}
  \end{array}
\end{displaymath}
By \thmref{thm:abstraction}, we can derive the following free theorem. For all $B \in \GL{2}$, $\vec{t} \in \Transl{2}$, and $\vec{x}, \vec{y}, \vec{z} \in \mathbb{R}^2$, we have 
\begin{displaymath}
  \abs{\det B}(\tmSem{\mathrm{area}}\ \vec{x}\ \vec{y}\ \vec{z}) = \tmSem{\mathrm{area}}\ (B\vec{x} + \vec{t})\ (B\vec{y} + \vec{t})\ (B\vec{z} + \vec{t})
\end{displaymath}
Thus, directly from the type of the $\mathrm{area}$ function, we can
see that its index-erasure semantics is (a) invariant under
translations, and (b) if the inputs are subjected to a linear
transformation $B$, the output varies with the absolute value of the
determinant of $B$.



% Wadler's influential ``Theorems for Free!''  \cite{wadler89theorems}
% emphasised a particular aspect of Reynolds' theory of relational
% parametricity: the fact that we can read off theorems about a program
% simply by looking at the relational interpretation of its type. We now
% state some free theorems that are derivable in each of the three main
% examples we introduced in \autoref{sec:motivating-examples}.

\subsection{Type Isomorphisms}
\label{sec:types-indexed-abelian-groups}
Types indexed by abelian groups induce a particularly rich theory of
type isomorphisms; previous work on
units-of-measure~\cite{kennedy97relational} relates these to
Buckingham's theorem from dimensional analysis. Here we consider the
additive abelian groups of translations and the multiplicative abelian
group of scalings.

\paragraph{Translations} 
Consider first the group $\Transl{2}$ of translations from
\autoref{sec:type-system-geom-intro} and 
\autoref{sec:affine-vector-ops}. For any quantifier-free type $A$
we have: % the isomorphism:
\begin{eqnarray*}
\forall t\mathord:\SynTransl{2}.\tyPrim{vec}{t}\to A
& \cong &
A[0/t]
\end{eqnarray*}
where $A[0/t]$ denotes substitution of the identity translation $0$
for index variable $t$ in type $A$. This isomorphism formalises the
equivalence between \emph{coordinate-free} geometry, expressed by a
polymorphic type whose first argument can be thought of as the
\emph{origin} with respect to which $A$ is specified, and a
\emph{coordinate-based} geometry, expressed by the type $A[0/t]$, in
which the origin is fixed at $(0,0)$. It is sometimes said that an
affine space is a vector space that has forgotten its origin; we have
captured this in a type isomorphism.

\exref{ex:type-iso} is a special case of this isomorphism; another instance is the
type of vector addition:
\begin{eqnarray*}
\forall t_1\mathord:\SynTransl{2}.\forall t_2\mathord:\SynTransl{2}.\tyPrim{vec}{t_1}\to\tyPrim{vec}{t_2}\to\tyPrim{vec}{t_1+t_2}\\
\cong\quad
\forall t_1\mathord:\SynTransl{2}.\tyPrim{vec}{t_1}\to\tyPrim{vec}{t_1}\quad\cong\quad
\tyPrim{vec}{0}
\end{eqnarray*}
\noindent
\newcommand{\transup}[1]{\mathord\uparrow_{#1}}
\newcommand{\transdn}[1]{\mathord\downarrow_{#1}}
The maps associated with the isomorphism are 
$I = \lambda x. x\ [0]\ 0$ and $J = \lambda y. \Lambda t.\lambda v. \transup A (y)$,
%\begin{eqnarray*}
%I = \lambda x. x\ [0]\ 0 & \text{ and } &
%J = \lambda y. \Lambda t.\ \lambda v. \trans A v t(y)
%\end{eqnarray*}
where terms $\transdn A : A\to A[0/t]$ and $\transup A : A[0/t] \to A$ are defined by induction over the syntax of $A$ (cases omitted for $\transup A$ have definition symmetric to $\transdn A$):
\begin{align*}
\transdn{\tyPrimNm{unit}} &= \lambda x. x \qquad
\transdn{A_1\times A_2} = \lambda p. (\transdn{A_1}(\pi_1 p),\transdn{A_2}(\pi_2 p))\\ 
\transdn{A_1 + A_2} &= \lambda x.
\textrm{case}\ x\ \textrm{of}\ \textrm{inl}\ y.\textrm{inl}(\transdn{A_1}y); \textrm{inr}\ y.\textrm{inr}(\transdn{A_2}y)\\ 
\transdn{A_1\to A_2} &= \lambda f. \lambda x. \transdn{A_2} (f(\transup{A_1}x))\\ 
\transdn{\tyPrim{vec}{e}} &= \lambda x. x - kv \qquad
\transup{\tyPrim{vec}{e}} = \lambda x. x + kv\\ 
\text{ if }e & \equiv k t + e' \text{ for
  some }k\in\setOfIntegers \text{ and }e'\text{ with }t\notin e'
\end{align*}
To show $I(J(y))$ is contextually equivalent to $y$ is an easy
induction on $A$ using the fact that the vector $0$
is an identity for vector addition. To show $J(I(x))$ is contextually
equivalent to $x$ we must apply the abstraction theorem and use
the fact that $\tmSem{\transup A}$ and $\tmSem{\transdn A}$ 
considered as relations are simply instances of $\rsem A{}{}$.
%\[
%$\rsem A {t \mapsto v} {} = \{ (x, \tmSem{\transup A (x)}) \mid x \in
%\tySem A\}$.
%\]

\paragraph{Scalings}
For the group $\GL{1}$ of scalings we can treat
a real-valued argument to a function as a unit-of-measure with
which to scale the result. 
%The small fly in the ointment is that the
Although the argument might be zero, and this cannot be used for scaling,
%Nevertheless, 
we still can obtain the following slightly more complicated
isomorphism:
\begin{eqnarray*}
\forall s\mathord:\SynGL{1}.\tyPrim{real}{s}\to A
& \cong &
A[1/s]\times \forall s\mathord:\SynGL{1}.A
\end{eqnarray*}
The type of $\mathrm{areaCircle}$ from the introduction is one instance:
\begin{eqnarray*}
\forall s\mathord:\SynGL{1}.\tyPrim{real}{s}\to\tyPrim{real}{s^2}\\ \quad\cong\quad \tyPrim{real}{1}\times(\forall
s\mathord:\SynGL{1}.\tyPrim{real}{s^2})\\ \quad\cong\quad
\tyPrim{real}{1}\times 1\quad\cong\quad \tyPrim{real}{1}
\end{eqnarray*}
%where %the isomorphism 
The abstraction theorem is used to prove
$\forall s\mathord:\SynGL{1}.\tyPrim{real}{s^2}\cong 1$.
% is proved using
%the abstraction theorem.

%\begin{enumerate}
%\item Two cases: when we have a total ``division'' operation, and when
%  we don't.
%\item Type isomorphisms, based on Smith Normal Form
% \item Non-definability results, based on the non-compositional
%   relational environments
% \item Alteration of the non-definability results in the light of
%   addition of a square root operation
% \item Mention the variation we can obtain by changing some types,
%   e.g. the type of $\mathrm{abs}$. Also, the complex numbers example.
%\end{enumerate}

\subsection{Non-definability}
\label{sec:types-indexed-abelian-groups-indef}

\newcommand{\Grp}{\mathit{Gr}}
To prove non-definability results, the model and relational interpretation
used in the previous two sections are not sufficient.
This is true even for simple scalars with invariance under scaling.
Consider the type 
$\forall s \mathord: \SynGL{1}.\tyPrim{real}{s^2} \to \tyPrim{real}{s}$. 
There are many functions $f$ in $\mathbb R \to \mathbb R$
that satisfy its relational interpretation, i.e. for which $f(k^2\cdot x) = k\cdot f(x)$ for 
any $k\neq 0$.
Consider 
\[
f(x) = \begin{cases}\sqrt x & \text{if }x > 0\\0&\text{otherwise}\end{cases}
\]
for instance. Yet this type contains only the constant zero function, a fact that
we can prove using a surprisingly simple model!

\begin{example}
If  $\opsCtxt \vdash f : \forall s \mathord: \SynGL{1}.\
\tyPrim{real}{s^2} \to \tyPrim{real}{s}$ 
then $\tmSem f = \lambda x.0$.
To show this, take the model
\[
\begin{array}{l}
\semSort{\SynGL{1}} \isDefinedAs \{0,1\}\qquad
\semIndexExp{1} \isDefinedAs 0 \qquad
\semIndexExp{{}^{-1}}  \isDefinedAs \mathrm{id}\\
\semIndexExp{\cdot} \isDefinedAs \lambda(x,y).(x+y)\mathrel{\mathrm{mod}} 2
\qquad
\semIndexExp{|-|} \isDefinedAs \mathrm{id},

\end{array}
\]
in other words, the additive abelian group $(\mathbb Z_2, +)$. 
Now set
\[
\semPrimType{\tyPrimNm{real}}(z) = 
  \begin{cases} \Delta_{\mathbb R} & \text{if }z=0\\
                      {(0,0)} & \text{if }z=1
\end{cases}
\]
It's easy to check that $(\opsEnv,\opsEnv)\in\rsem{\opsCtxt}*$.

You can think of $z$ as tracking whether or not exponents on scale
parameters are divisible by 2: all the primitive operations in
\autoref{fig:real-ops} produce results with even exponents if their
inputs have even exponents. But the type under consideration here does
not.

By \autoref{thm:abstraction} we have that $(f,f)\in\rsem{\forall s
  \mathord: \SynGL{1}.\ \tyPrim{real}{s^2} \to \tyPrim{real}{s}} *$.
Expanding the definitions, this means that for any
$z\in\semSort{\SynGL{1}}$ and any
$(x,y)\in\semPrimType{\tyPrimNm{real}}((z+z)\mathrel\textrm{mod}2)$, it is the case that
$(f(x),f(y))\in\semPrimType{\tyPrimNm{real}}(z)$. Set $z = 1$.  
Then we have that if $x=y$ then $f(x)=f(y)=0$.
\qed
\end{example}

The particular model and relational interpretation used here is devised only to
rule out the `square root type' (it does not rule out a `cube root type', for instance); 
nevertheless, it is possible to devise craftier interpretations that serve up both invariance
and more general non-definability results. For example, we can set
\begin{align*}
\semSort{\SynGL{1}} & \isDefinedAs \mathbb \mathbb \GL{1} \times \mathbb Q &
\semIndexExp{\cdot} & \isDefinedAs (\cdot,+) & 
\semIndexExp{1} & \isDefinedAs (1,0) \\
\semIndexExp{{}^{-1}} & \isDefinedAs \mathrm{({}^{-1},-)} &
\semIndexExp{|\cdot|} & \isDefinedAs \mathrm{(|\cdot|,\mathrm{id})}
\end{align*}
and
\[
\semPrimType{\tyPrimNm{real}}(k,q) = 
  {\begin{cases} \{(x,k x) \sepbar x \in \mathbb R \} & \text{if }q \in \mathbb Z\\
                      {(0,0)} & \text{otherwise}
  \end{cases}}
\]

\begin{example}
Suppose we extend the operations $\opsCtxt$ of \autoref{fig:real-ops}
and corresponding $\opsEnv$ with a square root operation typed by
\[
\mathrm{sqrt} : \forall s\mathord: \SynGL{1}.\tyPrim{real}{s^2} \to \tyPrim{real}{s}.
\]
If  $\opsCtxt \vdash f : \forall s \mathord: \SynGL{1}.\
\tyPrim{real}{s^3} \to \tyPrim{real}{s}$ 
then $\tmSem f = \lambda x.0$.
To show this, take the model
\begin{align*}
\semSort{\SynGL{1}} & \isDefinedAs \mathbb Q &
\semIndexExp{\cdot} & \isDefinedAs + & 
\semIndexExp{1} & \isDefinedAs 0 &
\semIndexExp{{}^{-1}} & \isDefinedAs \mathrm{-} &
\semIndexExp{|\cdot|} & \isDefinedAs \mathrm{id},
\end{align*}
in other words, the additive abelian group $(\mathbb Q, +)$. 
Now set
\[
\semPrimType{\tyPrimNm{real}}(q) =
\begin{cases} \Delta_{\mathbb R} & \text{if }\exists n, 2^n q \in\mathbb Z\\
\{(0,0)\} & \text{otherwise}
\end{cases}
\]
It's easy to check that $(\opsEnv,\opsEnv)\in\rsem{\opsCtxt}*$.

Here $q$ is tracking the exponents on scale parameters, with
$\semPrimType{\tyPrimNm{real}}(q)$ accepting only the zero value
unless the denominator of $q$ is a power of two (a so-called
\emph{dyadic} number).  
Applying the abstraction theorem and expanding, we have that for
any
$q\in\mathbb Q$ and any
$(x,y)\in\semPrimType{\tyPrimNm{real}}(3q)$, it is the case that
$(f(x),f(y))\in\semPrimType{\tyPrimNm{real}}(q)$. Set $q = \frac 1 3$.  
Then we have that if $x=y$ then $f(x)=f(y)=0$.
\qed
\end{example}

For proving non-definability results, we consider the general case of
a sort $\mathsf{G}$ with the equational theory of abelian groups. We
assume a group-indexed primitive type $\tyPrimNm{G}$ and set of
primitive operations typed by $\Gamma_\Grp$ that include the group
identity $1:\tyPrim{G}{1}$, operation $(\cdot): \forall
a,b\mathord:\mathsf{G}.\ \tyPrim{G}{a} \to \tyPrim{G}{b} \to
\tyPrim{G}{a\cdot b}$ and inverse $\ ^{-1}: \forall
a\mathord:\mathsf{G}.\ \tyPrim{G}{a} \to \tyPrim{G}{a^{-1}}$. The
context $\Gamma_\Grp$ may also include members with types of the form
$\forall \vec{a}\mathord:\mathsf{G}.\ \tyPrim{G}{e_1} \to ...
\tyPrim{G}{e_n} \to \tyPrim{G}{e}$ as long as the result index $e$ is
generated by the set $\{e_1,...,e_n\}$. One instance is the
sort~$\SynTransl{2}$ with $0$, $(+)$ and $\mathrm{negate}$ on
$\tyPrim{vec}{t}$. For the purposes of non-definability results, we
may choose an arbitrary index-erasure semantics with $\eta_\Grp \in
\ctxtSem{\Gamma_\Grp}$.

We use the construction of definability relational environments
from \autoref{sec:constr-rel-env}, with $R^\bullet_{\tyPrimNm{G}} =
\emptyset$, to give a pre-substitutive family $\relEnv{E}_\Grp$. This
gives us the following lemma and theorem.

\begin{lemma}\label{lem:geom-environments-2}
  For all $\Delta$ and $\rho \in \relEnv{E}_\Grp(\Delta)$,
  $(\eta_\Grp,\eta_\Grp) \in \rsem{\Gamma_\Grp}{\relEnv{E}_\Grp}\rho$.
\end{lemma}

% For index-erasure interpretation, we assume a (not necessarily
% abelian) group $(G, 1, \cdot, \ ^{-1})$. Let $Z(G)$ be the centre of
% the $G$ %: i.e.,~the set of elements that commute with every other
% %element in $G$. We set 
% and $\tyPrimSem{G} = G$. For each index context $\Delta$, the set
% $\relEnv{E}_\Grp(\Delta)$ of relational environments is defined to be
% $\{ \rho_{(H,h)} \sepbar H\textrm{ is a subgroup of }(\Delta
% \Rightarrow \mathsf{G})/\equiv, h\textrm{ is a group homomorphism }H
% \to Z(G) \}$, where
% \begin{displaymath}
%   \rho_{(H,h)}\ \tyPrimNm{G}\ (e) = \left\{
%     \begin{array}{ll}
%       \{ \} & \textrm{if}\ e\not\in H \\
%       \{ (x, h(e)\oplus x) \sepbar x \in G \} & \textrm{if}\ e\in H
%     \end{array}
%   \right.
% \end{displaymath}


Writing $i^n$ for $n$-fold iteration of the group operation, we have:
\begin{theorem}
  Let $m$ and $n$ be natural numbers. For all $n$-by-$m$-matrices of
  natural numbers $A$ and $m$-by-$1$ matricies of integers $\vec{b}$,
  there exists a quantifier-free program $M$ such that:
  \begin{displaymath}
    i_1,\dots,i_m\mathord:\mathsf{G}; \Gamma_\Grp \vdash M : \tyPrim{G}{e_1} \to \dots \to \tyPrim{G}{e_n} \to \tyPrim{G}{e}
  \end{displaymath}
  where $e_j = i_1^{A_{j1}}\cdots i_m^{A_{jm}}$ and $e = i_1^{b_1}\cdots i_m^{b_m}$, iff there is a solution $\vec{x}$
  in the integers to the equation $A \vec x = \vec{b}$.
\end{theorem}
The uninhabited type $\forall t \mathord: \SynTransl{2}.\
\tyPrim{vec}{t + t} \to \tyPrim{vec}{t}$ from
\exref{ex:uninhabited-type} is an instance of this theorem.  
%\begin{proof}
%  (If) The program $\Lambda i_1\dots i_m.\ \lambda g_1\dots g_n.\
%  g_1^{x_1}\dots g_n^{x_n}$ satisfies the typing judgment
%  (\ref{eq:fo-group-type}).

%  (Only if) Assume that there is a program $M$ satisfying the typing
%  judgment (\ref{eq:fo-group-type}). By \thmref{thm:abstraction} we
%  know that for all relational environments $\rho \in
%  \relEnv{E}_\Grp(i_1,\dots,i_m)$, and all $g_j,g'_j \in G$,
%  \begin{displaymath}
%    \begin{array}{l}
%      (g_1,g'_1) \in \rho\ \tyPrimNm{G}\ (e_1) \land \dots \land (g_n,g'_n) \in \rho\ \tyPrimNm{G}\ (e_n) \Rightarrow \\
%      \quad (\tmSem{M}g_1\dots g_n, \tmSem{M}g'_1\dots g'_n) \in \rho\ \tyPrimNm{G}\ (e)
%    \end{array}
%  \end{displaymath}
%  We select the relational environments
%  \begin{displaymath}
%    \rho\ \tyPrimNm{G}\ (e) = \left\{
%      \begin{array}{ll}
%        \{(g,g) \sepbar g \in \mathcal{G} \} &
%        \begin{array}[t]{@{}l}
%          \textrm{if}\ e = e_1^{x_1}\dots e_n^{x_n} \\
%          \textrm{ for some }x_1,\dots,x_n \in \mathbb{Z}
%        \end{array}
%        \\
%        \{\} & \textrm{otherwise}
%      \end{array}
%    \right.
%  \end{displaymath}
%  Now, for any $g_1,\dots,g_m \in \mathcal{G}$, we know that, for all
%  $j$, $(g_j,g_j) \in \rho\ \tyPrimNm{G}\ (e_j)$, so we know that
%  $(\tySem{M}g_1\dots g_n, \tySem{M}g_1 \dots g_n) \in \rho\
%  \tyPrimNm{G}\ (e)$. Thus there exist integers $x_1,...,x_n$ such
%  that $e = e_1^{x_1}\dots e_n^{x_n}$. But we also know that $e =
%  i_1^{b_1}...i_m^{b_m}$. By the cancellation property of free groups,
%  we learn that $x_1,...,x_n$ is the solution we need.
%\end{proof}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
