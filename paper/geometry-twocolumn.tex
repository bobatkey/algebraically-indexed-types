\section{Geometry via Algebraically Indexed Types}
\label{sec:motivating-examples}

We motivate this paper's goal of investigating algebraically-indexed
types and their relational interpretations by presenting a novel type
system for writing programs that manipulate two-dimensional geometric
data. Geometry is rich with operations that are invariant under
transformation: affine operations are invariant under change of
origin, vector space operations are invariant under change of basis,
and the Euclidean dot product is invariant under orthogonal changes of
basis. Moreover, some operations are interestingly variant under
transformations: for example, the cross product varies with scalings
of the plane. We incorporate this extra information about our
geometric primitives into the type system by means of algebraically
indexed types.

\subsection{Origin Invariance and Representation Independence}

When writing programs that manipulate geometric data, the basic data
structure is the $n$-tuple of numbers. In the 2-dimensional case,
tuples $\vec{v} = (x,y)$ are called upon to represent both
\emph{points}---offsets from some origin---and
\emph{vectors}---offsets in their own right. Points and vectors are
very different despite their common representation.

Distinguishing between points and vectors is the key feature of
\emph{affine geometry} (see, for example, Gallier's book
\cite{gallier11geometric}, Chapter 2). Traditionally in computational
geometry libraries, the distinction between points and vectors has
either been left to the programmer to maintain by themselves, or has
been enforced through the use of separate abstract types for points
and vectors (one might say that the standard mathematical formulation
of affine spaces uses the abstract types approach). Here, we
investigate a more sophisticated approach using types indexed by
change of origin transformations, and think of the difference between
points and vectors as a change of data representation.

Putting this in concrete terms, if we have two origins, $(0,0)$ and
$(10,20)$, then the tuple $(1,1)$ with respect to the first origin and
$(11,21)$ with respect to the second origin represent the \emph{same}
point because they have the same displacement from their respective
origins. It is merely an artifact of our representation of points as
pairs of numbers that these appear to be different. When we write
programs that manipulate data that represents points, we ought to
ensure that our programs are invariant with respect to changes in the
choice of origin. On the other hand, vectors are not intended to be
regarded as invariant under change of origin. Vectors represent
offsets and the vector $(0,0)$ always represents the zero offset.

Invariance under change of representation immediately recalls
Reynolds' fable about two professors teaching the theory of complex
numbers \cite{reynolds83types}. One professor chooses rectangular
coordinates ($x + iy$), while the other chooses polar coordinates
($\alpha\cos\theta + i\alpha\sin\theta$). Happily, after learning the
basic operations on complex numbers in the two representations, the
two classes can interact because the theory of complex numbers is
invariant with respect to the choice of representation. Reynolds
formalises the idea of invariance with respect to changes of
representation as preservation of relations. If a binary relation $R$
relates two representations of a concept---for example the rectangular
and polar representations of the same complex number are
related---then a program that manipulates complex numbers at a level
of abstraction above their specific representation should preserve the
relation $R$. For example, let $f$ be a program taking complex numbers
to complex numbers that respects invariance under change of
representation. Then if $c$ is a complex number in rectangular form,
and $c'$ is a complex number in polar form such that $R$ relates them,
which we write as $(c,c') \in R$, then it is the case that $(f(c),
f(c')) \in R$.

We now apply Reynolds' relational approach to the geometric
setting. We define a family of binary relations on $\mathbb{R}^2$
which is indexed by changes of origin. Changes of origin are
represented by vectors in $\mathbb{R}^2$, and form a group under
addition. To emphasise the intended meaning as translations, we write
the collection of all change of origin offsets as $\Transl{2}$. By
quantifying over all changes of origin we will be able to ensure that
our programs are invariant with respect to the particular choice of
origin. The members of the $\Transl{2}$-indexed family of binary
relations $\{ R_{\vec{t}} \subseteq \mathbb{R}^2 \times \mathbb{R}^2
\}_{\vec{t} \in \Transl{2}}$ are defined as follows:
\begin{displaymath}
  R_{\vec{t}} = \{ (\vec{v}, \vec{v'}) \sepbar \vec{v'} = \vec{v} + \vec{t} \}
\end{displaymath}

Now consider a function $f$ that, for example, takes two tuples in
$\mathbb{R}^2$ and returns a single tuple in $\mathbb{R}^2$. We intend
that all these tuples represent points with respect to the same
origin, but that the function itself should be invariant with respect
to the choice of origin. We use Reynolds' idea of preservation of
relations to formalise this: for any $\vec{t} \in \Transl{2}$ (i.e.~any
change of origin), the function $f$ should satisfy the following
statement:
\begin{equation}\label{eq:f-preserve-rel-frame}
  \forall (\vec{v_1},\vec{v'_1}) \in R_{\vec{t}}, (\vec{v_2},\vec{v'_2}) \in R_{\vec{t}}. (f(\vec{v_1}, \vec{v_2}), f(\vec{v'_1}, \vec{v'_2})) \in R_{\vec{t}}
\end{equation}
Unfolding the definition of $R_{\vec{t}}$, this statement is
equivalent to the following statement expressing invariance of $f$
with respect to changes of origin: for all $\vec{t} \in \Transl{2}$:
\begin{equation}\label{eq:f-invariant-frame}
  \forall \vec{v_1}, \vec{v_2}.\ f(\vec{v_1} + \vec{t},\vec{v_2} + \vec{t}) = f(\vec{v_1},\vec{v_2}) + \vec{t}.
\end{equation}
So Reynolds' preservation of relations, when instantiated with the
family of relations $\{R_{\vec{t}}\}$, yields exactly the geometric
property of invariance under change of origin.

% An example function $f$ that satisfies
% \statementref{eq:f-invariant-frame} is the following function that
% computes a particular affine combination of two points by working
% directly on their coordinate representation:
% \begin{displaymath}
%   f(\vec{v_1}, \vec{v_2}) = \frac{1}{2}\vec{v_1} + \frac{1}{2}\vec{v_2}.
% \end{displaymath}
% In general, affine combinations of points $\lambda_1\vec{v_1} +
% \lambda_2\vec{v_2}$, where $\lambda_1 + \lambda_2 = 1$, satisfy
% \statementref{eq:f-invariant-frame}. Affine combination is one of the
% fundamental building blocks of affine geometry -- the properties of
% points invariant under invertible affine maps
% (\cite{gallier11geometric}, Chapter 2). If we drop the condition that
% $\lambda_1 + \lambda_2 = 1$, then we are dealing with linear
% combinations of vectors, and we are no longer invariant with respect
% to changes of frame. However, linear combinations are invariant with
% respect to change of basis. We can represent changes of basis as
% linear invertible maps $B : \mathbb{R}^2 \to \mathbb{R}^2$. The set of
% all such maps forms the general linear group $\GL(2)$. We now define
% another family of relations $\{R_{\texttt{vec}}(B) \subseteq
% \mathbb{R}^2 \times \mathbb{R}^2 \}_{B \in \GL(2)}$ that relates two
% points up to change of basis:
% \begin{displaymath}
%   R_{\texttt{vec}}(B) = \{ (\vec{v_1},\vec{v_2}) \sepbar B\vec{v_2} = \vec{v_1} \}.
% \end{displaymath}
% Now the functions $f_{\lambda_1\lambda_2}(\vec{v_1},\vec{v_2}) =
% \lambda_1\vec{v_1} + \lambda_2\vec{v_2}$, for arbitrary $\lambda_1$
% and $\lambda_2$, do preserve the relations $R_{\texttt{vec}}(B)$, for
% all $B \in \GL(2)$. Unfolding the definition of $R_{\texttt{vec}}(B)$
% in the analogous statement to \statementref{eq:f-preserve-rel-frame}
% for $R_{\texttt{vec}}$ instead of $R_{\texttt{pt}}$, we can see that
% preservation of the relations $R_{\texttt{vec}}$ characterises the
% functions that are invariant under change of basis. For all $B \in \GL(2)$, we have
% \begin{displaymath}
%   \forall \vec{v_1}, \vec{v_2}.\ f(B\vec{v_1},B\vec{v_2}) = B(f(\vec{v_1},\vec{v_2})),
% \end{displaymath}
% and this is exactly the property of invariance under change of basis
% we required above of programs manipulating vectors.

% Note that the family of relations $R_{\texttt{vec}}$ is just
% $R_{\texttt{pt}}$ when restricted to elements of the group
% $\GL(2)$. In the type system we introduce in the next section, we
% combine points and vectors into the same data type. Whether it
% represents a point or a vector depends on the group of geometric
% transformations that we expect it to be invariant under.

% FIXME: vectors are not invariant under change of origin, so they are
% represented by the relation $R_0$, which is just equality. But they,
% and points are invariant under change of basis. However, as we shall
% see below, not all operations are invariant under all changes of
% basis. In particular the dot product is only invariant under
% orthogonal transformations.

\subsection{A Type System for Change of Origin Invariance}
\label{sec:type-system-geom-intro}

Reynolds' further insight was to see how preservation of relations by
the denotational interpretations of programs can automatically be
established by following a typing discipline. In Reynolds' case, the
typing discipline was the polymorphic $\lambda$-calculus where new
types can be constructed by universal quantification over all
types. Universal type quantification is commonly written $\forall
\alpha. A$, which denotes a type that may be instantiated with any
other type $B$ by replacing the type variable $\alpha$ with $B$ in
$A$.

In terms of relations, Reynolds interprets universal quantification
over types as quantification over binary relations between denotations
of types. In the statements of geometric invariance that we stated in
the previous section (e.g., \statementref{eq:f-invariant-frame}), we
did not quantify over all relations. Instead, we quantified over all
changes of origin and used the choice to select a relation from the
family $\{R_{\vec{t}}\}$. Driven by this observation, we introduce
quantification over changes of origin into the language of types.  We
use the notation $\forall t \mathord: \SynTransl{2}. A$ for
quantification over all 2-dimensional translations (i.e.~choices of
origin) $t$. We refer to $\SynTransl{2}$ as the \emph{sort} of
$t$. Note that we have used a different font to distinguish the
semantic group $\Transl{2}$ from the syntactic sort $\SynTransl{2}$.

The sort $\SynTransl{2}$ represents an abelian group, so we can combine
its elements using the usual group operations. We write operations
additively, using $e_1 + e_2$ for the group operation, $-e$ for
inverse and $0$ for the unit.  We also regard expressions built from
variables and the group operations up to the abelian group axioms. For
example, $e_1 + (e_2 + e_3)$ and $(e_1 + e_2) + e_3$ are to be
regarded as equivalent.

Our language of types also includes the common type constructors for
function types, $A \to B$, sum types $A + B$, unit type
$\tyPrimNm{unit}$ and tuple types $A \times B$. We also assume a
primitive type $\tyPrimNm{real}$, used to represent scalars. As we
noted at the start of the previous section, the central data structure
in geometric applications is the tuple of real numbers for
representing points and vectors. However, we cannot simply express
this as the type $\tyPrimNm{real} \times \tyPrimNm{real}$ because it
will not have the correct relational interpretation. (Two elements of
type $\tyPrimNm{real}$ will be related if and only if they are equal,
and hence two elements of $\tyPrimNm{real} \times \tyPrimNm{real}$
will be related if and only if they are equal, by Reynolds' definition
of the relational interpretation of tuple types.) Therefore, we
introduce a new type indexed by expressions $e$ of sort
$\SynTransl{2}$ to represent points \emph{and} vectors:
$\tyPrim{vec}{e}$. The indexing argument $e$ represents the possible
amount of displacement by change of origin this point may have been
subjected to. We have used the name $\tyPrimNm{vec}$, even though we
have taken pains to separate geometric points and vectors, to recall
the computer science notion of vector as a sequence of values of
homogeneous type which has a known length (in this case two).

We now sketch the interpretation of the types $\tyPrim{vec}{e}$ and
$\forall t\mathord:\SynTransl{2}.A$. In our calculus, each type has two
interpretations: an index-erasure interpretation that ignores the
indexing expression $e$, and a relational interpretation as a binary
relation on the index-erasure interpretation. For now, we assume we
are given some way of turning an expression $e$ of sort $\SynTransl{2}$
into an actual element $\sem{e}\rho$ of the group $\Transl{2}$, under
some environment $\rho$ which tells how to interpret the free
variables. The (simplified) index-erasure and relation interpretations
of the types $\tyPrim{vec}{e}$ are:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{vec}{e}} & \mathbb{R}^2 \\
    \rsem{\tyPrim{vec}{e}}{}\rho & R_{\sem{e}\rho} = \{ (\vec{v},\vec{v'}) \sepbar \vec{v'} = \vec{v} + \sem{e}\rho \}
  \end{array}
\end{displaymath}
The index-erasure interpetation of universal quantification $\forall
t\mathord:\SynTransl{2}.A$ is simply the interpretation of the
underlying type $A$. The relational interpretation intersects the
relational interpretations of the type $A$ under all extensions of the
relational environment $\rho$:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\forall t\mathord:\SynTransl{2}.A} & \tySem{A} \\
    \rsem{\forall t\mathord:\SynTransl{2}.A}{}\rho & \bigcap\{ \rsem{A}{}{\rho'} \sepbar \rho' \in \extends{\rho}{t\mathord:\SynTransl{2}} \}
  \end{array}
\end{displaymath}
The exact definition of $\extends{\rho}{t\mathord:\SynTransl{2}}$
depends on which (possibly non-compositional) interpretation of
relational environments that we take. For now, it will suffice to
think of relational environments as simply mappings from free
variables of sort $\SynTransl{2}$ to the group $\Transl{2}$, and
extension as just adding an extra component to the tuple. The general
index-erasure semantics will be given in
\autoref{sec:index-erasure-semantics}. The relational interpretation
is in general more complex, due to the possibility of
non-compositional interpretations of free index variables. The
relational interpretation will be presented in
\autoref{sec:relational-semantics}.

In the previous section, we discussed functions $f : \mathbb{R}^2
\times \mathbb{R}^2 \to \mathbb{R}^2$ that have the property that they
preserve all changes of origin. We can now express this property as a
type:
\begin{displaymath}
  \mathrm{f} : \forall t \mathord: \SynTransl{2}.\ \tyPrim{vec}{t} \times \tyPrim{vec}{t} \to \tyPrim{vec}{t}
\end{displaymath}
Spelling out the relational interpretation of this type using the
definitions above (and the standard relational interpretations for
tuple and function types), we obtain
\statementref{eq:f-invariant-frame}.

\subsection{Affine and Vector Operations}
\label{sec:affine-vector-ops}

Invariance under change of origin is the key feature of affine
geometry, and the central operation of affine geometry is the affine
combination of points: $\lambda_1\vec{v_1} + \lambda_2\vec{v_2}$,
where $\lambda_1 + \lambda_2 = 1$. Geometrically, affine combination
can be interpreted as interpolation between the points represented by
$\vec{v_1}$ and $\vec{v_2}$. We add affine combination of points to
our calculus, with the following typing and intended denotation:
\begin{displaymath}
  \begin{array}{l}
    \mathrm{affComb} :\forall t \mathord: \SynTransl{2}.\ \tyPrim{vec}{t} \to \tyPrimNm{real} \to \tyPrim{vec}{t} \to \tyPrim{vec}{t} \\
    \sem{\mathrm{affComb}}\ \vec{v_1}\ r\ \vec{v_2} = (1-r)\vec{v_1} + r\vec{v_2}
  \end{array}
\end{displaymath}
It can be verified by hand that the intended denotation
$\sem{\mathrm{affComb}}$ has the invariance property specified by its
type.
% By defining the primitive function $\mathrm{affComb}$ to take a
% single $\tyPrimNm{real}$ parameter $t$, we can easily ensure that we
% are taking the affine combination of two representatives of points,
% and not just an arbitrary linear combination.

\begin{example}
  The evaluation of quadratic B\'{e}zier curves (B\'{e}zier curves
  with two endpoints and a single control point) can be expressed
  using the affine combination primitive and three steps of De
  Casteljau's algorithm:
  \begin{displaymath}
    \begin{array}{@{}l}
      \mathrm{quadB\acute{e}zier} : \forall t \mathord:\SynTransl{2}.\ \tyPrim{vec}{t} \to \tyPrim{vec}{t} \to \tyPrim{vec}{t} \to \tyPrimNm{real} \to \tyPrim{vec}{t} \\
      \mathrm{quadB\acute{e}zier}\ [t]\ p_0\ p_1\ p_2\ s = \\
      \quad \mathrm{affComb}\ [t]\ (\mathrm{affComb}\ [t]\ p_0\ s\ p_1)\ s\ (\mathrm{affComb}\ [t]\ p_1\ s\ p_2) \\
    \end{array}
  \end{displaymath}
  For two endpoints $p_0$ and $p_2$ and a control point $p_1$, an
  application $\mathrm{quadB\acute{e}zier}\ p_0\ p_1\ p_2\ s$ for $s
  \in [0,1]$ gives us the point on the curve at ``time'' $s$. Note
  that the type of $\mathrm{quadB\acute{e}zier}$ tells us immediately
  that it preserves all changes of origin.
\end{example}

% Affine combination only provides us with an operation on points. We
% are also interested in operations on the vectors representing offsets
% between points. We now examine the correct types to assign to the
% vector space operations of addition of vectors, negation of vectors,
% multiplication by a scalar and the zero vector. The typings of these
% operations will make use of the abelian group structure of change of
% origin translations.

Vector operations are not invariant under change of origin. The
obvious type for vector addition is therefore:
\begin{displaymath}
  (+) : \tyPrim{vec}{0} \to \tyPrim{vec}{0} \to \tyPrim{vec}{0}
\end{displaymath}
(we write binary operators intended to be used infix in parentheses
when not appearing in infix position, following the Haskell
syntax.)

However, it is possible to give vector addition a more precise type
that shows how it is variant with change of origin:
\begin{displaymath}
  (+) : \forall t_1, t_2 \mathord: \SynTransl{2}.\ \tyPrim{vec}{t_1} \to \tyPrim{vec}{t_2} \to \tyPrim{vec}{t_1 + t_2}
\end{displaymath}
Intuitively, this type says that if the first input vector has been
displaced by $t_1$ and the second by $t_2$, then their sum is
displaced by $t_1 + t_2$. We can also negate vectors, yielding a
vector which points in the opposite direction. Negation negates
translation arguments:
\begin{displaymath}
  \mathrm{negate} : \forall t \mathord: \SynTransl{2}.\ \tyPrim{vec}{t} \to \tyPrim{vec}{-t}
\end{displaymath}
With the primitive operations of addition and negation of vectors, we
can define the derived operation of subtraction:
\begin{displaymath}
  \begin{array}{l}
    (-) : \forall t_1,t_2 \mathord:\SynTransl{2}.\ \tyPrim{vec}{t_1} \to \tyPrim{vec}{t_2} \to \tyPrim{vec}{t_1 - t_2} \\
    (-)\ [t_1]\ [t_2]\ p_1\ p_2 = p_1 + \mathrm{negate}\ p_2
  \end{array}
\end{displaymath}

Given two points that have been constrained to be invariant with
respect to the same change of origin---i.e.~two values of type
$\tyPrim{vec}{t}$---we can compute their offset, which is a vector
expressed with respect to the null change of origin. The offset
operation is a special case of vector subtraction:
\begin{displaymath}
  \begin{array}{l}
    \mathrm{offset} : \forall t \mathord:\SynTransl{2}.\ \tyPrim{vec}{t} \to \tyPrim{vec}{t} \to \tyPrim{vec}{0} \\
    \mathrm{offset}\ [t]\ p_1\ p_2 = p_1 - p_2
  \end{array}
\end{displaymath}
Note how the type of the result of $\mathrm{offset}$ simplifies from
$\tyPrim{vec}{t-t}$ to $\tyPrim{vec}{0}$: the algebraic structure on
the indexing theory induces type equalities.  The type of the vector
addition operation can be specialised to the case of moving a point by
a vector:
\begin{displaymath}
  \begin{array}{l}
    \mathrm{moveBy} : \forall t \mathord:\SynTransl{2}.\ \tyPrim{vec}{t} \to \tyPrim{vec}{0} \to \tyPrim{vec}{t} \\
    \mathrm{moveBy}\ [t]\ p\ v = p + v
  \end{array}
\end{displaymath}
The types we assign to the remaining vector space primitives, the zero
vector and multiplication by a scalar, do not describe any interesting
effect on translations:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}:\hspace{0.5em}}l@{\hspace{4em}}l@{\hspace{0.5em}:\hspace{0.5em}}l}
    \mathrm{0} & \tyPrim{vec}{0}&
    (*) & \tyPrimNm{real} \to \tyPrim{vec}{0} \to \tyPrim{vec}{0}
  \end{array}
\end{displaymath}

% \fixme{If we had dependent types, could the affComb operation be
%   derived from an appropriately dependently typed scaling operation?}

\begin{example}\label{ex:type-iso}
  The vector space operators and the properties that follow from their
  types allow us to establish a useful type isomorphism. Consider
  functions with types following the schema:
  \begin{displaymath}
    \tau_{n} \isDefinedAs \forall t\mathord:\SynTransl{2}.\ \underbrace{\tyPrim{vec}{t} \to ... \tyPrim{vec}{t}}_{n+1\textrm{ times}} \to \tyPrimNm{real}
  \end{displaymath}
  Just by looking at the types $\tau_{n}$, we know that their
  inhabitants will be invariant under change of origin, due to the
  quantification over all $t$ in $\SynTransl{2}$. Therefore, we may as well pick
  one of the input points as the origin and assume that all the other
  points are defined with respect to this chosen origin. This is
  similar to the common mathematical step of stating that, ``without
  loss of generality'', we may pick some point in a description of a
  problem to be the origin, as long as the problem statement is
  invariant under translation.

  The types $\tau_{n}$ are isomorphic to the corresponding types
  $\sigma_{n}$:
  \begin{displaymath}
    \sigma_{n} \isDefinedAs \underbrace{\tyPrim{vec}{0} \to ... \tyPrim{vec}{0}}_{n\textrm{ times}} \to \tyPrimNm{real}
  \end{displaymath}
  We demonstrate this isomorphism formally in
  \autoref{sec:instantiations}, in a more general setting of types
  indexed by abelian groups.

  % The isomorphism between these two families of types can be witnessed
  % by the following two functions.
  % \begin{displaymath}
  %   \begin{array}{l}
  %     i_{n,A} : \tau_{n,A} \to \sigma_{n,A} \\
  %     i_{n,A}\ f\ [B]\ (p_1, p_2, ..., p_n) = f\ [B \ltimes 0]\ (0, p_1, ..., p_n) \\
  %     \\
  %     i^{-1}_{n,A} : \sigma_{n,A} \to \tau_{n,A} \\
  %     i^{-1}_{n,A}\ g\ [F]\ (p_0, ..., p_n) = g\ [\pi_L(F)]\ (p_1-p_0, ..., p_n-p_0)
  %   \end{array}
  % \end{displaymath}
  % The direction defined by the function $i_{n,A}$ treats the inputs
  % $p_1,...,p_n$ as vector offsets from the origin $0$. The direction
  % witnessed by $i^{-1}_{n,A}$ picks the first point to act as the
  % origin, and uses the operation of vector subtraction we defined
  % above to turn each of the other points into offsets from this
  % point. Note that this isomorphism is not unique: for each $n$ we can
  % pick any of the $n+1$ inputs to act as the distinguished
  % origin. Thus the families of types $\tau_{n,A}$ and $\sigma_{n,A}$
  % are isomorphic, but not uniquely isomorphic.
\end{example}

\begin{example}\label{ex:uninhabited-type}
  To this point we have emphasised the properties that we can deduce
  about programs from their types, so called ``free theorems''. By
  refining our relational interpretations of types appropriately it is
  also possible to show that certain types are uninhabited. For
  example, the type $\forall t \mathord: \SynTransl{2}.\
  \tyPrim{vec}{t + t} \to \tyPrim{vec}{t}$ does not have any
  inhabitants. Intuitively, this is because we have no way of removing
  the extra $t$ in $\tyPrim{vec}{t+t}$ using our operations. We
  demonstrate this indefinability result in
  \autoref{sec:types-indexed-abelian-groups}. In order to obtain this
  result, we require a more sophisticated relational interpretation of
  free translation variables than the one we sketched above.
\end{example}

\subsection{Change of Basis Invariance}
\label{sec:motivation-generalising}

From basic linear algebra, we know that the vector operations of
addition, negation and scaling, while not invariant under change of
origin, are invariant under change of basis. Following the same
methodology as we did for origin invariance, we can express basis
invariance by means of preservation of relations indexed by changes of
basis. Change of basis is accomplished by applying an invertible
linear map, and the collection of all invertible linear maps on
$\mathbb{R}^2$ forms the \emph{General Linear} group $\GL{2}$. We
reflect in our language the group $\GL{2}$ as a new indexing sort
$\SynGL{2}$, which has (non-abelian) group structure that we will
write multiplicatively. We also extend the $\tyPrimNm{vec}$ type to be
indexed by elements of $\SynGL{2}$ as well as $\SynTransl{2}$. Thus,
$\tyPrim{vec}{B,t}$ is a vector which varies with change of basis $B$
and change of origin $t$. Formally, the index-erasure and (simplified)
relational semantics of this type are as follows:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{vec}{e_B,e_t}} & \mathbb{R}^2 \\
    \rsem{\tyPrim{vec}{e_B,e_t}}{}\rho & \{ (\vec{v},\vec{v'}) \sepbar \vec{v'} = (\sem{e_B}\rho)\vec{v} + \sem{e_t}\rho \}
  \end{array}
\end{displaymath}

\paragraph{Affine Geometry} The combination of an invertible linear
map and a translation is an \emph{affine transformation}. We can now
assign types to all the primitive affine and vector space operations
that indicates how they they behave with respect to affine
transformations:
\begin{eqnarray*}
  \mathrm{affComb} & : &
  \begin{array}[t]{@{}l}
    \forall B \mathord: \SynGL{2}, t \mathord: \SynTransl{2}.\\
    \hspace{0.2cm} \tyPrim{vec}{B,t} \to \tyPrimNm{real} \to \tyPrim{vec}{B,t} \to \tyPrim{vec}{B,t}
  \end{array}
  \\
  (+) & : &
  \begin{array}[t]{@{}l}
    \forall B \mathord: \SynGL{2}, t_1,t_2 \mathord: \SynTransl{2}. \\
    \hspace{0.2cm}\tyPrim{vec}{B,t_1} \to \tyPrim{vec}{B,t_2} \to \tyPrim{vec}{B,t_1 + t_2}
  \end{array}
  \\
  \mathrm{negate} & : & \forall B \mathord: \SynGL{2}, t \mathord: \SynTransl{2}.\ \tyPrim{vec}{B,t} \to \tyPrim{vec}{B,-t} \\
  0 & : & \forall B \mathord: \SynGL{2}.\ \tyPrim{vec}{B,0} \\
  (*) & : & \forall B \mathord: \SynGL{2}.\ \tyPrimNm{real} \to \tyPrim{vec}{B,0} \to \tyPrim{vec}{B,0}
\end{eqnarray*}

\paragraph{Euclidean Geometry} Euclidean geometry extends affine
geometry with the operation of \emph{dot product} (also known as the
\emph{inner product}) of two vectors. The standard Euclidean dot
product is defined on the coordinate representation in the following
way:
\begin{displaymath}
  (x_1,y_1) \cdot (x_2,y_2) = x_1x_2 + y_1y_2
\end{displaymath}
% The dot product is used to define properties of vectors such as their
% \emph{norm} $||\vec{v}|| = \vec{v}\cdot\vec{v}$, which is the square
% of the length of the vector $\vec{v}$, and the notion of
% orthogonality: two vectors $\vec{v_1}$ and $\vec{v_2}$ are orthogonal
% if $\vec{v_1}\cdot\vec{v_2} = 0$.
To incorporate the operation of dot product into our calculus, we must
assign it a type. The dot product is not invariant under the action of
either of the groups $\GL{2}$ and $\Transl{2}$ that we have considered
so far. However, the dot product is invariant under the subgroup
$\Orth{2}$ of $\GL{2}$ of \emph{orthogonal} linear transformations:
invertible linear maps whose matrix representation's transpose is
equal to their inverse. We introduce orthogonal transformations as a
new sort $\SynOrth{2}$, and overload the multiplicative group
operations syntax for inhabitants of $\SynOrth{2}$. We also assume a
function $\iota_O$ that takes $e : \SynOrth{2}$ to $\iota_O(e) :
\SynGL{2}$. We may now assign a type to the dot product, using
quantification over $\SynOrth{2}$:
\begin{displaymath}
  (\cdot) : \forall O \mathord: \SynOrth{2}.\ \tyPrim{vec}{\iota_OO, 0} \to \tyPrim{vec}{\iota_OO, 0} \to \tyPrimNm{real}
\end{displaymath}

\begin{figure}[t]
  \centering
  \begin{eqnarray*}
    0   &:& \forall s \mathord:\SynGL{1}.\ \tyPrim{real}{s} \\
    1   &:& \tyPrim{real}{1} \\
    (+) &:& \forall s \mathord:\SynGL{1}.\ \tyPrim{real}{s} \to \tyPrim{real}{s} \to \tyPrim{real}{s} \\
    (-) &:& \forall s \mathord:\SynGL{1}.\ \tyPrim{real}{s} \to \tyPrim{real}{s} \to \tyPrim{real}{s} \\
    (*) &:& \forall s_1,s_2 \mathord:\SynGL{1}.\ \tyPrim{real}{s_1} \to \tyPrim{real}{s_2} \to \tyPrim{real}{s_1s_2} \\
    (/) &:&
    \begin{array}[t]{@{}l@{}l}
      \forall s_1,s_2 \mathord:\SynGL{1}.\ \tyPrim{real}{s_1}\ & \to \tyPrim{real}{s_2} \\
      &\to \tyPrim{real}{s_1s_2^{-1}} + \tyPrimNm{unit} \\
    \end{array}\\
    \mathrm{abs} &:& \forall s \mathord:\SynGL{1}.\ \tyPrim{real}{s} \to \tyPrim{real}{|s|} %\\
%    \mathrm{sqrt} &:& \tyPrim{real}{1} \to \tyPrim{real}{1}
  \end{eqnarray*}
  \caption{Operations on scaled real numbers}
  \label{fig:real-ops}
\end{figure}

The cross product of two vectors is defined on coordinate
representations as $(x_1,y_1) \times (x_2,y_2) = x_1y_2 - x_2y_1$.
Geometrically, the cross product is the signed area of the
parallelogram described by the pair of input vectors. Under change of
basis by an invertible linear transformation $B$, the value of the
cross product of two vectors varies with the determinant of $B$. This
corresponds to the scaling of the plane by the change of basis
transformation.

We therefore augment our calculus with a new sort $\SynGL{1}$ of scale
factors (i.e.~$1$-dimensional invertible linear maps). Semantically,
$\SynGL{1}$ ranges over the non-zero real numbers and forms an abelian
group, which we write multiplicatively. We also add two new
operations: determinant, $\det B$, which takes an inhabitant of
$\SynGL{2}$ to its determinant in $\SynGL{1}$, and the operation of
absolute value that takes scaling factors to scaling factors which we
write as $|e|$. We also refine the type $\tyPrimNm{real}$ of real
numbers to be indexed by the sort $\SynGL{1}$: $\tyPrim{real}{e}$,
where the old type $\tyPrimNm{real}$ is just $\tyPrim{real}{1}$. The
collection of operations on real numbers indexed by scaling factors is
shown in \autoref{fig:real-ops}.

With the additional sort $\SynGL{1}$, and the refined type of real
numbers, we can assign a type to the cross product:
\begin{displaymath}
  (\times) : \forall B \mathord: \SynGL{2}.\ \tyPrim{vec}{B,0} \to \tyPrim{vec}{B,0} \to \tyPrim{real}{\det B}
\end{displaymath}
Since the absolute value of the determinant of an orthogonal
transformation is always $1$, we assume $|\det (\iota_O O)| = 1$ to
hold.

\begin{example}\label{ex:area-of-triangle-1}
  Using the operations we have defined in this subsection, we can
  compute the area of a triangle. 
  \begin{displaymath}
    \begin{array}{@{}l}
      \mathrm{area} : \forall B\mathord:\SynGL{2}, t\mathord:\SynTransl{2}.\ \\
      \hspace{0.8cm}\tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{vec}{B, t} \to \tyPrim{real}{|\det B|} \\
      \mathrm{area}\ [B]\ [t]\ p_1\ p_2\ p_3 = \frac{1}{2} * \mathrm{abs}\ ((p_2 - p_1) \times (p_3 - p_1))
    \end{array}
  \end{displaymath}
  The calculation is performed in several steps, each of which removes
  some of the symmetry described by the type of
  $\mathrm{area}$. First, the two offset vectors $p_2 - p_1$ and $p_3
  - p_1$ are computed. These operations remove the effect of
  translations on the result, in exactly the same way as the type
  isomorphism we introduced in \exref{ex:type-iso}. We then compute
  the cross product of the two vectors to determine the area of the
  parallelogram described by the sides of the triangle. This value has
  type $\tyPrim{real}{\det B}$, and we have removed some of the
  symmetry due to invertible linear maps. This value still varies with
  the sign of the determinant, so we remove this symmetry by applying
  the $\mathrm{abs}$ function to leave us with a value of type
  $\tyPrim{real}{|\det B|}$. Finally, we multiply by the constant
  $\frac{1}{2}$ to recover the area of the triangle, rather than the
  whole parallelogram.

  If we specialise $\mathrm{area}$ to just orthogonal transformations,
  we obtain the following type, as a consequence of assuming the
  equation $|\det (\iota_OO)| = 1$:
  \begin{displaymath}
    \begin{array}{@{}l}
      \mathrm{area} : \forall O\mathord:\SynOrth{2}, t\mathord:\SynTransl{2}.\ \\
      \hspace{0.8cm}\tyPrim{vec}{\iota_OO, t} \to \tyPrim{vec}{\iota_OO, t} \to \tyPrim{vec}{\iota_OO, t} \to \tyPrim{real}{1}
    \end{array}
  \end{displaymath}
  This type demonstrates that the area of a triangle is invariant
  under orthogonal transformations and translations. Such combined
  transformations are isometries---distance preserving maps.
\end{example}

% \begin{enumerate}
% \item Possibly do a $n$-body gravity simulator as an example?
% \item Have a special sort and type for rotations. An operation for
%   computing the rotation between two points, and for applying a
%   rotation to a vector. This will allow for more free theorems...
% \end{enumerate}

\subsection{Scale Invariance and Dimensional Analysis}
\label{sec:scale-invariance}

Indexing types by scaling factors brings us to the original
inspiration for the current work: Kennedy's interpretation of his
units of measure type system via scaling invariance
\cite{kennedy97relational}. Kennedy demonstrates how interpreting
types in terms of scaling invariance brings the techniques of
dimensional analysis \fixme{ref} to bear on programming. The types we
have assigned to the real number arithmetic operations in
\autoref{fig:real-ops} are exactly the types Kennedy assigns in his
units of measure system, except for the absolute value operation. The
effect of our assigned type is that, semantically, we are indexing by
non-zero scaling factors, whereas Kennedy indexes by strictly positive
scaling factors. We further examine the typing of the absolute value
operation in \autoref{sec:types-indexed-abelian-groups}.

In our two-dimensional setting, we can make additions to Kennedy's
one-dimensional scaling invariance. We add an operation $\iota_1$
that, semantically, takes scale factors in $\GL{1}$ to invertible
linear maps in $\GL{2}$: i.e.~takes numbers $s$ to matrices $\left(
  \begin{smallmatrix}s & 0 \\ 0 & s\end{smallmatrix}\right)$.  This
operation satisfies the equation $\det (\iota_1 s) = s^2$, indicating
that if we scale the plane by $s$ in both directions, we scale areas
by $s^2$. This is illustrated by the next example.

\begin{example}\label{ex:area-of-triangle-2}
  Just as we specialised the type of the $\mathrm{area}$ function to
  orthogonal transformations in \exref{ex:area-of-triangle-1}, we can
  also specialise $\mathrm{area}$'s type to scaling
  transformations. This yields the type:
  \begin{displaymath}
    \begin{array}{@{}l}
      \mathrm{area} : \forall s\mathord:\SynGL{1}, t\mathord:\SynTransl{2}.\ \\
      \hspace{0.8cm} \tyPrim{vec}{\iota_1s, t} \to \tyPrim{vec}{\iota_1s, t} \to \tyPrim{vec}{\iota_1s, t} \to \tyPrim{real}{s^2}
    \end{array}
  \end{displaymath}
  As expected, the area of a triangle varies with the square of
  scalings of the plane, and this is reflected in the type.
\end{example}

Linear maps of the form $\left(
  \begin{smallmatrix}s & 0 \\ 0 & s\end{smallmatrix}\right)$, as
generated by $\iota_1$, commute with all other invertible linear
maps. (These maps are all the elements of $\GL{2}$ that commute with
everything, and form the \emph{centre} of $\GL{2}$.) Therefore we
assume $(\iota_1 s)B = B(\iota_1 s)$ to hold.

If we keep track of scalings, we may assign more precise types to
scalar multiplcation:
\begin{displaymath}
  (*) : \forall s \mathord: \SynGL{1}, B \mathord: \SynGL{2}.\ \tyPrim{real}{s} \to \tyPrim{vec}{B,0} \to \tyPrim{vec}{\iota_1(s)B,0}
\end{displaymath}
and dot product:
\begin{displaymath}
  \begin{array}{l@{}l}
    (\cdot) : \forall s \mathord: \SynGL{1}, O \mathord: \SynOrth{2}.\ & \tyPrim{vec}{\iota_1(s)\iota_O(O),0} \to\\
    &\tyPrim{vec}{\iota_1(s)\iota_O(O),0} \to \tyPrim{real}{s^2}
  \end{array}
\end{displaymath}

\begin{example}
  With the operations in \autoref{fig:real-ops}, it is not possible to
  write a program with the following type that is not constantly zero:
  \begin{displaymath}
    \forall s \mathord: \SynGL{2}.\ \tyPrim{real}{s^2} \to \tyPrim{real}{s}
  \end{displaymath}
  This was shown by Kennedy for his units of measure system
  \cite{kennedy97relational}.  In particular, it is not possible to
  write a square root function with the above type. The indefinability
  of square root is similar to the uninhabited type from
  \exref{ex:uninhabited-type}.

  In \autoref{sec:types-indexed-abelian-groups} we revisit Kennedy's
  proof and show that if we add square root as a primitive
  operation---with the type above---then it is still not possible to
  construct the cube root function. The indefinability of cube root is
  of interest due to its relevance to the classical problem of
  trisecting an angle by ruler and compass constructions.
\end{example}


%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
