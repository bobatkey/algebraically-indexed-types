\section{Monoid Indexed Types}
\label{sec:monoid-indexed-types}

\newcommand{\Mon}{\textit{Mon}}

In the last section we looked at types indexed by abelian groups. We
now examine an instantiation of our general framework with a monoid
type indexed by elements of a commutative monoid. Our main example of
monoid indexed types is strings indexed by ``taint'' markers: when
strings are appended their taint markers are combined. Thanks to the
information in the indexes, we are able to prove an indefinability
result (\thmref{thm:monoid-indefinability}).

We assume a single indexing sort $\mathsf{M}$, with the monoid
operations of unit and multiplication along with the commutative
monoid axioms. There is a single primitive type $\tyPrimNm{M}$, with
$\primTyArity(\tyPrimNm{M}) = [\mathsf{M}]$. For the index-erasure
semantics, we assume some (not necessarily commutative) monoid $M$,
which we also write multiplicatively. Thus, we set
$\tyPrimSem{\tyPrimNm{M}} = M$. The collection of primitive operations
$\Gamma_{\mathit{Mon}}$ is simply the two monoid operations:
\begin{displaymath}
  \begin{array}{r@{\hspace{0.5em}:\hspace{0.5em}}l@{\hspace{2em}}r@{\hspace{0.5em}:\hspace{0.5em}}l}
    1 & \tyPrim{M}{1}, &
    (\cdot) & \forall a,b\mathord:\mathsf{M}.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to \tyPrim{M}{a b}
  \end{array}
\end{displaymath}
which we interpret using the monoid structure of $M$, giving an
environment $\eta_\Mon \in \ctxtSem{\Gamma_\Mon}$.

For the sets of relational environments, we make use of the
construction in \autoref{sec:constr-rel-env}, setting the chosen model
$\mathcal{M}$ to be the \emph{centre} $Z(M)$ of $M$ (recall that the
centre of a monoid is the set of all elements that commute with every
other element). We then set $R_{\tyPrimNm{M}}(m) = \{ (n,mn) \sepbar n
\in M \}$ and $R^\bullet_{\tyPrimNm{M}} = \emptyset$. By setting the
model $\mathcal{M}$ to only be the elements of $M$ that commute with
everything else, we ensure that the following lemma holds:
\begin{lemma}
  For all $\Delta$ and $\rho \in \relEnv{E}_\Mon(\Delta)$,
  $(\eta_\Mon,\eta_\Mon) \in \rsem{\Gamma_\Mon}{\relEnv{E}}\rho$.
\end{lemma}

\newcommand{\mscup}{\stackrel{ms}\cup}

\begin{example}
  By selecting a suitable monoid $M$, we can simulate a programming
  language that dynamically annotates strings with taint markers. Let
  $\Sigma$ be a set of characters from some alphabet, and let $T$ be a
  set of taint markers. Set $M = \Sigma^* \times
  \mathcal{MS}_{\mathit{fin}}(T)$, where $\mathcal{MS}_{\mathit{fin}}$
  denotes the finite power set operator. Since both $\Sigma^*$ and
  $\mathcal{MS}_{\mathit{fin}}(T)$ are monoids (the latter with
  multiset union as the monoid multiplication, which we write as
  $\mscup$), $M$ is itself a monoid. The centre of $M$, $Z(M)$,
  consists of all elements of the form $([], t)$ for multisets of
  taint markers.

  As an example of a free theorem for this instantiation of our
  general framework, consider programs of the following type:
  \begin{displaymath}
    ; \Gamma_\Mon \vdash M : \forall a,b\mathord:\mathsf{M}.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to \tyPrim{M}{aa}
  \end{displaymath}
  From this type we can derive the following free theorem about
  $M$. For all $a, b \in \mathcal{MS}_{\mathit{fin}}(T)$, $(s_1,t_1),
  (s_2,t_2) \in \Sigma^*$,
  \begin{displaymath}
    \begin{array}{l}
      \pi_2(\tmSem{M}\ (s_1,t_1 \mscup a)\ (s_2,t_2 \mscup b)) = \\
      \hspace{2em}\pi_2(\tmSem{M}\ (s_1,t_1)\ (s_2,t_2)) \mscup a \mscup a
    \end{array}
  \end{displaymath}
  We read this result as follows: if we taint the first input by $a$
  and the second by $b$, then the taint of the output varies according
  to $M$'s type. In this case the output contains two copies of $a$
  and none of $b$.
\end{example}

% if $b$ does not appear in the output, then it cannot have been used in
% the program. Turn this into a theorem...

% If forall i1...,in. M<e0> \to ... \to M<em> -> M<e>
% and e0 is not a factor of e, then we can get rid of the first input

% It ought to be invariant under its first input... Set R^\bullet to
% be the everywhere relation....

% prove this by using a relational environment that excludes 

\begin{theorem}
  \begin{equation}
    \label{eq:fo-monoid-type-insensitive}
    ; \Gamma_\Mon \vdash M : \forall i_1,\dots,i_m\mathord:\mathsf{M}.\ \tyPrim{M}{e_1} \to \dots \to \tyPrim{M}{e_n} \to \tyPrim{M}{e}
  \end{equation}
  
\end{theorem}

\begin{theorem}
  \label{thm:monoid-indefinability}
  Let $m$ and $n$ be natural numbers. For all $n$-by-$m$-matricies of
  natural numbers $A$ and $m$-by-$1$ matricies of natural numbers $b$,
  there exists a program $M$ such that
  \begin{displaymath}
    \label{eq:fo-monoid-type}
    ; \Gamma_\Mon \vdash M : \forall i_1,\dots,i_m\mathord:\mathsf{M}.\ \tyPrim{M}{e_1} \to \dots \to \tyPrim{M}{e_n} \to \tyPrim{M}{e}
  \end{displaymath}
  where $e_j = i_1^{A_{j1}}\dots i_m^{A_{jm}}$ and $e =
  i_1^{b_1}\dots i_m^{b_m}$, if and only if there is a solution
  $\vec{x} = (x_1,\cdots,x_n)$ in the natural numbers to the equation
  $A x^\top = b$.
\end{theorem}

\begin{example}
  By \thmref{thm:monoid-indefinability}, it is impossible to write a
  program with the type $\forall m_1,m_2 \mathord: \mathsf{M}.\
  \tyPrim{M}{m_1m_2} \to \tyPrim{M}{m_1}$, showing that it is
  impossible to convert a doubly tainted value to a singly tainted
  one.

  In contrast to the case of abelian group indexed types, the lack of
  inverses in the monoid indexed setting means that the type $\forall
  m_1,m_2\mathord:\mathsf{M}.\ \tyPrim{M}{m_1m_2} \to \tyPrim{M}{m_2}
  \to \tyPrim{M}{m_1}$ is also uninhabited. There are no naturals
  $a_1,a_2$ such that $(m_1m_2)^{a_1}m_2^{a_2} \equiv m_1$.
\end{example}

% \fixme{Finish this} We can further assume that there are other
% operations that distribute over the multiplication of the monoid, for
% example semi-ring operations (e.g.~relational algebra).

\section{Metric Spaces and Simple Continuity Analysis}
\label{sec:continuity-analysis}

Our final motivating example of algebraically indexed types and
representation independence makes use of the metric space structure of
the real numbers. In the geometry example, we used relational
interpretations that related values via geometrical
transformations. An alternative relational interpretation of the real
numbers is to relate values that are close, in the metric space
sense. By indexing types by a measure of closeness, we can actually
state continuity of functions as a typing problem.

We introduce an indexing sort $\mathsf{R}^{>0}$, representing positive
distances between real numbers. Our type of real numbers is indexed by
expressions of sort $\mathsf{R}^{>0}$, and we use the following
index-erasure and relational interpretations:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{real}{e}} & \mathbb{R} \\
    \rsem{\tyPrim{real}{e}}{}\rho & \{ (x,x') \sepbar |x-x'| < \sem{e}\rho \}
  \end{array}
\end{displaymath}
Thus, two real numbers are related if they only differ by the positive
real number assigned to $e$. With this interpretation, and a
straightforward interpretation of existential types, we can state the
standard $\epsilon$-$\delta$ definition of continuity as a type:
\begin{displaymath}
  \forall \epsilon \mathord: \mathsf{R}^{>0}.\ \exists \delta\mathord: \mathsf{R}^{>0}.\ \tyPrim{real}{\delta} \to \tyPrim{real}{\epsilon}
\end{displaymath}
Chaudhuri, Gulwani and Lublinerman \cite{chaudhuri10continuity} have
presented a program logic based approach to verifying the continuity
of programs. Algebraically indexed types give us a way of expressing
and verifying continuity properties of functions in a type based way.

\begin{displaymath}
  \begin{array}{r@{\hspace{0.5em}:\hspace{0.5em}}l}
    \underline{c} & \forall \epsilon\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon} \\
    (+) & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1 + \epsilon_2} \\
    (-) & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1 + \epsilon_2} \\
    (*) & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1\epsilon_2}
  \end{array}
\end{displaymath}

\begin{enumerate}
\item State the operations and equations (rational powers, addition
  and multiplication (remember: positive reals))
\item Derive subtyping by addition of $0$
\item Do the probability monad as a special case, with a specific
  relational interpretation that relates things according to the
  differential privacy notion. Need to think about the
  measure-theoretic problems...
\item Work out the details of the continuity example, especially the
  implementation of an ADT for continuous functions that can handle
  polynomials.
\end{enumerate}

\section{Singleton Types}
\label{sec:singleton-types}

\newcommand{\Sing}{\mathit{Sing}}

Singleton types differ from the ``variation'' types that we have
considered so far because they nail down exactly the underlying value
instead of describing how it varies.

Indexing theory contains all the integers as constants, along with
$+$, $-$ and $*$. Normal arithmetic laws for these
operations. Program-level operations:
\begin{displaymath}
  \begin{array}{@{}c@{\hspace{0.5em}:\hspace{0.5em}}l}
    \underline{z} & \tyPrim{int}{z} \\ % FIXME: only need zero and one
    (+) & \forall z_1,z_2\mathord:\mathsf{integer}.\ \tyPrim{int}{z_1} \to \tyPrim{int}{z_2} \to \tyPrim{int}{z_1 + z_2} \\
    (-) & \forall z_1,z_2\mathord:\mathsf{integer}.\ \tyPrim{int}{z_1} \to \tyPrim{int}{z_2} \to \tyPrim{int}{z_1 - z_2} \\
    (*) & \forall z_1,z_2\mathord:\mathsf{integer}.\ \tyPrim{int}{z_1} \to \tyPrim{int}{z_2} \to \tyPrim{int}{z_1 * z_2}
  \end{array}
\end{displaymath}

\begin{enumerate}
\item Given an algebraic theory, and a model, we can define a
  singleton type system.
\item Need to carefully define this in general, and give the
  appropriate relational environments
\item Give the integers (freely generated monoid) as an example
\end{enumerate}

\begin{theorem}
  There exists a program
  \begin{displaymath}
    -; \Gamma_\Sing \vdash M : \forall i_1,...,i_m\mathord:\mathsf{S}.\ \tyPrim{S}{e_1} \to ... \to \tyPrim{S}{e_n} \to \tyPrim{S}{e}
  \end{displaymath}
  if and only if there exists an index expression
  $i'_1\mathord:\mathsf{S}, ..., i'_n\mathord:\mathsf{S} \vdash e' :
  \mathsf{S}$ such that $(e_1,...,e_n)^*e' \equiv e$.
\end{theorem}

\begin{proof}
  (If) Use the index expression $e'$ to define $M$, replacing each
  index operation with its program-level counterpart.

  (Only if) \fixme{use a special relational environment...}
\end{proof}

% \subsection{Predicate Types}
% \label{sec:predicate-types}

% \begin{enumerate}
% \item Let the indexing theory be predicates on the underlying value
% \item With the laws of boolean algebra
% \item Singleton types are a special case (i.e. with equality to a fixed value)
% \item But also have $\land$, $\lor$, $\lnot$ (and derived $\Rightarrow$)
% \item A pair of things is related if they both satisfy the predicate
%   (and are equal?)
% \item Need a special type for comparisons?
%   \begin{displaymath}
%     (<) : \forall z_1,z_2:\mathsf{integer}.\ \tyPrim{int}{z_1} \to \tyPrim{int}{z_2} \to (\tyPrim{int}{< z_1} \times 
%   \end{displaymath}
% \end{enumerate}

\section{Logical Information Flow}
\label{sec:information-flow}

\begin{enumerate}
\item This is now a special case of the preceeding subsection
\item Also makes use of the relational aspect, the previous stuff
  could make do with unary logical predicates as the interpretations
  of types, but the information flow properties make use of the
  relational interpretation.
\end{enumerate}

\fixme{
  \begin{enumerate}
  \item Make the definition of control of information flow clearer
  \item Make the example a bit more compelling
  \item Put in some examples of composite principals formed from
    boolean logic, and the use of boolean algebra to do reasoning in
    the types. List the laws of boolean algebra, and the laws of
    Heyting algebra. Need to explain the difference between 
  \item Possibly use singleton types to be able to do more interesting
    security policies?
  \item Put in the formal statement of the information flow property
    and the proof.
  \end{enumerate}
}

An extreme example of invariance under change of representation is the
tracking of information flow through programs. If a program does not
depend upon a particular piece of information, then it will be
invariant under \emph{all} changes of representation of this
information. As thoroughly described by Sabelfeld and Sands
\cite{sabelfeld01per}, information flow can be captured semantically
through the use of partial equivalence relations (PERs). Interpreting
types as PERs forms an instance of Reynolds' approach to abstraction
and representation independence. Abadi, Banerjee, Heintze and Riecke
\cite{abadi99core} built a \emph{Core Calculus for Dependency}, using
a type system based around a security level indexed monad $T_lA$. Tse
and Zdancewic \cite{tse04translating} showed that it is possible to
translate Abadi et al.'s calculus into System F, translating the
monadic type $T_lA$ to $\alpha_l \to A$ for some free type variable
$\alpha_l$, and making direct use of Reynolds' abstraction theorem to
prove information flow properties. We now show how a refined variant
of Tse and Zdancewic's translation can be expressed via
algebraically-indexed types.

We assume a single indexing sort $\mathsf{principal}$, intended to
represent (possibly composite) principals in a system. Principals are
combined using the connectives of boolean logic ($\top$, $\bot$,
$\lor$, $\land$, $\lnot$). For the equational theory of principals, we
assume all the axioms of boolean algebra, and semantically we
interpret composite principals as boolean values: either true ($\top$)
or false ($\bot$). We introduce a single primitive type, indexed by
expressions of sort $\mathsf{principal}$, $\tyPrim{T}{e}$, with the
following interpretations:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{T}{e}} & \{*\} \\
    \rsem{\tyPrim{T}{e}}{}\rho & \left\{
      \begin{array}{ll}
        \{(*,*)\} & \textrm{if }\sem{e}\rho = \top \\
        \{\}      & \textrm{if }\sem{e}\rho = \bot
      \end{array}
      \right.
  \end{array}
\end{displaymath}
The relational interpretation of $\tyPrim{T}{e}$ forces this type to
only be inhabited when the boolean expression $e$ evaluates to true
under the environment $\rho$. To write programs, we assume the
following pair of primitive operations:
\begin{eqnarray*}
  \mathrm{proj} & : & \forall p, q\mathord:\mathsf{principal}.\ \tyPrim{T}{p \land q} \to \tyPrim{T}{p} \\
  \mathrm{combine} & : & \forall p, q\mathord:\mathsf{principal}.\ \tyPrim{T}{p} \to \tyPrim{T}{q} \to \tyPrim{T}{p \land q}
\end{eqnarray*}
We can now adapt Tse and Zdancewic's translation of Abadi et al.'s
monadic type to our setting. We define a type synonym, for each type
$A$ and expression $e$ of sort $\mathsf{principal}$:
\begin{displaymath}
  T_eA = \tyPrim{T}{e} \to A
\end{displaymath}
For every principal $e$, we can endow the types $T_e-$ with the
structure of a monad. This is due to the fact that it is an instance
of the ``environment'' (or ``reader'') monad \cite{jones95functional}.

\begin{example}
  Suppose we have a program with the following type:
  \begin{displaymath}
    \forall p,q\mathord:\mathsf{principal}. \tyPrim{T}{e} \to T_p(\tyPrimNm{unit} + \tyPrimNm{unit}) \to T_q(\tyPrimNm{unit} + \tyPrimNm{unit})
  \end{displaymath}
  where $e$ is some boolean algebra expression involving $p$ and
  $q$. We will show in \autoref{sec:instantiations} that programs with
  this type are non-constant (i.e.~depend on their input) if and only
  if the formula $e \Rightarrow q \Rightarrow p$ is valid in boolean
  logic.
\end{example}

\begin{enumerate}
\item Treat the information flow thing as a type isomorphism, in the
  same way that Tse and Zdancewic do
  \begin{displaymath}
    \begin{array}{l}
    \forall \vec{p}\mathord:\mathsf{principal}.\ T_{e_1}\tyPrimNm{bool} \to T_{e_2}\tyPrimNm{bool}\\
    \hspace{4em}\cong \\
    \left\{
      \begin{array}{ll}
        \tyPrimNm{bool} \tyArr \tyPrimNm{bool} & \textrm{if }e_2 \vdash e_1 \\
        \tyPrimNm{bool} & \textrm{if }e_2 \not\vdash e_1
      \end{array}
    \right.
  \end{array}
  \end{displaymath}
  where $\tyPrimNm{bool} = \tyUnit + \tyUnit$.
\item mention the issue with bogus tokens if we allow for a
  call-by-name style of non-termination
\item if we axiomatise intuitionistic logic instead of
  boolean/classical logic, we get a different type isomorphism.
\item The isomorphism relies upon $e_1 \vdash e_2 \Leftrightarrow e_1
  \lor e_2 = e_1$.
\item Relevant logic? Look at the Wikipedia page to see how to do
  residuated (commutative) monoids on lattices with just
  equations. With this, we will be able to do substructural logics
  too. As long as we know that a particular axiomatisation is sound
  and complete for some reasoning system, then we can state and prove
  the non-interference isomorphism above.
\item Compare to Tse and Zdancewic's addition of axioms to the logic.
\item Internalising equality? The logical structure can then be used
  on types as well as everything else. Need the special rules for
  equality... (see the Fomega paper).
\end{enumerate}

% Go a step further by considering equivalence relations on word32, and
% their lattice structure. Link this to quantative information
% flow. Will also need to include singleton types.

\subsection{Abelian Group Indexed Types}
\label{sec:abelian-group-indexed-types}

\newcommand{\Grp}{\mathit{Grp}}

Primitive operations $\Gamma_\Grp$:
\begin{displaymath}
  \begin{array}{r@{\hspace{0.5em}:\hspace{0.5em}}l}
    1 & \tyPrim{G}{1} \\
    (\cdot) & \forall a,b\mathord:\mathsf{G}.\ \tyPrim{G}{a} \to \tyPrim{G}{b} \to \tyPrim{G}{a b} \\
    \ ^{-1} & \forall a\mathord:\mathsf{G}.\ \tyPrim{G}{a} \to \tyPrim{G}{a^{-1}}
  \end{array}
\end{displaymath}

For the index-erasure interpretation, we assume a group $(G, 1, \cdot,
\ ^{-1})$. Let $Z(G)$ be the centre of the $G$: i.e.,~the set of
elements that commute with every other element in $G$. We set
$\tyPrimSem{G} = G$. The primitive operations in $\Gamma_\Grp$ are
interpreted just as the unit, multiplication and inverse operations
of $G$. For each index context $\Delta$, the set
$\relEnv{E}_\Grp(\Delta)$ of relational environments is defined to be
$\{ \rho_{(H,h)} \sepbar H\textrm{ is a subgroup of }(\Delta
\Rightarrow \mathsf{G})/\equiv, h\textrm{ is a group homomorphism }H
\to Z(G) \}$, where
\begin{displaymath}
  \rho_{(H,h)}\ \tyPrimNm{G}\ (e) = \left\{
    \begin{array}{ll}
      \{ \} & \textrm{if}\ e\not\in H \\
      \{ (x, h(e)\cdot x) \sepbar x \in G \} & \textrm{if}\ e\in H
    \end{array}
  \right.
\end{displaymath}

\begin{lemma}
  For all $\Delta$ and $\rho \in \relEnv{E}_\Grp(\Delta)$,
  $(\eta_\Grp,\eta_\Grp) \in \rsem{\Gamma_\Grp}{\relEnv{E}}\rho$.
\end{lemma}

\begin{theorem}
  Let $m$ and $n$ be natural numbers. For all $n$-by-$m$-matricies of
  natural numbers $A$ and $m$-by-$1$ matricies of integers $b$,
  there exists a program $M$ such that
  \begin{equation}
    \label{eq:fo-group-type}
    \Gamma_\Grp \vdash M : \forall i_1,\dots,i_m\mathord:\mathsf{G}.\ \tyPrim{G}{e_1} \to \dots \to \tyPrim{G}{e_n} \to \tyPrim{G}{e}
  \end{equation}
  where $e_j = i_1^{A_{j1}}\dots i_m^{A_{jm}}$ and $e = i_1^{b_1}\dots
  i_m^{b_m}$, if and only if there is a solution $\vec{x} =
  (x_1,\cdots,x_n)$ in the integers to the equation $A x^\top = b$.
\end{theorem}

\fixme{Define shorthand notation $x^z$}

\begin{proof}
  (If) The program $\Lambda i_1\dots i_m.\ \lambda g_1\dots g_n.\
  g_1^{x_1}\dots g_n^{x_n}$ satisfies the typing judgment
  (\ref{eq:fo-group-type}).

  (Only if) Assume that there is a program $M$ satisfying the typing
  judgment (\ref{eq:fo-group-type}). By \thmref{thm:abstraction} we
  know that for all relational environments $\rho \in
  \relEnv{E}_\Grp(i_1,\dots,i_m)$, and all $g_j,g'_j \in G$,
  \begin{displaymath}
    \begin{array}{l}
      (g_1,g'_1) \in \rho\ \tyPrimNm{G}\ (e_1) \land \dots \land (g_n,g'_n) \in \rho\ \tyPrimNm{G}\ (e_n) \Rightarrow \\
      \quad (\tmSem{M}g_1\dots g_n, \tmSem{M}g'_1\dots g'_n) \in \rho\ \tyPrimNm{G}\ (e)
    \end{array}
  \end{displaymath}
  We select the relational environments
  \begin{displaymath}
    \rho\ \tyPrimNm{G}\ (e) = \left\{
      \begin{array}{ll}
        \{(g,g) \sepbar g \in \mathcal{G} \} &
        \begin{array}[t]{@{}l}
          \textrm{if}\ e = e_1^{x_1}\dots e_n^{x_n} \\
          \textrm{ for some }x_1,\dots,x_n \in \mathbb{Z}
        \end{array}
        \\
        \{\} & \textrm{otherwise}
      \end{array}
    \right.
  \end{displaymath}
  Now, for any $g_1,\dots,g_m \in \mathcal{G}$, we know that, for all
  $j$, $(g_j,g_j) \in \rho\ \tyPrimNm{G}\ (e_j)$, so we know that
  $(\tySem{M}g_1\dots g_n, \tySem{M}g_1 \dots g_n) \in \rho\
  \tyPrimNm{G}\ (e)$. Thus there exist integers $x_1,...,x_n$ such
  that $e = e_1^{x_1}\dots e_n^{x_n}$. But we also know that $e =
  i_1^{b_1}...i_m^{b_m}$. By the cancellation property of free groups,
  we learn that $x_1,...,x_n$ is the solution we need.
\end{proof}

\begin{enumerate}
\item Can add any other operations that distribute over the group
  multiplication.
\item What about partial division operations? Make division just
  return $0$.
\item Adding square root as an operation. Need to check that all the
  other operations preserve the new relational environments. Square
  root is also supported by the plain relational environments, so the
  type isomorphism result still holds.
\end{enumerate}



\subsubsection{Type isomorphisms}
\label{sec:abelian-group-type-isos}

\begin{enumerate}
\item This only needs the simpler relational environments, but needs
  the group used for the index-erasure semantics to be abelian.
\item One direction is easy, but the other requires the use of the
  free theorem for the type.
\item There are two version: one with some fixed ground type as the
  result, and one with the same type as the result, but with the same
  parameter.
\item Integrates into the Smith Normal Form thing too, since
  invertible integer-valued matrices can be turned into type
  isomorphisms.
\item Partiality?
\end{enumerate}

\fixme{Define what a type isomorphism is}

\begin{theorem}
  For all natural numbers $n$, the types
  \begin{displaymath}
    \tau_{n} \isDefinedAs \forall a\mathord:\mathsf{G}.\ \underbrace{\tyPrim{G}{a} \to ... \to \tyPrim{G}{a}}_{n+1\textrm{ times}} \to \tyPrim{G}{a}
  \end{displaymath}
  and
  \begin{displaymath}
    \sigma_{n} \isDefinedAs \underbrace{\tyPrim{G}{1} \to ... \tyPrim{G}{1}}_{n\textrm{ times}} \to \tyPrim{G}{1}
  \end{displaymath}
  are isomorphic.
\end{theorem}

\begin{proof}
  We define programs $\Gamma_\Grp \vdash M : \tau_n \to \sigma_n$ and
  $\Gamma_\Grp \vdash M^{-1} : \sigma_n \to \tau_n$ as follows:
  \begin{displaymath}
    M = \lambda f. \lambda g_1 \dots g_n.\ f\ [1]\ 1\ g_1\ \dots\ g_n
  \end{displaymath}
  and
  \begin{displaymath}
    M^{-1} = \lambda f. \Lambda a.\ \lambda g_0 \dots g_n.\ (f\ (g_1 g^{-1}_0)\ \dots\ (g_n g^{-1}_0)) g_0
  \end{displaymath}
  In one direction, the proof that these are mutually inverse is
  straightfoward, using only the fact that $G$ is a group. For any
  program $\Gamma_\Grp \vdash f : \sigma_n$, we have
  \begin{displaymath}
    \begin{array}{cl}
        & \tmSem{M\ (M^{-1}\ f)}\eta_\Grp \\
      = & (\tmSem{M}\eta_{\Grp})\ (\lambda g_0 \dots g_n.\ (\tmSem{f}\eta_\Grp\ (g_1 g^{-1}_0)\ \dots\ (g_n g^{-1}_0)) g_0) \\
      = & \lambda g_1\dots g_n.\ \tmSem{f}\eta_\Grp\ (g_1 1^{-1})\ \dots\ (g_n 1^{-1})) 1) \\
      = & \lambda g_1\dots g_n.\ \tmSem{f}\eta_\Grp\ g_1\ \dots\ g_n \\
      = & \tmSem{f}\eta_\Grp
    \end{array}
  \end{displaymath}
  as required. In the other direction, we need to use the abstraction
  theorem. For any program $\Gamma_\Grp \vdash f : \tau_n$, we have
  \begin{displaymath}
    \begin{array}{cl}
        & \tmSem{M^{-1}\ (M\ f)}\eta_\Grp \\
      = & (\tmSem{M^{-1}}\eta_\Grp)\ (\lambda g_1\dots g_n.\ (\tmSem{f}\eta_\Grp\ 1\ g_1\ \dots\ g_n)) \\
      = & \lambda g_0\dots g_n.\ (\tmSem{f}\eta_\Grp\ 1\ (g_1g^{-1}_0)\ \dots\ (g_ng^{-1}_0))g_0
    \end{array}
  \end{displaymath}
  By \thmref{thm:abstraction}, we know that the following holds of
  $\tmSem{f}$:
  \begin{displaymath}
    \forall a.\ \forall g_0 \dots g_n.\ \tmSem{f}\eta_\Grp\ (g_0a)\ \dots\ (g_na) = (\tmSem{f}\eta_\Grp\ g_0\ \dots\ g_n)a
  \end{displaymath}
  As a special case, we set $a = g^{-1}_0$, and learn that
  \begin{displaymath}
    \forall g_0 \dots g_n.\ \tmSem{f}\eta_\Grp\ 1\ (g_1g^{-1}_0) \dots\ (g_ng^{-1}_0) = (\tmSem{f}\eta_\Grp\ g_0\ \dots\ g_n)g^{-1}_0.
  \end{displaymath}
  By functional extensionality, we are done.
\end{proof}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
