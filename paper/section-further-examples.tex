\section{Further Examples}
\label{sec:further-examples}

\subsection{Logical Information Flow}
\label{sec:information-flow}

An extreme example of invariance under change of representation is the
tracking of information flow through programs. If a program does not
depend upon a particular piece of information, then it will be
invariant under \emph{all} changes of representation of this
information. As thoroughly described by Sabelfeld and Sands
\cite{sabelfeld01per}, information flow can be captured semantically
through the use of partial equivalence relations (PERs). PERs form an
instance of Reynolds' approach to abstraction and representation
independence. Abadi, Banerjee, Heintze and Riecke \cite{abadi99core}
built a \emph{Core Calculus for Dependency}, using a type system based
around a security level indexed monad $T_lA$. Tse and Zdancewic
\cite{tse04translating} showed that it is possible to translate Abadi
et al.'s calculus into System F, translating the monadic type $T_lA$
to $\alpha_l \to A$ for some free type variable $\alpha_l$, and making
direct use of Reynolds' abstraction theorem to prove information flow
properties. We now show how a refined variant of Tse and Zdancewic's
translation can be expressed via algebraically-indexed types.

We assume a single indexing sort $\mathsf{principal}$, intended to
represent (possibly composite) principals in a system. Principals are
combined using the connectives of boolean logic ($\top$, $\bot$,
$\lor$, $\land$, $\lnot$). For the equational theory of principals, we
assume all the axioms of boolean algebra, and semantically we
interpret composite principals as boolean values: either true ($\top$)
or false ($\bot$). We introduce a single primitive type, indexed by
expressions of sort $\mathsf{principal}$, $\tyPrim{T}{e}$, with the
following interpretations:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{T}{e}} & \{*\} \\
    \rsem{\tyPrim{T}{e}}{}\rho & \left\{
      \begin{array}{ll}
        \{(*,*)\} & \textrm{if }\sem{e}\rho = \top \\
        \{\}      & \textrm{if }\sem{e}\rho = \bot
      \end{array}
      \right.
  \end{array}
\end{displaymath}
The relational interpretation of $\tyPrim{T}{e}$ forces this type to
only be inhabited when the boolean expression $e$ evaluates to true
under the environment $\rho$. To write programs, we assume the
following pair of primitive operations:
\begin{eqnarray*}
  \mathrm{proj} & : & \forall p, q\mathord:\mathsf{principal}.\ \tyPrim{T}{p \land q} \to \tyPrim{T}{p} \\
  \mathrm{combine} & : & \forall p, q\mathord:\mathsf{principal}.\ \tyPrim{T}{p} \to \tyPrim{T}{q} \to \tyPrim{T}{p \land q}
\end{eqnarray*}
We can now adapt Tse and Zdancewic's translation of Abadi et al.'s
monadic type to our setting. We define a type synonym, for each type
$A$ and expression $e$ of sort $\mathsf{principal}$:
\begin{displaymath}
  T_eA = \tyPrim{T}{e} \to A
\end{displaymath}
For every principal $e$, we can endow the types $T_e-$ with the
structure of a monad. This is due to the fact that it is an instance
of the ``environment'' (or ``reader'') monad \cite{jones95functional}.

\begin{example}
  Suppose we have a program with the following type:
  \begin{displaymath}
    \forall p,q\mathord:\mathsf{principal}. \tyPrim{T}{e} \to T_p(\tyPrimNm{unit} + \tyPrimNm{unit}) \to T_q(\tyPrimNm{unit} + \tyPrimNm{unit})
  \end{displaymath}
  where $e$ is some boolean algebra expression involving $p$ and
  $q$. We will show in \autoref{sec:instantiations} that programs with
  this type are non-constant (i.e.~depend on their input) if and only
  if the formula $e \Rightarrow q \Rightarrow p$ is valid in boolean
  logic.
\end{example}


% Go a step further by considering equivalence relations on word32, and
% their lattice structure. Link this to quantative information
% flow. Will also need to include singleton types.

\subsection{Metric Spaces and Simple Continuity Analysis}
\label{sec:continuity-analysis}

Our final motivating example of algebraically indexed types and
representation independence makes use of the metric space structure of
the real numbers. In the geometry example, we used relational
interpretations that related values via geometrical
transformations. An alternative relational interpretation of the real
numbers is to relate values that are close, in the metric space
sense. By indexing types by a measure of closeness, we can actually
state continuity of functions as a typing problem.

We introduce an indexing sort $\mathsf{R}^{>0}$, representing positive
distances between real numbers. Our type of real numbers is indexed by
expressions of sort $\mathsf{R}^{>0}$, and we use the following
index-erasure and relational interpretations:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.5em}=\hspace{0.5em}}l}
    \tySem{\tyPrim{real}{e}} & \mathbb{R} \\
    \rsem{\tyPrim{real}{e}}{}\rho & \{ (x,x') \sepbar |x-x'| < \sem{e}\rho \}
  \end{array}
\end{displaymath}
Thus, two real numbers are related if they only differ by the positive
real number assigned to $e$. With this interpretation, and a
straightforward interpretation of existential types, we can state the
standard $\epsilon$-$\delta$ definition of continuity as a type:
\begin{displaymath}
  \forall \epsilon \mathord: \mathsf{R}^{>0}.\ \exists \delta\mathord: \mathsf{R}^{>0}.\ \tyPrim{real}{\delta} \to \tyPrim{real}{\epsilon}
\end{displaymath}
Chaudhuri, Gulwani and Lublinerman \cite{chaudhuri10continuity} have
presented a program logic based approach to verifying the continuity
of programs. Algebraically indexed types give us a way of expressing
and verifying continuity properties of functions in a type based way.

% \begin{eqnarray*}
%   \underline{c} & : & \forall \epsilon\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon} \\
%   (+) & : & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1 + \epsilon_2} \\
%   (-) & : & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1 + \epsilon_2} \\
%   (*) & : & \forall \epsilon_1, \epsilon_2\mathord:\mathsf{R}^{>0}.\ \tyPrim{real}{\epsilon_1} \to \tyPrim{real}{\epsilon_2} \to \tyPrim{real}{\epsilon_1\epsilon_2}
% \end{eqnarray*}

\subsection{Monoid Indexed Types}
\label{sec:monoid-indexed-types}

Primitive type is a monoid, and we index by a commutative monoid. An
example of this is strings with tainting information, or bags, or sets
of stuff. This gives a slightly different information flow analysis to
the logical information flow above. In particular, we can now count
uses of input data.

Primitive operations $\Gamma_{\mathit{Mon}}$:
\begin{displaymath}
  \begin{array}{c@{\hspace{0.5em}:\hspace{0.5em}}l}
    1 & \tyPrim{M}{1} \\
    (\cdot) & \forall a,b.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to \tyPrim{M}{a\cdot b}
  \end{array}
\end{displaymath}

For the index-erasure interpretation, we assume a commutative monoid
$\mathcal{M}$. The primitive type $\tyPrimNm{M}$ is interpreted as
$\tySem{\tyPrim{M}{e}} = \mathcal{M}$. The primitive operations in
$\Gamma_{\mathit{Mon}}$ are interpreted just as the unit and multiplication of
the monoid $\mathcal{M}$.


% Need the following definitions: syntatic group/monoid arising from
% the syntax, and a neater way of defining relational
% environments. Also, a neat way of formally introducing a load of
% primitive operations.

For each index context $\relEnv{E}(\Delta)$, the set
$\relEnv{E}(\Delta)$ of relational environments is defined to be $\{
\rho_{(M,h)} \sepbar M\textrm{ is a submonoid of }(\Delta \Rightarrow
\mathsf{M})/\equiv, h\textrm{ is a monoid homomorphism }M \to
Z(\mathcal{M}) \}$, where
\begin{displaymath}
  \rho_{(M,h)}\ \tyPrimNm{M}\ (e) = \left\{
    \begin{array}{ll}
      \{ \} & \textrm{if}\ e\not\in M \\
      \{ (x, h(e)\cdot x) \sepbar x \in \mathcal{M} \} & \textrm{if}\ e\in M
    \end{array}
  \right.
\end{displaymath}
Note the mapping to the centre of the monoid $\mathcal{M}$.

\begin{lemma}
  For all $\Delta$ and $\rho \in \relEnv{E}(\Delta)$,
  $(\eta_{M},\eta_{M}) \in \rsem{\Gamma_{\mathit{Mon}}}{\relEnv{E}}\rho$.
\end{lemma}

\begin{theorem}
  Let $m$ and $n$ be natural numbers. For all $n$-by-$m$-matricies of
  natural numbers $A$ and $m$-by-$1$ matricies of natural numbers $b$,
  there exists a program $M$ such that
  \begin{equation}
    \label{eq:fo-monoid-type}
    \Gamma_{\mathit{Mon}} \vdash M : \forall i_1,\dots,i_m\mathord:\mathsf{M}.\ \tyPrim{M}{e_1} \to \dots \to \tyPrim{M}{e_n} \to \tyPrim{M}{e}
  \end{equation}
  where $e_j = i_1^{A_{j1}}\dots i_m^{A_{jm}}$ and $e =
  i_1^{b_1}\dots i_m^{b_m}$, if and only if there is a solution
  $\vec{x} = (x_1,\cdots,x_n)$ in the natural numbers to the equation
  $A x^\top = b$.
\end{theorem}

\begin{proof}
  (If) The program $\Lambda i_1\dots i_m.\ \lambda z_1\dots z_n.\
  z_1^{x_1}\dots z_n^{x_n}$ satisfies the typing judgment
  (\ref{eq:fo-monoid-type}).

  (Only if) Assume that there is a program $M$ satisfying the typing
  judgment (\ref{eq:fo-monoid-type}). By \thmref{thm:abstraction} we
  know that for all relational environments $\rho \in
  \relEnv{E}(i_1,\dots,i_m)$, and all $z_j,z'_j \in \mathcal{M}$,
  \begin{displaymath}
    \begin{array}{l}
      (z_1,z'_1) \in \rho\ \tyPrimNm{M}\ (e_1) \land \dots \land (z_n,z'_n) \in \rho\ \tyPrimNm{M}\ (e_n) \Rightarrow \\
      \quad (\tmSem{M}z_1\dots z_n, \tmSem{M}z'_1\dots z'_n) \in \rho\ \tyPrimNm{M}\ (e)
    \end{array}
  \end{displaymath}
  We select the relational environments
  \begin{displaymath}
    \rho\ \tyPrimNm{M}\ (e) = \left\{
      \begin{array}{ll}
        \{(z,z) \sepbar z \in \mathcal{M} \} &
        \begin{array}[t]{@{}l}
          \textrm{if}\ e = e_1^{x_1}\dots e_n^{x_n} \\
          \textrm{ for some }x_1,\dots,x_n \in \mathbb{N}
        \end{array}
        \\
        \{\} & \textrm{otherwise}
      \end{array}
    \right.
  \end{displaymath}
  Now, for any $z_1,\dots,z_m \in \mathcal{M}$, we know that, for all
  $j$, $(z_j,z_j) \in \rho\ \tyPrimNm{M}\ (e_j)$, so we know that
  $(\tySem{M}z_1\dots z_n, \tySem{M}z_1 \dots z_n) \in \rho\
  \tyPrimNm{M}\ (e)$. Thus there exist $x_1,...,x_n$ such that $e =
  e_1^{x_1}\dots e_n^{x_n}$. But we also know that $e =
  i_1^{b_1}...i_m^{b_m}$. By the cancellation property of free
  monoids, we learn that $x_1,...,x_n$ is the solution we need.
\end{proof}

We can further assume that there are other operations that distribute
over the multiplication of the monoid, for example semi-ring
operations (e.g.~relational algebra).

Examples
\begin{enumerate}
\item Finite sets of stuff.
\item Let $\mathcal{M} = \Sigma^* \times
  \mathcal{P}_{\mathit{fin}}(C)$, where $\Sigma$ is some alphabet, and
  $C$ is some set of taint markers. The centre of this monoid is
  $\{([], c) \sepbar c \in \mathcal{P}_{\mathit{fin}}(C) \}$.
\end{enumerate}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
