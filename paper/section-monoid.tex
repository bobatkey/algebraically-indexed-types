\section{Monoid Indexed Types}
\label{sec:monoid-indexed-types}

\newcommand{\Mon}{\textit{Mon}}

Above we investigated types indexed by abelian group expressions,
whose elements are taken from some group. We now switch from abelian
groups to commutative monoids.  Our main example is strings indexed by
``taint'' markers: when strings are appended their taint markers are
combined. Thanks to the information in the indices, we are able to
prove an indefinability result (\thmref{thm:monoid-indefinability}).

For this, we assume a single sort $\mathsf{M}$, with the monoid operations of
unit and multiplication and the commutative monoid axioms, and a % There is a
single primitive type $\tyPrimNm{M}$ with $\primTyArity(\tyPrimNm{M})
= [\mathsf{M}]$. For the index-erasure semantics, we assume some (not
necessarily commutative) monoid $M$, which we 
also write
multiplicatively. The collection of primitive operations
$\Gamma_{\mathit{Mon}}$ %is simply 
has the two monoid operations
%\begin{displaymath}
 % \begin{array}{r@{\hspace{0.5em}:\hspace{0.5em}}l@{\hspace{2em}}r@{\hspace{0.5em}:\hspace{0.5em}}l}
%    1 & \tyPrim{M}{1}, &
%    (\cdot) & \forall a,b\mathord:\mathsf{M}.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to \tyPrim{M}{a b}
%  \end{array}
%\end{displaymath}
$1 : \tyPrim{M}{1}$ and $(\cdot) : \forall
a,b\mathord:\mathsf{M}.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to
\tyPrim{M}{a b}$, which we interpret using the monoid structure of
$M$, giving an environment $\eta_\Mon \in \ctxtSem{\Gamma_\Mon}$.

For the relational environments, we use %make use of 
the compositional
construction in \autoref{sec:constr-rel-env}, setting the chosen model
$\mathcal{M}$ to be the centre $Z(M)$ of $M$. % (recall that the
%centre of a monoid is the set of all elements that commute with every
%other element). 
Setting $R_{\tyPrimNm{M}}(m) = \{ (n,mn) \sepbar n
\in M \}$
%By setting the model $\mathcal{M}$ to be only the elements of $M$ that
%commute with everything else, we ensure that the following lemma
%holds:
gives:
\begin{lemma}\label{lem:monoid-ops-related}
  For all $\Delta$ and $\rho \in \relEnv{E}_\Mon(\Delta)$,
  $(\eta_\Mon,\eta_\Mon) \in \rsem{\Gamma_\Mon}{\relEnv{E}}\rho$.
\end{lemma}

By selecting a suitable monoid $M$, we can simulate a programming
language that annotates strings with taint markers. Let $\Sigma$ be a
set of characters from some alphabet, and let $T$ be a set of taint
markers. Set $M = \Sigma^* \times \mathcal{MS}_{\mathit{fin}}(T)$,
where $\mathcal{MS}_{\mathit{fin}}$ denotes the finite power set
operator. Since both $\Sigma^*$ and $\mathcal{MS}_{\mathit{fin}}(T)$
are monoids (the latter with multiset union as the monoid
multiplication, which we write as $\uplus$), $M$ is itself a
monoid. The centre $Z(M)$ of $M$, consists of all elements of the form
$([], t)$.

As an example of a free theorem for this instantiation of our general
framework, consider programs of the following type:
\begin{displaymath}
  ; \Gamma_\Mon \vdash N : \forall a,b\mathord:\mathsf{M}.\ \tyPrim{M}{a} \to \tyPrim{M}{b} \to \tyPrim{M}{aa}
\end{displaymath}
From this type we can derive the following free theorem about $N$. For
all $a, b \in \mathcal{MS}_{\mathit{fin}}(T)$, $(s_1,t_1), (s_2,t_2)
\in \Sigma^*$,
\begin{displaymath}
  \begin{array}{l}
    \pi_2(\tmSem{N}\ (s_1,t_1 \uplus a)\ (s_2,t_2 \uplus b)) = \\
    \hspace{2em}\pi_2(\tmSem{N}\ (s_1,t_1)\ (s_2,t_2)) \uplus a \uplus a
  \end{array}
\end{displaymath}
If we taint the first input by $a$ and the second by $b$, then two
copies of the taint $a$ will flow to the output, and none of taint
$b$.

% if $b$ does not appear in the output, then it cannot have been used in
% the program. Turn this into a theorem...

% If forall i1...,in. M<e0> \to ... \to M<em> -> M<e>
% and e0 is not a factor of e, then we can get rid of the first input

% It ought to be invariant under its first input... Set R^\bullet to
% be the everywhere relation....

% prove this by using a relational environment that excludes 

% \begin{theorem}
%   \begin{equation}
%     \label{eq:fo-monoid-type-insensitive}
%     ; \Gamma_\Mon \vdash M : \forall i_1,\dots,i_m\mathord:\mathsf{M}.\ \tyPrim{M}{e_1} \to \dots \to \tyPrim{M}{e_n} \to \tyPrim{M}{e}
%   \end{equation}
%   If all solutions to the matrix equation below have a row of zeros at
%   position $i$, then $\tmSem{M}$ is insensitive to 
% \end{theorem}

% as long as $e_1$ is not derivable from the other indexes, and the
% output one is, then the program is insensitive to its first argument:
% if $e_1 \not\in \Free(\{e_2,...,e_n\})$ and $e \in
% \Free(\{e_2,...,e_n\})$, then $M$ is insensitive to its first
% argument.

% \begin{proof}
%   Use the relational environment generated by the set $\{e_2, ...,
%   e_n\}$. Then the relational interpretation of the first argument's
%   type will be the total relation, and the remainder will be in the
%   identity relation. So for all $x_1,x_1' \in M$, and $x_2,...,x_n \in
%   M$ we have $\tmSem{M}\eta_\Mon\ x_1\ x_2...x_n = \tmSem{M}\eta_\Mon\
%   x'_1\ x_2...x_n$.
% \end{proof}

% Doesn't apply if we have:
% \begin{displaymath}
%   \forall a,b.\ \tyPrim{M}{a} \to \tyPrim{M}{a} \to \tyPrim{M}{b}
% \end{displaymath}
% but it ought to work... probably ought to state it in terms of minimal
% set of generators of the input: if there is a set of $e_i$ that
% generates the result type's index, then each of the inputs that it
% doesn't generate are not used by the function. Need the restrict to
% ones it doesn't generate because of the following:
% \begin{displaymath}
%   \forall a.\ \tyPrim{M}{a} \to \tyPrim{M}{a} \to \tyPrim{M}{a}
% \end{displaymath}
% we don't know which of the inputs will be used...

% Problem: what about
% \begin{displaymath}
%   \forall a.\ \tyPrim{M}{a} \to \tyPrim{M}{a^2} \to \tyPrim{M}{a^2}
% \end{displaymath}
% The set $\{a^2\}$ generates the output, and doesn't generate $a$, but
% a program of this type could easily use either of the inputs... 

% Relational environment is:
% \begin{displaymath}
%   \rho\ \tyPrimNm{M}\ (e) = \left\{
%     \begin{array}{ll}
%       \id_M & \textrm{if }e = a^2 \\
%       M \times M & \textrm{otherwise}
%     \end{array}
%   \right.
% \end{displaymath}

% In general, we are just setting $R^\bullet_{\tyPrimNm{M}} = M \times
% M$. However, this is not supported by the monoid multiplication
% operation: if the two inputs are not in generated set, the output
% still might be, and is expected to be equal... So we need some notion
% of \emph{not} being generated by the set... free structures that avoid
% some argument?

% If we restrict to just variables, then we might be OK... otherwise,
% I'm stuck.

% The multiplication operation does not satisfy this spec. The
% generating set needs to be closed under decomposition....



% so we need to say that, somehow, the redundant arguments' indexes
% never contribute anything to the result type's index.

% Maybe: if an $e_i$ is not present in any of the minimal sets of
% generators that produces the output type, then it is redundant.

% Let $S = \{ G \subseteq \{e_1,...,e_n\} \sepbar e \in \Free(G) \}$.

% $S' = $ minimal elements of $S$: all the elements of $S$ that do not
% have anything beneath them in the subset ordering. Then if some $e_j$
% is not present in any of these, 

\begin{theorem}
  \label{thm:monoid-indefinability}
  Let $m$ and $n$ be natural numbers. For all $n$-by-$m$-matricies of
  natural numbers $A$ and $m$-by-$1$ matricies of natural numbers $b$,
  there exists an $M$ in the quantifier-free fragment, with
  \begin{displaymath}
    i_1,\dots,i_m\mathord:\mathsf{M}; \Gamma_\Mon \vdash M : \tyPrim{M}{e_1} \to \dots \to \tyPrim{M}{e_n} \to \tyPrim{M}{e}
  \end{displaymath}
  where $e_j = i_1^{A_{j1}}\dots i_m^{A_{jm}}$ and $e = i_1^{b_1}\dots
  i_m^{b_m}$ iff there is a solution $\vec{x} = (x_1,...,x_n)$ in the
  natural numbers to $A x^\top = b$.
\end{theorem}

The proof of this theorem uses the non-compositional relational
environments from \autoref{sec:constr-rel-env}, with
$R^\bullet_{\tyPrimNm{M}} = \emptyset$. From the theorem we can see
that it is impossible to write a program with the type
$\tyPrim{M}{ab} \to \tyPrim{M}{a}$, and is thus impossible to
convert a doubly tainted value to a singly tainted one.
%
By contrast with abelian group indexed types, the lack of inverses in
the monoid indexed setting means that the type $\tyPrim{M}{ab} \to
\tyPrim{M}{b} \to \tyPrim{M}{a}$ is also uninhabited since there are
no naturals $x_1,x_2$ such that $(ab)^{x_1}b^{x_2} \equiv a$.

% \fixme{Finish this} We can further assume that there are other
% operations that distribute over the multiplication of the monoid, for
% example semi-ring operations (e.g.~relational algebra).

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
