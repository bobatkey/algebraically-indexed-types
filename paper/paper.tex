\documentclass[natbib,preprint]{sigplanconf}

\usepackage[usenames]{color}
\definecolor{citationcolour}{rgb}{0,0.4,0.2}
\definecolor{linkcolour}{rgb}{0,0,0.8}
\usepackage{hyperref}
\hypersetup{colorlinks=true,
            urlcolor=linkcolour,
            linkcolor=linkcolour,
            citecolor=citationcolour,
            pdftitle=Relational Parametricity for Algebraically-Indexed Types,
            pdfauthor={Robert Atkey, Patricia Johann, Neil Ghani},
            pdfkeywords={}}  
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}

\title{Relational Parametricity for Algebraically Indexed Types}

\authorinfo{Robert Atkey\and Patricia Johann\and Neil Ghani}
           {University of Strathclyde}
           {\{Robert.Atkey,Patricia.Johann,Neil.Ghani\}@cis.strath.ac.uk}

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}

\newcommand{\sepbar}{\mathrel|}

\newcommand{\Rel}{\mathrm{Rel}}
\newcommand{\relArrow}{\mathrel{\widehat\to}}
\newcommand{\relTimes}{\mathrel{\widehat\times}}
\newcommand{\relSum}{\mathrel{\widehat+}}

\newcommand{\setOfIntegers}{\mathbb{Z}}
\newcommand{\setOfBooleans}{\{\tmTT, \tmFF\}}

\newcommand{\id}{\mathrm{id}}

\newcommand{\indexOp}[1]{\texttt{#1}}
\newcommand{\idxTms}[2]{\mathrm{IdxTm}(#1 \vdash #2)}
\newcommand{\idxTmAS}[1]{\mathrm{IdxTm}(#1)}

\newcommand{\sortType}{\texttt{type}}
\newcommand{\tyInt}{\texttt{int}}
\newcommand{\tyBool}{\texttt{bool}}
\newcommand{\tyUnit}{\texttt{unit}}
\newcommand{\tyPrim}[2]{\texttt{#1}\langle #2 \rangle}
\newcommand{\tyPrimNm}[1]{\texttt{#1}}

\newcommand{\tyArr}{\to}
\newcommand{\tyProduct}{\times}
\newcommand{\tyX}[1]{\texttt{X}\langle #1 \rangle}
\newcommand{\isType}{\textsf{ type}}
\newcommand{\isCtxt}{\textsf{ ctxt}}
\newcommand{\Ty}{\textsf{Ty}}
\newcommand{\ty}{\textsf{ty}}
\newcommand{\subst}[2]{\mathrm{Subst}(#1,#2)}

\newcommand{\tmTT}{\texttt{tt}}
\newcommand{\tmFF}{\texttt{ff}}

\newcommand{\relEnv}[1]{\mathcal{#1}}
\newcommand{\tySem}[1]{\llbracket #1 \rrbracket^{\mathcal{T}}}
\newcommand{\ctxtSem}[1]{\llbracket #1 \rrbracket^{\mathcal{C}}}
\newcommand{\tmSem}[1]{\llbracket #1 \rrbracket^{\mathit{tm}}}
\newcommand{\tyPrimSem}[1]{\llbracket \tyPrimNm{#1} \rrbracket^{\mathcal{T}_0}}
\newcommand{\rsem}[3]{\llbracket #1 \rrbracket^{\mathcal{R}}_{#2}{#3}}
\newcommand{\extends}[2]{\mathsf{ext}(#1,#2)}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newcommand{\lemref}[1]{\hyperref[#1]{Lemma \ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem \ref*{#1}}}
\newcommand{\propref}[1]{\hyperref[#1]{Proposition \ref*{#1}}}
\newcommand{\corref}[1]{\hyperref[#1]{Corollary \ref*{#1}}}
\newcommand{\conref}[1]{\hyperref[#1]{Conjecture \ref*{#1}}}
\newcommand{\exref}[1]{\hyperref[#1]{Example \ref*{#1}}}

\begin{document}

\maketitle

\begin{abstract}
  
\end{abstract}

\category{D.1.1}{Programming techniques}{Applicative (functional)
  programming} \category{D.2.4}{Software Engineering}{Software/Program
  Verification} \category{D.3.3}{Programming Languages}{Language
  Constructs and Features---Data types and structures}

\terms
  Languages, Theory, Types

\keywords
  parametricity, dimension types, computational geometry

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

\begin{enumerate}
\item Introduction using the area-of-a-triangle example
\item Narrowing of the semantic gap by use of advanced type systems
\item Importance of the use of symmetry in computer science,
  mathematics and the physical sciences
\item Development of the theory of parametricity
\end{enumerate}

\subsection{Contributions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Background and Related Work}

Reynolds (Parametricity), Wadler (Free Theorems).

Kennedy (Units of Measure)

Something about symmetry?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type System}

We now introduce our type system. We parameterise our development by
an arbitrary multi-sorted algebraic theory, in the sense of universal
algebra. We present the precise form of the theories we allow in
\autoref{sec:index-exp}, and define some auxiliary notions of
substitution and terms-up-to-equality. Several examples of useful
algebraic theories will be given in
\autoref{sec:example-systems}. Once an algebraic theory has been
fixed, we define the well-formed types and terms with respect to this
theory in \autoref{sec:types-and-terms}. 

\subsection{Algebraic Theories for Indexing}\label{sec:index-exp}

\begin{figure*}[t]
  \centering
  Well-sorted terms
  \begin{mathpar}
    \inferrule*
    {i : s \in \Delta}
    {\Delta \vdash x : s}
    
    \inferrule*
    {\indexOp{f} : s_1,...,s_n \to s \\
      \Delta \vdash e_1 : s_1 \\
      \dots \\
      \Delta \vdash e_n : s_n}
    {\Delta \vdash \indexOp{f}(e_1, ..., e_n) : s}
  \end{mathpar}

  \medskip

  Equational rules
  \begin{mathpar}
    \inferrule*
    {e_1 \stackrel{ax}= e_2 : s \in \mathit{Ax}(\Delta)}
    {\Delta \vdash e_1 \equiv e_2 : s}

    \inferrule*
    {\indexOp{f} : s_1,...,s_n \to s \\
      \Delta \vdash e_1 \equiv e'_1 : s_1 \\
      \dots \\
      \Delta \vdash e_n \equiv e'_n : s_n}
    {\Delta \vdash \indexOp{f}(e_1, ..., e_n) \equiv \indexOp{f}(e'_1, ..., e'_n) : s}

    \inferrule*
    {\Delta \vdash e : s}
    {\Delta \vdash e \equiv e : s}

    \inferrule*
    {\Delta \vdash e_1 \equiv e_2 : s}
    {\Delta \vdash e_2 \equiv e_1 : s}

    \inferrule*
    {\Delta \vdash e_1 \equiv e_2 : s \\ \Delta \vdash e_2 \equiv e_3 : s}
    {\Delta \vdash e_1 \equiv e_3 : s}
  \end{mathpar}
  \caption{Algebraic Theories for Indexing}
  \label{fig:alg-theories}
\end{figure*}

We assume a set $\mathit{Sort}$ of \emph{index sorts}, and we will use
$s, s_1, s_2, ...$ to range over elements of $\mathit{Sort}$. An index
context $\Delta$ is list of index variable and sort pairs, $i : s$,
and we use the symbol $\epsilon$ to denote the empty index context (we
will also use this symbol below to denote the empty typing
context). We use letters like $i$ and $j$, sometimes with subscripts,
to range over index variables. We also assume a collection
$\mathit{IndexOp}$ of sorted index operations $\indexOp{f} :
s_1,...,s_n \to s$. From the index operations we generate the
well-sorted index expressions by the rules in
\autoref{fig:alg-theories}.

For each index context $\Delta$, we assume a set $\mathit{Ax}(\Delta)$
of axioms $e_1 \stackrel{ax}= e_2 : s$ where both $\Delta \vdash e_1 :
s$ and $\Delta \vdash e_2 : s$. From this collection of axioms, we
generate the equational theory of index expressions by the rules in
\autoref{fig:alg-theories} by closing under congruence, reflexivity,
symmetry and transitivity.

% For a pair of index contexts $\Delta$ and $\Delta'$, a substitution
% $\sigma \in \subst{\Delta}{\Delta'}$ is a function $\sigma$ mapping
% variables in $\Delta$ to well-sorted index expressions in $\Delta'$.

Index context morphisms $\sigma : \Delta \Rightarrow \Delta'$ consist
of a sequence of terms, one for each element of $\Delta'$, all
well-sorted in the index context $\Delta$.
\begin{mathpar}
  \inferrule*
  { }
  {\cdot : \Delta \Rightarrow \epsilon}

  \inferrule*
  {\sigma : \Delta \Rightarrow \Delta' \\ \Delta \vdash e : s}
  {\sigma, e : \Delta \Rightarrow \Delta', i:s}
\end{mathpar}
Directly from the definition of index context morphisms, we can see
that given an index context morphism $\sigma : \Delta \Rightarrow
\Delta'$, then for any index variable $i : s \in \Delta'$ there is an
index expression $\sigma(i)$ such that $\Delta \vdash \sigma(i) : s$.

We write $\id_\Delta : \Delta \Rightarrow \Delta$ for the index
context morphism comprised of the terms built from the variables of
$\Delta$, in order. We write $\pi_{i\mathord:s} : \Delta, i : s
\Rightarrow \Delta$ for the context morphism again comprised of the
terms built from the variables of $\Delta$, but this time typed in a
larger context. For an index context morphism $\sigma : \Delta \to
\Delta'$ we write $\sigma_s : \Delta, i\mathord:s \Rightarrow \Delta',
i\mathord:s$ for the index context morphism generated by lifting each
term to the larger context $\Delta, i\mathord:s$, and mapping the
variable $i\mathord:s$ to the term $i$.

Given an index expression $\Delta' \vdash e : s$, we define
re-indexing by an index context morphism $\sigma : \Delta \Rightarrow
\Delta'$ by the following clauses:
\begin{eqnarray*}
  \sigma^*i & = & \sigma(i) \\
  \sigma^*\indexOp{f}(e_1, ..., e_n) & = & \indexOp{f}(\sigma^*e_1,...,\sigma^*e_n)
\end{eqnarray*}
It is easy to check that these clauses preserve well-formedness of
index expressions, so that we obtain $\Delta \vdash \sigma^*e :
s$. Moreover re-indexing by index context morphisms preserves
equality:
\begin{lemma}\label{lem:indexeq-subst}
  If $\Delta \vdash e_1 \equiv e_2 : s$, then for any $\sigma :
  \Delta' \Rightarrow \Delta$, we have $\Delta' \vdash \sigma^*e_1
  \equiv \sigma^*e_2 : s$.
\end{lemma}

Also, projection commutes with lifting of substitutions. This is used
in the proof of \lemref{lem:tysubst-rel}.
\begin{lemma}
  $\sigma^* \circ \pi^*_{i\mathord:s} = \pi^*_{i\mathord:s} \circ \sigma^*_s$
\end{lemma}

For an index context $\Delta$ and sort $s$, we write
$\idxTms{\Delta}{s}$ for the set of index expressions $e$ such that
$\Delta \vdash e : s$, quotiented by the equivalence relation $\Delta
\vdash - \equiv - : s$. In light of \lemref{lem:indexeq-subst}, we can
see that re-indexing by an index context morphism $\sigma : \Delta
\Rightarrow \Delta'$ can be used as a function $\sigma^* :
\idxTms{\Delta'}{s} \to \idxTms{\Delta}{s}$, for any sort $s$.

\subsection{Types and Terms}\label{sec:types-and-terms}

\begin{figure*}[t]
  \centering
  Well-indexed Types
  \begin{mathpar}
    \inferrule* [right=TyPrimIdx]
    {\tyPrimNm{X} \in \mathit{PrimType}(s) \\ \Delta \vdash e : s}
    {\Delta \vdash \tyPrim{X}{e} : \sortType}

    \inferrule* [right=TyPrimNoIdx]
    {\tyPrimNm{X} \in \mathit{PrimType}(\cdot)}
    {\Delta \vdash \tyPrimNm{X} : \sortType}

    \inferrule* [right=TyUnit]
    { }
    {\Delta \vdash \tyUnit : \sortType}

    \inferrule* [right=TyArr]
    {\Delta \vdash A : \sortType \\ \Delta \vdash B : \sortType}
    {\Delta \vdash A \tyArr B : \sortType}

    \inferrule* [right=TyProd]
    {\Delta \vdash A : \sortType \\ \Delta \vdash B : \sortType}
    {\Delta \vdash A \tyProduct B : \sortType}

    \inferrule* [right=TySum]
    {\Delta \vdash A : \sortType \\ \Delta \vdash B : \sortType}
    {\Delta \vdash A + B : \sortType}
    
    \inferrule* [right=TyForall] %FIXME: macroize forall
    {\Delta, i : s \vdash A : \sortType}
    {\Delta \vdash \forall i \mathord: s. A : \sortType}
  \end{mathpar}

  \medskip
  Equality of well-indexed types
  \begin{mathpar}
    \inferrule* [right=TyEqPrimIdx]
    {\Delta \vdash e_1 \equiv e_2 : s}
    {\Delta \vdash \tyPrim{X}{e_1} \equiv \tyPrim{X}{e_2} : \sortType}

    \inferrule* [right=TyEqPrimNoIdx]
    { }
    {\Delta \vdash \tyPrimNm{X} \equiv \tyPrimNm{X} : \sortType}

    \inferrule* [right=TyEqUnit]
    { }
    {\Delta \vdash \tyUnit \equiv \tyUnit : \sortType}

    \inferrule* [right=TyEqArr]
    {\Delta \vdash A \equiv A' : \sortType \\ \Delta \vdash B \equiv B' : \sortType}
    {\Delta \vdash A \tyArr B \equiv A' \tyArr B' : \sortType}

    \inferrule* [right=TyEqProd]
    {\Delta \vdash A \equiv A' : \sortType \\ \Delta \vdash B \equiv B' : \sortType}
    {\Delta \vdash A \tyProduct B \equiv A' \tyProduct B' : \sortType}

    \inferrule* [right=TyEqSum]
    {\Delta \vdash A \equiv A' : \sortType \\ \Delta \vdash B \equiv B' : \sortType}
    {\Delta \vdash A + B \equiv A' + B' : \sortType}

    \inferrule* [right=TyEqForall]
    {\Delta, i : s \vdash A \equiv A' : \sortType}
    {\Delta \vdash \forall i \mathord: s. A \equiv \forall i \mathord: s. A' : \sortType}
  \end{mathpar}

  \medskip
  Well-indexed contexts
  \begin{mathpar}
    \inferrule*
    { }
    {\Delta \vdash \epsilon \isCtxt}

    \inferrule*
    {\Delta \vdash \Gamma \isCtxt \\ \Delta \vdash A : \sortType \\ x \not\in \Gamma}
    {\Delta \vdash \Gamma, x : A \isCtxt}
  \end{mathpar}
  \caption{Well-indexed Types and Contexts}
  \label{fig:types}
\end{figure*}

For each sort $s \in \mathit{Sort}$, we assume we are given a set of
names of primitive types $\mathit{PrimType}(s)$. We assume that the
sets $\mathit{PrimType}(s)$ are disjoint for non-equal sorts $s_1,
s_2$. For example, in the units of measure example in
\autoref{sec:units-example}, there is a single sort $\mathsf{unit}$,
and $\mathit{PrimType}(\mathsf{unit}) = \{\tyPrimNm{num}\}$. For each
primitive type $\tyPrimNm{X} \in \mathit{PrimType}(s)$, and index
expression $\Delta \vdash e : s$, we form the type $\tyPrim{X}{e}$, by
the \TirName{TyPrimIdx} rule in \autoref{fig:types}. Thus, in the
units-of-measure example, the type $\tyPrim{num}{u}$ represents
numbers measured by the units $u$.

We also assume that there is an additional set of primitive types
$\mathit{PrimType}(\cdot)$ that is disjoint from all the other sets of
primitive types. These primitive types do not need to be paired with
an index expression to form well-indexed types. Such types are created
by the \TirName{TyPrimNoIdx} rule. An example of such a primitive type
is the type $\tyPrimNm{real}$ of real-valued scalars in the Euclidean
plane geometry example in \autoref{sec:2d-example}.

The rules for generating the rest of the types of the system,
including unit, product, sum, function and universal types, are given
in \autoref{fig:types}. We use capital roman letters like $A$ and $B$
to range over well-indexed types. Well-indexed types come with an
equational theory, derived from the equational theory on index
expressions. This equational theory is also presented in
\autoref{fig:types}.

We define substitution by an index context morphism $\sigma : \Delta
\Rightarrow \Delta'$ on types by structural induction on the structure
of the type: given a type $\Delta' \vdash A : \sortType$, we obtain a
type $\Delta \vdash \sigma^*A : \sortType$. The only interesting case
is for \TirName{TyPrimIdx}:
\begin{displaymath}
  \sigma^*\tyPrim{X}{e} = \tyPrim{X}{\sigma^*e}
\end{displaymath}

Well-formed contexts are defined to be lists of variables paired with
well-formed types with respect to some index context $\Delta$, with
the condition that no variable names are repeated. Formally, contexts
are defined by the two rules shown in
\autoref{fig:types}. Substitution by an index context morphism extends
to contexts just by doing substitution on each individual type.

The typing rules for our system define the well-typed terms with
respect to an index context $\Delta$ and a type context $\Delta \vdash
\Gamma \isCtxt$. The judgement $\Delta; \Gamma \vdash M : A$ is
defined in \autoref{fig:terms}. The equational theory on types is
incorporated into the type system via the rule \TirName{TyEq}, which
allows for a term that is judged to have type $A$ to also have any
other equal type $B$.
\begin{figure*}[t]
  \centering
  \begin{mathpar}
    \inferrule* [right=Var]
    {\Delta \vdash \Gamma \isCtxt \\ x : A \in \Gamma}
    {\Delta; \Gamma \vdash x : A}

    \inferrule* [right=TyEq]
    {\Delta; \Gamma \vdash M : A \\ \Delta \vdash A \equiv B : \sortType}
    {\Delta; \Gamma \vdash M : B}

    \inferrule* [right=Unit]
    { }
    {\Delta; \Gamma \vdash * : 1}

    \inferrule* [right=Pair]
    {\Delta; \Gamma \vdash M : A \\
      \Delta; \Gamma \vdash N : B}
    {\Delta; \Gamma \vdash (M, N) : A \tyProduct B}

    \inferrule* [right=Proj1]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_1 M : A}

    \inferrule* [right=Proj2]
    {\Delta; \Gamma \vdash M : A \tyProduct B}
    {\Delta; \Gamma \vdash \pi_2 M : B}

    \inferrule* [right=Inl]
    {\Delta; \Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \mathrm{inl}\ M : A + B}

    \inferrule* [right=Inr]
    {\Delta; \Gamma \vdash M : B}
    {\Delta; \Gamma \vdash \mathrm{inr}\ M : A + B}

    \inferrule* [right=Cond]
    {\Delta; \Gamma \vdash M : A + B \\
      \Delta; \Gamma, x : A \vdash N_1 : C \\
      \Delta; \Gamma, y : B \vdash N_2 : C}
    {\Delta; \Gamma \vdash \textrm{case}\ M\ \textrm{of}\ \textrm{inl}\ x.N_1; \textrm{inr}\ y.N_2 : C}

    \inferrule* [right=Abs]
    {\Delta; \Gamma, x : A \vdash M : B}
    {\Delta; \Gamma \vdash \lambda x.M : A \tyArr B}

    \inferrule* [right=App]
    {\Delta; \Gamma \vdash M : A \tyArr B \\
      \Delta; \Gamma \vdash N : A}
    {\Delta; \Gamma \vdash M N : B}

    \inferrule* [right=UnivAbs]
    {\Delta, i : s; \pi_{i\mathord:s}^*\Gamma \vdash M : A}
    {\Delta; \Gamma \vdash \Lambda i. M : \forall i\mathord:s. A}

    \inferrule* [right=UnivApp]
    {\Delta; \Gamma \vdash M : \forall i\mathord:s. A \\ \Delta \vdash e : s}
    {\Delta; \Gamma \vdash M [e] : (\id_\Delta, e)^*A}
  \end{mathpar}
  
  \caption{Well-typed terms}
  \label{fig:terms}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example Systems}\label{sec:example-systems}

\subsection{Units of Measure}\label{sec:units-example}

We now show that our general framework encompasses Kennedy's
units-of-measure system \cite{kennedy97relational}. For our indexing
algebraic theory, we have a single sort $\mathsf{unit}$ intended to
represent composite units such as $\mathit{m}\ \mathit{s}^{-1}$ or
$\mathit{kg}\ \mathit{m}^{-2}$. Units of measure form an abelian
group, so we have three operations:
\begin{mathpar}
  1 : \mathsf{unit},

  \cdot : \mathsf{unit}, \mathsf{unit} \to \mathsf{unit},

  -^{-1} : \mathsf{unit} \to \mathsf{unit},
\end{mathpar}
subject to the normal abelian group axioms. We will elide the group
multiplication operation and just write multiplication as
juxtaposition: $u_1u_2$.

We let $\mathit{PrimType}(\mathsf{unit}) = \{\tyPrimNm{num}$, and
$\mathit{PrimType}(\cdot) = \{\tyPrimNm{rational}\}$. The intended
reading is that the type $\tyPrim{num}{u_1u^2_2}$ represents
quantities in units of $u_1u^2_2$, while values of type
$\tyPrimNm{rational}$ represent dimensionless constants. We make a
distinction between $\tyPrim{num}{1}$ and $\tyPrimNm{rational}$ for
technical reasons arising from the relational interpretation below: we
want the relation on $\tyPrim{num}{1}$ to be the identity relation,
and the existence of $\mathit{toRat}$ and $\mathit{fromRat}$ forces
this\footnote{Kennedy assumes that all relational environments set the
  relation on $\tyPrim{num}{1}$ to be the identity relation, but we
  cannot do this in general, because we do not necessarily have a
  group structure in the indexing theory.}. To write programs using
the $\tyPrimNm{num}$ type, we assume an typing context
$\Gamma_{\textrm{units}}$ consisting of the following typed
operations:
\begin{eqnarray*}
  \mathit{toRat} & : & \tyPrim{num}{1} \to \tyPrimNm{rational} \\
  \mathit{fromRat} & : & \tyPrim{num}{1} \to \tyPrimNm{rational} \\
  0 & : & \forall u. \tyPrim{num}{u} \\
  1 & : & \tyPrim{num}{1} \\
  + & : & \forall u. \tyPrim{num}{u} \to \tyPrim{num}{u} \to \tyPrim{num}{u} \\
  - & : & \forall u. \tyPrim{num}{u} \to \tyPrim{num}{u} \to \tyPrim{num}{u} \\
  * & : & \forall u_1 u_2. \tyPrim{num}{u_1} \to \tyPrim{num}{u_2} \to \tyPrim{num}{u_1u_2} \\
  / & : & \forall u_1 u_2. \tyPrim{num}{u_1} \to \tyPrim{num}{u_2} \to \tyPrim{num}{u_1u_2^{-1}} + 1 \\
  < & : & \forall u. \tyPrim{num}{u} \to \tyPrim{num}{u} \to \tyBool
\end{eqnarray*}
There are constants for zero and one, but only the constant for zero
is polymorphic in the units. In \autoref{sec:units-semantics} below,
we will following Kennedy by interpreting units of measure in terms of
\emph{scalings} by rational numbers, where it will be apparent that
the constant one cannot be unit-polymorphic: we can scale $0$ and
still get $0$, but we cannot scale $1$ by an arbitrary rational number
and expect to get $1$.

\subsection{Euclidean Plane Geometry}\label{sec:2d-example}

We now consider a type system for writing programs that are invariant
under the translational symmetries of the Euclidean plane. We assume a
single sort $\mathsf{translation}$. The sort $\mathsf{translation}$ is
intended to represent translations in the plane, and comes equipped
with abelian group structure that we write additively:
\begin{mathpar}
  0 : \mathsf{translation}

  + : \mathsf{translation},\mathsf{translation} \to \mathsf{translation}

  - : \mathsf{translation} \to \mathsf{translation}
\end{mathpar}
In indexing expressions involving variables of sort
$\mathsf{translation}$, we use the shorthand $t_1 - t_2$ to stand for
$t_1 + (-t_2)$.

There are two primitive types:
$\mathit{PrimType}(\mathsf{translation}) = \{\tyPrimNm{vec}\}$, and
$\mathit{PrimType}(\cdot) = \{\tyPrimNm{real}\}$. The types
$\tyPrim{vec}{t}$ represent two-dimensional vectors, indistinguishable
up to some translation $t$. Values of type $\tyPrimNm{real}$ are just
real numbers. To write programs using these types we assume a typing
context $\Gamma_{\mathit{2D}}$ consisting of the following operations:
\begin{eqnarray*}
  + & : & \forall t_1 t_2\mathord:\mathsf{translation}.\tyPrim{vec}{t_1} \to \tyPrim{vec}{t_2} \to \tyPrim{vec}{t_1 + t_2} \\
  - & : & \forall t\mathord:\mathsf{translation}. \tyPrim{vec}{t} \to \tyPrim{vec}{-t} \\
  0 & : & \tyPrim{vec}{0} \\
  * & : & \tyPrimNm{real} \to \tyPrim{vec}{0} \to \tyPrim{vec}{0} \\
  \mathrm{getX} & : & \tyPrim{vec}{0} \to \tyPrimNm{real} \\
  \mathrm{getY} & : & \tyPrim{vec}{0} \to \tyPrimNm{real} \\
  \mathrm{vec}  & : & \tyPrimNm{real} \to \tyPrimNm{real} \to \tyPrim{vec}{0}
\end{eqnarray*}
The first three operations express the abelian group structure of
2-dimensional real vectors. Note how the indexing tracks the
operations on vectors: e.g.~addition on vectors is reflected by
addition on the indicies. The final four operations are operations
that are not invariant under arbitrary translation: multiplication by
a scalar, and projection from and constructon of vectors. For the
purposes of examples, we also assume a standard set of arithmetic and
other operations on real numbers.

As an example of the use of the above operations, consider the
following type of a function for computing the area of a triangle
described by three points. Since the area of a triangle is invariant
under translations that are applied to all three points, we can
quantify over all translations $t$:
\begin{displaymath}
  \mathit{area} : \forall t\mathord:\mathsf{translation}.\ \tyPrim{vec}{t} \to \tyPrim{vec}{t} \to \tyPrim{vec}{t} \to \tyPrimNm{real}
\end{displaymath}
Since the result is invariant under translation, it safe to assume
that one of the vertexes of the triangle is the origin, and only
specify two points to describe the triangle. So we might expect that
the type of $\mathit{area}$ is isomorphic to this type:
\begin{displaymath}
  \mathit{area'} : \tyPrim{vec}{0} \to \tyPrim{vec}{0} \to \tyPrimNm{real}
\end{displaymath}
Given $\mathit{area'}$, we can define $\mathit{area}$ using the
operations in $\Gamma_{\mathit{2D}}$:
\begin{displaymath}
  \mathit{area} = \Lambda t. \lambda v_1 v_2 v_3.\ \mathit{area'}\ (v_2 - v_1)\ (v_3 - v_1)
\end{displaymath}
and vice versa, we can define $\mathit{area'}$ in terms of
$\mathit{area}$:
\begin{displaymath}
  \mathit{area'} = \lambda v_1 v_2. \mathit{area}\ [0]\ 0\ v_1\ v_2
\end{displaymath}
In \autoref{sec:2d-semantics} below, we will show that these two
translations form a type isomorphism between the types of
$\mathit{area}$ and $\mathit{area'}$.

\paragraph{Alternative Transformation Groups?}
We should also consider other groups of transformations for indexing:
isometries, orthogonal transformations, rotations and reflections.

\subsection{Security Typing and Non-interference}

This example shows how our framework can accommodate non-interference
properties common in security type systems. This example has a
different flavour to the two previous examples because it does not
concern invariance under the action of some group. We assume a single
sort $\mathsf{principal}$, intended to represent (possibly composite)
principals in a system. Principals are combined using the connectives
of boolean logic:
\begin{mathpar}
  \top : \mathsf{principal}

  \bot : \mathsf{principal}

  \land : \mathsf{principal},\mathsf{principal} \to \mathsf{principal}

  \lor : \mathsf{principal},\mathsf{principal} \to \mathsf{principal}

  \Rightarrow : \mathsf{principal},\mathsf{principal} \to \mathsf{principal}

  \lnot : \mathsf{principal} \to \mathsf{principal}
\end{mathpar}
For the equational theory of principals, we assume all the axioms of
boolean algebra.

Let $\mathit{PrimType}(\mathsf{principal}) = \{\tyPrimNm{T}\}$. The
intended reading of a type $\tyPrim{T}{p}$ for some principal $p$ is
that the existence of a value of this type indicates that the
principal $p$ is ``happy''. To write programs, we assume the following
typing context $\Gamma_{\mathit{sec}}$ of operations:
\begin{eqnarray*}
  \mathrm{proj} & : & \forall p_1 p_2\mathord:\mathsf{principal}.\ \tyPrim{T}{p_1 \land p_2} \to \tyPrim{T}{p_1} \\
  \mathrm{combine} & : & \forall p_1 p_2\mathord:\mathsf{principal}.\ \tyPrim{T}{p_1} \to \tyPrim{T}{p_2} \to \tyPrim{T}{p_1 \land p_2}
\end{eqnarray*}

To illustrate the use of this application of our framework, we define
a type synonym, for each type $A$ and principal $p$:
\begin{displaymath}
  T_pA = \tyPrim{T}{p} \to A
\end{displaymath}
For every principal $p$, we can endow the types $T_p-$ with the
structure of a monad. This is due to the fact that it is an instance
of the ``environment'' (or ``reader'') monad. Explicitly, the
$\mathit{return}$ and $>>=$ of these monads are given by:
\begin{eqnarray*}
  \mathit{return} & : & A \to T_pA \\
  \mathit{return} & = & \lambda a\ t.\ a \\
  \\
  (>>=) & : & T_pA \to (A \to T_pB) \to T_pB \\
  (>>=) & = & \lambda a\ f\ t.\ f\ (a\ t)\ t
\end{eqnarray*}
The intended reading of a value of type $T_pA$ is as a piece of data
of type $A$ that can only be accessed if the principal $p$ is
happy. The existence of such a monad should allow us to draw parallels
between our system and the Dependency Core Calculus (DCC) system of
Abadi \emph{et al.} \cite{abadi99core}. The definition of a DCC monad
as an instance of an environment monad follows Tse and Zdancewic's
interpretation of DCC in System F, where they use System F
parametricity to ensure non-interference properties.

There is also a coercion operator between instances of $T_pA$ for
different principals. Reading the type in terms of happiness, this
says that if we have a piece of data that is protected by $p$, and
happiness of $q$ implies happiness of $p$, then this data can also be
accessed by $q$.
\begin{eqnarray*}
  \mathit{coerce} & : & \tyPrim{T}{q \Rightarrow p} \to T_pA \to T_qA \\
  \mathit{coerce} & = & \lambda t_{qp}\ a\ t_q.\ a\ (\mathrm{combine}\ t_{qp}\ t_q)
\end{eqnarray*}
Here we have used the fact that the result of the application of
$\mathrm{combine}$ has type $\tyPrim{T}{(q \Rightarrow p) \land
  q}$. By the laws of boolean algebras---which we have assumed for our
indexing theory---this is equal to the type $\tyPrim{T}{p}$. Thus we
get access to the data stored in $a$, which is protected by $p$.

Now suppose we have a term $M$ with the following typing:
\begin{displaymath}
  p,q:\mathsf{principal}; t_{qp} : \tyPrim{T}{q \Rightarrow p}, x : T_q (1 + 1) \vdash M : T_p (1 + 1)
\end{displaymath}
Intuitively, given the operations $\Gamma_{\mathit{sec}}$ we have
defined above, it should be the case that $M$ can only be equivalent
to the program which is constantly $\lambda t. \mathrm{inl}(*)$ or
$\lambda t. \mathrm{inr}(*)$, because there is no useful data to be
gained from the $t_{qp}$ argument, and a value of $\tyPrim{T}{q}$
cannot be generated in order to get access to the data within the $x$
argument. The application of our framework that we have presented in
this section has a ``non-interference'' property: the value of $x$
cannot interfere with the output. In \autoref{sec:sec-semantics} we
show that this is indeed the case.

\paragraph{Alternative Logics?}
Above, we assumed that the indexing theory of principals was the
theory of boolean algebras. As a consequence, a value of type $T_{p
  \lor \lnot p}A$ can always be accessed, due to the exlcuded middle
property of boolean logic. An interesting question is: what happens we
we consider alternative logics. If we take the theory of Heyting
algebras for our theory of principals, then data typed as $T_{p \lor
  \lnot p}A$ can only be accessed if either $p$ or $\lnot p$ can be
demonstrated. Considering an alternative logical theory alters the
non-interference property of the type system.

\paragraph{Alternative Presentations?}
In the above we presented the theory of boolean logic by means of the
equational theory of boolean algebras. This isn't necessarily the most
convenient way of presenting a logic. An alternative approach would be
to consider a trivial equational theory with no axioms, and
incorporate the rules of logic consequence as operations in
$\Gamma_{\mathit{sec}}$. For example, as a Hilbert system:
\begin{eqnarray*}
  \mathit{MP} & : & \forall p,q.\ \tyPrim{T}{p \Rightarrow q} \to \tyPrim{T}{p} \to \tyPrim{T}{q} \\
  \mathit{k} & : & \forall p,q.\ \tyPrim{T}{p \Rightarrow q \Rightarrow p} \\
  \mathit{s} & : & \forall p,q,r.\ \tyPrim{T}{(p \Rightarrow q \Rightarrow r) \Rightarrow (p \Rightarrow q) \Rightarrow p \Rightarrow r}
\end{eqnarray*}
Plus axioms for the other connectives.  Or possibly some kind of
encoding of a natural deduction system?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Semantics and Parametricity Theorem}

There is an index-erasure semantics, and a relational semantics. The
relational semantics allows us to derive free theorems about the
index-erasure semantics.

\subsection{Index Erasure Semantics}

We now define a semantics of types and terms that ignores all indexing
information. By defining this semantics we can easily see that the
indexing information can be discarded before execution.

\subsubsection{Index-Erasure Semantics of Types}

For each primitive type $\tyPrimNm{X} \in \mathit{PrimType}(s)$, for
some sort $s$, and for the primitive types $\tyPrimNm{X} \in
\mathit{PrimType}(\cdot)$, we assume that $\tyPrimNm{X}$ is assigned a
set $\tyPrimSem{X}$. We extend this to assign a set to every
well-formed type by induction on the type structure. To interpret the
universal quantifier, we simply ignore the indexing:
\begin{eqnarray*}
  \tySem{\tyUnit} & = & \{*\} \\
  \tySem{\tyPrim{X}{e}} & = & \tyPrimSem{X} \\
  \tySem{\tyPrim{X}} & = & \tyPrimSem{X} \\
  \tySem{A \tyProduct B} & = & \tySem{A} \times \tySem{B} \\
  \tySem{A \tyArr B} & = & \tySem{A} \to \tySem{B} \\
  \tySem{A + B} & = & \tySem{A} + \tySem{B} \\
  \tySem{\forall i\mathord:s. A} & = & \tySem{A}
\end{eqnarray*}

Since our definition has completely ignored the indexing, and type
equality is defined as an extension of index equality, we can easily
see that equal types have equal denotations in our index-erasure
semantics:
\begin{lemma}\label{lem:tyeq-erasure}
  If $\Delta \vdash A \equiv B : \sortType$ then $\tySem{A} =
  \tySem{B}$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $\Delta \vdash A \equiv B :
  \sortType$:
  \begin{description}
  \item[Case \TirName{TyEqUnit}] In this case, $A = B = \tyUnit$, so
    $\tySem{A} = \tySem{B}$.
  \item[Case \TirName{TyEqPrimIdx}] We have $A = \tyPrim{X}{e_1}$ and
    $B = \tyPrim{X}{e_2}$, for some $e_1$ and $e_2$ of the same
    sort. The erasure semantics ignores the index arguments, so
    $\tySem{A} = \tySem{\tyPrim{X}{e_1}} = \tyPrimSem{X} =
    \tySem{\tyPrim{X}{e_2}} = \tySem{B}$, as required.
  \item[Case \TirName{TyEqPrimNoIdx}] We have $A = \tyPrimNm{X}$ and
    $B = \tyPrimNm{X}$. So $\tySem{A} = \tyPrimSem{X} = \tySem{B}$, as
    required.
  \item[Case \TirName{TyEqArr}] Here, $A = A_1 \tyArr A_2$ and $B =
    B_1 \tyArr B_2$, and by the induction hypothesis we know that
    $\tySem{A_1} = \tySem{B_1}$ and $\tySem{A_2} = \tySem{B_2}$. Hence
    $\tySem{A} = \tySem{A_1 \tyArr A_2} = \tySem{A_1} \to \tySem{A_2}
    = \tySem{B_1} \to \tySem{B_2} = \tySem{B_1 \tyArr B_2} =
    \tySem{B}$.
  \item[Case \TirName{TyEqProd}] In this case, $A = A_1 \tyProduct
    A_2$ and $B = B_1 \tyProduct B_2$, and by the induction hypothesis
    we know that $\tySem{A_1} = \tySem{B_1}$ and $\tySem{A_2} =
    \tySem{B_2}$. Hence $\tySem{A} = \tySem{A_1 \tyProduct A_2} =
    \tySem{A_1} \times \tySem{A_2} = \tySem{B_1} \times \tySem{B_2} =
    \tySem{B_1 \tyProduct B_2} = \tySem{B}$.
  \item[Case \TirName{TyEqSum}] In this case, $A = A_1 + A_2$ and $B =
    B_1 + B_2$, and by the induction hypothesis we know that
    $\tySem{A_1} = \tySem{B_1}$ and $\tySem{A_2} = \tySem{B_2}$. Hence
    $\tySem{A} = \tySem{A_1 + A_2} = \tySem{A_1} + \tySem{A_2} =
    \tySem{B_1} + \tySem{B_2} = \tySem{B_1 + B_2} = \tySem{B}$.
  \item[Case \TirName{TyEqForall}] We have $A = \forall
    i\mathord:s.A'$ and $B = \forall i\mathord:s.B'$. By the induction
    hypothesis we know that $\tySem{A'} = \tySem{B'}$, and hence
    $\tySem{A} = \tySem{\forall i\mathord:s. A'} = \tySem{A'} =
    \tySem{B'} = \tySem{\forall i\mathord:s. B'} = \tySem{B}$.
  \end{description}
\end{proof}

Moreover, the index-erasure semantics is insensitive to index
substitutions.
\begin{lemma}\label{lem:tysubst-erasure}
  If $\Delta \vdash A : \sortType$ and $\sigma : \Delta' \Rightarrow
  \Delta$, then $\tySem{\sigma^*A} = \tySem{A}$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $\Delta \vdash A : \sortType$.
  \begin{description}
  \item[Case \TirName{TyUnit}] Directly from the definition of
    substitution on types of the form $\tyUnit$, we have
    $\tySem{\sigma^*\tyUnit} = \tySem{\tyUnit}$, as required.
  \item[Case \TirName{TyPrimIdx}] Since the index-erasure semantics
    ignores all index expessions, we have
    $\tySem{\sigma^*\tyPrim{X}{e}} = \tySem{\tyPrim{X}{\sigma^*e}} =
    \tyPrimSem{X} = \tySem{\tyPrim{X}{e}}$.
  \item[Case \TirName{TyPrimNoIdx}] Similar to the previous case.
  \item[Case \TirName{TyArr}] We have $A = A_1 \tyArr A_2$, and by the
    induction hypothesis, we know that $\tySem{\sigma^*A_1} =
    \tySem{A_1}$ and $\tySem{\sigma^*B_1} = \tySem{B_1}$. Thus, by the
    definition of substitution on arrow types, we have
    $\tySem{\sigma^*(A_1 \tyArr A_2)} = \tySem{\sigma^*A_1 \tyArr
      \sigma^*A_2} = \tySem{\sigma^*A_1} \to \tySem{\sigma^*A_2} =
    \tySem{A_1} \to \tySem{A_2} = \tySem{A_1 \tyArr A_2}$, as
    required.
  \item[Case \TirName{TyProd}] We have $A = A_1 \tyProduct A_2$, and
    by the induction hypothesis, we know that $\tySem{\sigma^*A_1} =
    \tySem{A_1}$ and $\tySem{\sigma^*A_2} = \tySem{A_2}$. Thus, by the
    definition of substitution on product types, we have
    $\tySem{\sigma^*(A_1 \tyProduct A_2)} = \tySem{\sigma^*A_1
      \tyProduct \sigma^*A_2} = \tySem{\sigma^*A_1} \times
    \tySem{\sigma^*A_2} = \tySem{A_1} \times \tySem{A_2} = \tySem{A_1
      \tyProduct A_2}$, as required.
  \item[Case \TirName{TySum}] We have $A = A_1 + A_2$, and by the
    induction hypothesis, we know that $\tySem{\sigma^*A_1} =
    \tySem{A_1}$ and $\tySem{\sigma^*A_2} = \tySem{A_2}$. Thus, by the
    definition of substitution on sum types, we have
    $\tySem{\sigma^*(A_1 + A_2)} = \tySem{\sigma^*A_1 + \sigma^*A_2} =
    \tySem{\sigma^*A_1} + \tySem{\sigma^*A_2} = \tySem{A_1} +
    \tySem{A_2} = \tySem{A_1 + A_2}$, as required.
  \item[Case \TirName{TyForall}] We have $A = \forall i\mathord:s.A'$,
    and by the induction hypothesis we know that, for all $\sigma'$,
    $\tySem{\sigma'^*A'} = \tySem{A'}$. Therefore, from the definition
    of substitution for $\forall$-types, we have
    $\tySem{\sigma^*\forall i\mathord:s.A'} = \tySem{\forall
      i\mathord:s.\sigma_s^{*}A'} = \tySem{\sigma_s^{*}A'} = \tySem{A'}
    = \tySem{\forall i\mathord:s.A'}$, where we have relied on the
    fact that the index-erasure semantics of types ignores the index
    quantification.
  \end{description}
\end{proof}

For any typing context $\Delta \vdash \Gamma \isCtxt$, we define its
index-erasure semantics $\ctxtSem{\Gamma}$ by induction on its
structure: $\ctxtSem{\epsilon} = 1$ and $\ctxtSem{\Gamma, x : A} =
\ctxtSem{\Gamma} \times \tySem{A}$, where $1$ is the canonical
one-element set.

\subsubsection{Index-Erasure Semantics of Terms}

For a well-formed term $\Delta; \Gamma \vdash e : A$, we define a
function $\tmSem{e} : \ctxtSem{\Gamma} \to \tySem{A}$, completely
ignoring the indexing information. In light of
\lemref{lem:tyeq-erasure} and \lemref{lem:tysubst-erasure}, we may
define this function directly on the syntax of well-typed terms,
rather than on the typing derivations. We define $\tmSem{e}$ by the
following clauses:
\begin{eqnarray*}
  \tmSem{x}\eta & = & \eta_x \\
  \tmSem{(M,N)}\eta & = & (\tmSem{M}\eta, \tmSem{N}\eta) \\
  \tmSem{\pi_1M}\eta & = & \pi_1(\tmSem{M}\eta) \\
  \tmSem{\pi_2M}\eta & = & \pi_2(\tmSem{M}\eta) \\
  \tmSem{\mathrm{inl}\ M}\eta & = & \mathrm{inl}\ (\tmSem{M}\eta) \\
  \tmSem{\mathrm{inr}\ M}\eta & = & \mathrm{inr}\ (\tmSem{M}\eta) \\
  \left\llbracket
    \begin{array}{l}
      \textrm{case}\ M\ \textrm{of}\\
      \textrm{inl}\ x.N_1;\\
      \textrm{inr}\ y.N_2
    \end{array}\right\rrbracket^{\mathit{tm}}\eta & = &
  \left\{
    \begin{array}{ll}
      \tmSem{N_1}(\eta,a) & \textrm{if }\tmSem{M}\eta = \mathrm{inl}(a) \\
      \tmSem{N_2}(\eta,b) & \textrm{if }\tmSem{M}\eta = \mathrm{inr}(b)
    \end{array}
  \right. \\
  \tmSem{\lambda x. M}\eta & = & \lambda v. \tmSem{M}(\eta, v) \\
  \tmSem{M N}\eta & = & (\tmSem{M}\eta) (\tmSem{N}\eta) \\
  \tmSem{\Lambda i.\ M}\eta & = & \tmSem{M}\eta \\
  \tmSem{M[e]}\eta & = & \tmSem{M}\eta
\end{eqnarray*}
In the above, we have written $\eta_x$ to denote the appropriate
projection from $\eta$ to get the position corresponding to the
variable $x$ in the context.

\subsection{Relational Semantics}

\subsubsection{Relation Environments}

For a set $X$, let $\Rel(X)$ be the set of binary relations on
$X$. For an index context $\Delta$, a \emph{relation environment} is a
family of functions $\rho = \{ \rho_{\tyPrimNm{X}} :
\idxTms{\Delta}{s} \to \Rel(\tyPrimSem{X}) \}_{s \in \mathit{Sort},
  \tyPrimNm{X} \in \mathit{PrimType}(s)}$.

We define our relational semantics of types with respect to a given
collection of relation environments: we assume that, for each index
context $\Delta$, we are given a set of relation environments
$\relEnv{E}(\Delta)$. This family must satisfy the following two
properties:
\begin{enumerate}
\item Closure under re-indexing by index context morphisms: if $\rho
  \in \relEnv{E}(\Delta)$ and $\sigma : \Delta' \Rightarrow \Delta$,
  then $\rho \circ \sigma^* \in \relEnv{E}(\Delta')$.
\item If we have a pair of relation environments $\rho_1 \in
  \relEnv{E}(\Delta', i\mathord:s')$ and $\rho_2 \in
  \relEnv{E}(\Delta)$, along with an index context morphism $\sigma :
  \Delta' \Rightarrow \Delta$, such that the outer edges of the
  following diagram commute, for all primitive types $\tyPrimNm{X} \in
  \mathit{PrimType}(s)$:
  \begin{displaymath}
    \xymatrix{
      {\idxTms{\Delta}{s}} \ar[r]^(.45){\pi^*_{i\mathord:s'}} \ar[d]_{\sigma^*}
      &
      {\idxTms{\Delta,i\mathord:s'}{s}} \ar[d]^{\sigma_{s'}^*} \ar@/^/[rdd]^{\rho_1}
      \\
      {\idxTms{\Delta'}{s}} \ar[r]^(.45){\pi^*_{i\mathord:s'}} \ar@/_/[rrd]_{\rho_2}
      &
      {\idxTms{\Delta',i\mathord:s'}{s}} \ar@{.>}[dr]_\rho
      \\
      &
      &
      {\Rel(X)}
    }
  \end{displaymath}
  Then there exists a relation environment $\rho \in
  \relEnv{E}(\Delta,i\mathord:s')$ such that the two triangles in the
  bottom right of the diagram commute.
\end{enumerate}

Given a relation environment $\rho \in \relEnv{E}(\Delta)$, we define
the set of extensions $\extends{\rho}{i\mathord:s}$ of $\rho$ by an
additional index variable $i\mathord:s$ to be the following:
\begin{displaymath}
  \extends{\rho}{i\mathord:s} = \{ \rho' \in \relEnv{E}(\Delta,i\mathord:s) \sepbar \rho' \circ \pi^*_{i\mathord:s} = \rho \}
\end{displaymath}

\subsubsection{Relational Semantics of Types}

%FIXME: re-word this
A given relation context $\rho \in \relEnv{E}(\Delta)$ is extended to
a relation interpretation of any type $\Delta \vdash A : \sortType$ by
induction its derivation. So we define a relation
$\rsem{A}{\relEnv{E}}{\rho} \in \Rel(\tySem{A})$ for each well-formed
type $A$.
\begin{eqnarray*}
  \rsem{\tyUnit}{\relEnv{E}}\rho & = & \{(*,*)\} \\
  \rsem{\tyPrim{X}{e}}{\relEnv{E}}\rho & = & \rho_{\tyPrimNm{X}}(e) \\
  \rsem{A \tyArr B}{\relEnv{E}}\rho & = & \rsem{A}{\relEnv{E}}\rho \relArrow \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A \tyProduct B}{\relEnv{E}}\rho & = & \rsem{A}{\relEnv{E}}\rho \relTimes \rsem{B}{\relEnv{E}}\rho \\
  \rsem{A + B}{\relEnv{E}}\rho & = & \rsem{A}{\relEnv{E}}\rho \relSum \rsem{B}{\relEnv{E}}\rho \\
  \rsem{\forall i\mathord:s.A}{\relEnv{E}}\rho & = & \bigcap\{ \rsem{A}{\relEnv{E}}\rho' \sepbar \rho' \in \extends{\rho}{i:s} \}
\end{eqnarray*}
In this definition we have made use of the following two constructions
on binary relations. If $R \in \Rel(X)$ and $S \in \Rel(Y)$, then $R
\relArrow S \in \Rel(X \to Y)$ is defined as $\{ (f_1,f_2) \sepbar
\forall (a_1,a_2) \in R.\ (f_1a_1,f_2a_2) \in S \}$. With the same
assumptions on $R$ and $S$, the relation $R \relTimes S \in \Rel(X
\times Y)$ is defined as $\{ ((a_1,b_1),(a_2,b_2)) \sepbar (a_1,a_2)
\in R \land (b_1,b_2) \in S \}$. FIXME: do $\relSum$.

We extend the relational semantics to contexts of well-formed types by
the following clauses:
\begin{eqnarray*}
  \rsem{\epsilon}{\relEnv{E}}{\rho} & = & \id_{\ctxtSem{\epsilon}} \\
  \rsem{\Gamma, x : A}{\relEnv{E}}{\rho} & = & \rsem{\Gamma}{\relEnv{E}}\rho \relTimes \rsem{A}{\relEnv{E}}\rho
\end{eqnarray*}

\subsubsection{Parametricity}

This relies on \lemref{lem:tyeq-erasure} to make sure that it is
well-typed.

\begin{lemma}\label{lem:tyeq-rel}
  If $\Delta \vdash A \equiv B : \sortType$, then for all $\rho \in
  \relEnv{E}(\Delta)$, $\rsem{A}{\relEnv{E}}\rho = \rsem{B}{\relEnv{E}}\rho$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $\Delta \vdash A \equiv B :
  \sortType$.
  \begin{description}
  \item[Case \TirName{TyEqUnit}] In this case $A = B = \tyUnit$, so
    the statement is trivially statisfied.
  \item[Case \TirName{TyEqPrimIdx}] In this case we have $A =
    \tyPrim{X}{e_1}$ and $B = \tyPrim{X}{e_2}$, with $\Delta \vdash
    e_1 \equiv e_2 : s$. The index expressions $e_1$ and $e_2$ are in
    the same equivalence class, so by the definition of relation
    environments we have that $\rho_{\tyPrimNm{X}}(e_1) =
    \rho_{\tyPrimNm{X}}(e_2)$ and hence
    $\rsem{\tyPrim{X}{e_1}}{\relEnv{E}}\rho =
    \rsem{\tyPrim{X}{e_2}}{\relEnv{E}}\rho$.
  \item[Case \TirName{TyEqPrimNoIdx}] This case is similar to the case
    for \TirName{TyEqUnit}.
  \item[Case \TirName{TyEqArr}] We have $A = A_1 \tyArr A_2$ and $B =
    B_1 \tyArr B_2$, with $\Delta \vdash A_1 \equiv B_1 : \sortType$
    and $\Delta \vdash A_2 \equiv B_2 : \sortType$. By the induction
    hypothesis, we know that $\rsem{A_1}{\relEnv{E}}\rho =
    \rsem{B_1}{\relEnv{E}}\rho$ and $\rsem{A_2}{\relEnv{E}}\rho =
    \rsem{B_2}{\relEnv{E}}\rho$. Thus we may reason as follows:
    $\rsem{A_1 \tyArr A_2}{\relEnv{E}}\rho =
    \rsem{A_1}{\relEnv{E}}\rho \relArrow \rsem{A_2}{\relEnv{E}}\rho =
    \rsem{B_1}{\relEnv{E}}\rho \relArrow \rsem{B_2}{\relEnv{E}}\rho =
    \rsem{B_1 \tyArr B_2}{\relEnv{E}}\rho$, as required.
  \item[Case \TirName{TyEqProd}] We have $A = A_1 \tyProduct A_2$ and
    $B = B_1 \tyProduct B_2$, with $\Delta \vdash A_1 \equiv B_1 :
    \sortType$ and $\Delta \vdash A_2 \equiv B_2 : \sortType$. By the
    induction hypothesis, we know that $\rsem{A_1}{\relEnv{E}}\rho =
    \rsem{B_1}{\relEnv{E}}\rho$ and $\rsem{A_2}{\relEnv{E}}\rho =
    \rsem{B_2}{\relEnv{E}}\rho$. Therefore, we can reason as follows:
    $\rsem{A_1 \tyProduct A_2}{\relEnv{E}}\rho =
    \rsem{A_1}{\relEnv{E}}\rho \relTimes \rsem{A_2}{\relEnv{E}}\rho =
    \rsem{B_1}{\relEnv{E}}\rho \relTimes \rsem{B_2}{\relEnv{E}}\rho =
    \rsem{B_1 \tyProduct B_2}{\relEnv{E}}\rho$, as required.
  \item[Case \TirName{TyEqSum}] We have $A = A_1 + A_2$ and $B = B_1 +
    B_2$, with $\Delta \vdash A_1 \equiv B_1 : \sortType$ and $\Delta
    \vdash A_2 \equiv B_2 : \sortType$. By the induction hypothesis,
    we know that $\rsem{A_1}{\relEnv{E}}\rho =
    \rsem{B_1}{\relEnv{E}}\rho$ and $\rsem{A_2}{\relEnv{E}}\rho =
    \rsem{B_2}{\relEnv{E}}\rho$. Therefore, we can reason as follows:
    $\rsem{A_1 + A_2}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}\rho
    \relSum \rsem{A_2}{\relEnv{E}}\rho = \rsem{B_1}{\relEnv{E}}\rho
    \relSum \rsem{B_2}{\relEnv{E}}\rho = \rsem{B_1 +
      B_2}{\relEnv{E}}\rho$, as required.
  \item[Case \TirName{TyEqForall}] We have $A = \forall
    i\mathord:s. A'$ and $B = \forall i\mathord:s.B'$, with $\Delta, i
    : s \vdash A' \equiv B' : \sortType$. By the induction hypothesis,
    we know that for all $\rho'$, $\rsem{A'}{\relEnv{E}}\rho' =
    \rsem{B'}\rho'$. We reason as follows:
    \begin{eqnarray*}
      &    & (x_1,x_2) \in \rsem{\forall i\mathord:s. A'}{\relEnv{E}}\rho \\
      &\iff& \forall \rho' \in \extends{\rho}{i:s}.\ (x_1,x_2) \in \rsem{A'}{\relEnv{E}}\rho' \\
      &\iff& \forall \rho' \in \extends{\rho}{i:s}.\ (x_1,x_2) \in \rsem{B'}{\relEnv{E}}\rho' \\
      &\iff& (x_1,x_2) \in \rsem{\forall i\mathord:s. B'}{\relEnv{E}}\rho
    \end{eqnarray*}
    Thus, by extensionality, we have $\rsem{\forall
      i\mathord:s.A'}\rho \equiv \rsem{\forall
      i\mathord:s.B'}{\relEnv{E}}\rho$, as required.
  \end{description}
\end{proof}

This next lemma relies on \lemref{lem:tysubst-erasure} to make sure
that it is well-typed.

\begin{lemma}\label{lem:tysubst-rel}
  If $\Delta \vdash A : \sortType$ and $\sigma : \Delta' \Rightarrow
  \Delta$, then for all $\rho \in \relEnv{E}(\Delta')$,
  $\rsem{\sigma^*A}{\relEnv{E}}\rho = \rsem{A}{\relEnv{E}}{(\rho \circ \sigma^*)}$. Likewise,
  if $\Delta \vdash \Gamma \isCtxt$ and $\sigma : \Delta' \Rightarrow
  \Delta$, then for all $\rho \in \relEnv{E}(\Delta')$,
  $\rsem{\sigma^*\Gamma}{\relEnv{E}}\rho = \rsem{\Gamma}{\relEnv{E}}{(\rho \circ \sigma^*)}$.
\end{lemma}

\begin{proof}
  The first part of the lemma statement is proved by induction on the
  derivation of $\Delta \vdash A : \sortType$. We analyse each case in
  turn:
  \begin{description}
  \item[Case \TirName{TyUnit}] Directly from the definition of
    substitution on types of the form $\tyUnit$, and the fact that
    $\rsem{\tyUnit}{\relEnv{E}}\rho_1 =
    \rsem{\tyUnit}{\relEnv{E}}\rho_2$ for any pair $\rho_1,\rho_2$ of
    relation environments, we have
    $\rsem{\sigma^*\tyUnit}{\relEnv{E}}\rho =
    \rsem{\tyUnit}{\relEnv{E}}{(\rho \circ \sigma^*)}$, as required.
  \item[Case \TirName{TyPrimIdx}] We have $A = \tyPrim{X}{e}$, therefore
    $\rsem{\sigma^*A}{\relEnv{E}}\rho =
    \rsem{\sigma^*\tyPrim{X}{e}}{\relEnv{E}}\rho =
    \rsem{\tyPrim{X}{\sigma^*e}}{\relEnv{E}}\rho =
    \rho_{\tyPrimNm{X}}(\sigma^*e) =
    \rsem{\tyPrim{X}{e}}{\relEnv{E}}{(\rho \circ \sigma^*)}$, as
    required.
  \item[Case \TirName{TyPrimNoIdx}] Similar to the case for
    \TirName{TyUnit}.
  \item[Case \TirName{TyArr}] In this case, $A = A_1 \tyArr A_2$ and
    by the induction hypothesis, we know that $\rsem{\sigma^*A_1}{\relEnv{E}}\rho
    = \rsem{A_1}{\relEnv{E}}{(\rho \circ \sigma^*)}$ and $\rsem{\sigma^*A_2}{\relEnv{E}}\rho =
    \rsem{A_2}{\relEnv{E}}{(\rho \circ \sigma^*)}$. Accordingly, we reason as
    follows: $\rsem{\sigma^*(A_1 \tyArr A_2)}{\relEnv{E}}\rho = \rsem{\sigma^*A_1
      \tyArr \sigma^*A_2}{\relEnv{E}}\rho = \rsem{\sigma^*A_1}{\relEnv{E}}\rho \relArrow
    \rsem{\sigma^*A_2}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}{(\rho \circ \sigma^*)}
    \relArrow \rsem{A_2}{\relEnv{E}}{(\rho \circ \sigma^*)} = \rsem{A_1 \tyArr
      A_2}{\relEnv{E}}{(\rho \circ \sigma^*)}$, as required.
  \item[Case \TirName{TyProd}] In this case, $A = A_1 \tyProduct A_2$
    and by the induction hypothesis, we know that
    $\rsem{\sigma^*A_1}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}{(\rho
      \circ \sigma^*)}$ and $\rsem{\sigma^*A_2}{\relEnv{E}}\rho =
    \rsem{A_2}{\relEnv{E}}{(\rho \circ \sigma^*)}$. Accordingly, we
    reason as follows: $\rsem{\sigma^*(A_1 \tyProduct
      A_2)}{\relEnv{E}}\rho = \rsem{\sigma^*A_1 \tyProduct
      \sigma^*A_2}{\relEnv{E}}\rho =
    \rsem{\sigma^*A_1}{\relEnv{E}}\rho \relTimes
    \rsem{\sigma^*A_2}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}{(\rho
      \circ \sigma^*)} \relTimes \rsem{A_2}{\relEnv{E}}{(\rho \circ
      \sigma^*)} = \rsem{A_1 \tyProduct A_2}{\relEnv{E}}{(\rho \circ
      \sigma^*)}$, as required.
  \item[Case \TirName{TySum}] In this case, $A = A_1 + A_2$
    and by the induction hypothesis, we know that
    $\rsem{\sigma^*A_1}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}{(\rho
      \circ \sigma^*)}$ and $\rsem{\sigma^*A_2}{\relEnv{E}}\rho =
    \rsem{A_2}{\relEnv{E}}{(\rho \circ \sigma^*)}$. Accordingly, we
    reason as follows: $\rsem{\sigma^*(A_1 +
      A_2)}{\relEnv{E}}\rho = \rsem{\sigma^*A_1 +
      \sigma^*A_2}{\relEnv{E}}\rho =
    \rsem{\sigma^*A_1}{\relEnv{E}}\rho \relSum
    \rsem{\sigma^*A_2}{\relEnv{E}}\rho = \rsem{A_1}{\relEnv{E}}{(\rho
      \circ \sigma^*)} \relSum \rsem{A_2}{\relEnv{E}}{(\rho \circ
      \sigma^*)} = \rsem{A_1 + A_2}{\relEnv{E}}{(\rho \circ
      \sigma^*)}$, as required.
  \item[Case \TirName{TyForall}] We have $A = \forall
    i\mathord:s.A'$. We prove the required equation by demonstrating
    two inclusions. From left-to-right, we know that
    \begin{equation}
      \label{eq:tysubst-rel-forall1}
      (x_1,x_2) \in \rsem{\sigma^*\forall i\mathord:s. A'}{\relEnv{E}}\rho
    \end{equation}
    and we must show that $(x_1, x_2) \in \rsem{\forall
      i\mathord:s. A'}{\relEnv{E}}{(\rho \circ \sigma^*)}$. From
    (\ref{eq:tysubst-rel-forall1}) and the definition of substitution,
    we know that
    \begin{displaymath}
      \forall \rho' \in \extends{\rho}{i:s}.\ (x_1,x_2) \in \rsem{\sigma_s^*A'}{\relEnv{E}}\rho'
    \end{displaymath}
    By the induction hypothesis, we can deduce that
    \begin{equation}
      \label{eq:tysubst-rel-forall2}
      \forall \rho' \in \extends{\rho}{i:s}.\ (x_1,x_2) \in \rsem{A'}{\relEnv{E}}{(\rho' \circ \sigma_s^{*})}
    \end{equation}
    To show the required inclusion, we must show that for all $\rho_1
    \in \extends{\rho \circ \sigma^*}{i:s}$, it is the case that
    $(x_1,x_2) \in \rsem{A'}{\relEnv{E}}{\rho_1}$. We now make use of
    the pushout property of our family $\relEnv{E}$ of relation
    environments: we have a $\rho \in \relEnv{E}(\Delta)$ and $\rho_1
    \in \relEnv{E}(\Delta, i:s)$ such that $\rho_1 \circ \pi_{i:s} =
    \rho \circ \sigma^*$ (by the assumption that $\rho_1 \in
    \extends{\rho \circ \sigma^*}{i:s}$), so we can obtain a $\rho'
    \in \relEnv{E}(\Delta',i:s)$ such that $\rho' \circ \pi_{i:s} =
    \rho$ (so $\rho' \in \extends{\rho}{i:s}$), and $\rho' \circ
    \sigma^* = \rho_1$. Therefore we use
    (\ref{eq:tysubst-rel-forall2}) to deduce that $(x_1,x_2) \in
    \rsem{A'}{\relEnv{E}}{\rho_1}$, and the inclusion from
    left-to-right is shown.

    From right-to-left, we must now show
    (\ref{eq:tysubst-rel-forall2}) under the assumption that
    \begin{equation}
      \label{eq:tysubst-rel-forall3}
      \forall \rho_1 \in \extends{\rho \circ \sigma^*}{i:s}. (x_1,x_2) \in \rsem{A'}{\relEnv{E}}{\rho_1}.
    \end{equation}
    Given $\rho' \in \extends{\rho}{i:s}$, we let $\rho_1 = \rho'
    \circ \sigma^*$. Now, $\rho_1 \circ \pi_{i:s} = \rho' \circ
    \sigma^* \circ \pi_{i:s} = \rho' \circ \pi_{i:s} \circ \sigma_s^{*}
    = \rho \circ \sigma_s^{*}$. Thus $\rho_1 \in \extends{\rho \circ
      \sigma^*}{i:s}$ and we may use (\ref{eq:tysubst-rel-forall3}) to
    deduce that $(x_1,x_2) \in \rsem{A'}{\relEnv{E}}{(\rho' \circ \sigma_s^{*})}$,
    as required.
  \end{description}
  The second part of the lemma statement follows directly by induction
  on the derivation of $\Delta \vdash \Gamma \isCtxt$ and the first
  part. The step case of the induction is very similar to the
  \TirName{TyProd} case above.
\end{proof}

\begin{theorem}[Parametricity]
  If $\Delta; \Gamma \vdash M : A$, then for all $\rho \in
  \relEnv{E}(\Delta)$ and $\eta_1, \eta_2 \in \ctxtSem{\Gamma}$ such
  that $(\eta_1, \eta_2) \in \rsem{\Gamma}{\relEnv{E}}\rho$, we have
  $(\tmSem{M}\eta_1, \tmSem{M}\eta_2) \in \rsem{A}{\relEnv{E}}\rho$.
\end{theorem}

\begin{proof}
  By induction on the derivation of $\Delta; \Gamma \vdash M : A$. The
  three interesting cases follow:
  \begin{description}
  \item[Case \TirName{TyEq}] This case follows directly from
    \lemref{lem:tyeq-rel}.
  \item[Case \TirName{UnivAbs}] In this case, $M = \Lambda i.M'$ and
    $A = \forall i\mathord:s. A'$. We know from the induction
    hypothesis that for all $\rho' \in \relEnv{E}(\Delta, i:s)$ and
    $(\eta_1,\eta_2) \in \rsem{\pi_{i:s}^*\Gamma}{\relEnv{E}}\rho'$,
    we have $(\tmSem{M'}\eta_1,\tmSem{M'}\eta_2) \in
    \rsem{A'}{\relEnv{E}}\rho'$. We are given $\rho \in
    \relEnv{E}(\Delta)$, $(\eta_1,\eta_2) \in
    \rsem{\Gamma}{\relEnv{E}}\rho$ and $\rho'' \in
    \extends{\rho}{i:s}$. Since $\rho'' \circ \pi^*_{i:s} = \rho$, we
    have $(\eta_1,\eta_2) \in \rsem{\Gamma}{\relEnv{E}}\rho$ implies
    $(\eta_1,\eta_2) \in \rsem{\Gamma}{\relEnv{E}}{(\rho'' \circ
      \pi^*_{i:s})}$, and therefore $(\eta_1,\eta_2) \in
    \rsem{\pi_{i:s}^*\Gamma}\rho''$ by \lemref{lem:tysubst-rel}. So we
    can apply the induction hypothesis to get $(\tmSem{M'}\eta_1,
    \tmSem{M'}\eta_2) \in \rsem{A'}{\relEnv{E}}\rho''$, and thus
    $(\tmSem{\Lambda i.M'}\eta_1,\tmSem{\Lambda i.M'}\eta_2) \in
    \rsem{A'}{\relEnv{E}}\rho''$, by the definition of $\tmSem{\Lambda
      i. M'}$. Hence $(\tmSem{\Lambda i.M'}\eta_1,\tmSem{\Lambda
      i.M'}\eta_2) \in \rsem{\forall
      i\mathord:s. A'}{\relEnv{E}}\rho$, as required.
  \item[Case \TirName{UnivApp}] In this case, $M = M'[e]$ and $A =
    (\id_\Delta, e)^*A'$. By the induction hypothesis, and the
    definition of $\rsem{\forall i\mathord:s.A'}{\relEnv{E}}\rho$, we
    know that for all $\rho' \in \extends{\rho}{i:s}$,
    $(\tmSem{M'}\eta_1, \tmSem{M'}\eta_2) \in
    \rsem{A'}{\relEnv{E}}\rho'$. If we let $\rho' = \rho \circ
    (\id_\Delta, e)^*$, we know that $\rho' \in \extends{\rho}{i:s}$,
    because $\rho' \circ \pi^*_{i:s} = \rho \circ (\id_\Delta, e)^*
    \circ \pi^*_{i:s} = \rho$. Hence we may deduce that
    $(\tmSem{M'}\eta_1,\tmSem{M'}\eta_2) \in
    \rsem{A'}{\relEnv{E}}{(\rho \circ (\id_\Delta,e)^*)}$ and thence,
    by \lemref{lem:tysubst-rel}, conclude that $(\tmSem{M'}\eta_1,
    \tmSem{M'}\eta_2) \in \rsem{(\id_\Delta,e)^*A'}{\relEnv{E}}\rho$,
    as required.
  \end{description}
  The remaining cases are standard for proofs of the fundamental lemma
  of logical relations for simply-typed systems.
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Consequences of Parametricity}

We now give instances of our semantic framework for each of the three
examples from \autoref{sec:example-systems}. For each of the three
examples, we defined an indexing theory, a collection of primitive
types, and a collection of primitive operations $\Gamma_X$. Below, we
assign the ``obvious'' index-erasure semantics to each of the
primitive types and operations: so we have $\tyPrimSem{X}$ for each
primitive type $\tyPrimNm{X}$, and a $\eta_X \in \ctxtSem{\Gamma_X}$.

The key question we wish to answer below is whether there is a family
of sets of relation environments $\{\relEnv{E}_X(\Delta)\}_{\Delta}$
that satisfies the following completeness property identified by
Kennedy.
\begin{equation}\label{eq:kennedy-completeness}
  (\forall \Delta. \forall \rho \in \relEnv{E}'(\Delta). (\eta_X, \eta_X) \in \rsem{\Gamma_X}{\relEnv{E}'}{\rho}) \Leftrightarrow \relEnv{E}'\subseteq \relEnv{E}_X
\end{equation}
where the subset relation on families of sets of relation environments
is defined as $\relEnv{E}_1 \subseteq \relEnv{E}_2$ if $\forall
\Delta. \relEnv{E}_1(\Delta) \subseteq \relEnv{E}_2(\Delta)$.

Such a completeness result allows us to derive inexpressibility
results for a given instance of our general framework. Kennedy
demonstrates this for the units of measure system by showing that a
putative square root function of type $\forall u.\ \tyPrim{num}{u^2}
\to \tyPrim{num}{u}$ can only ever be the constantly zero function (or
non-terminating).

\subsection{Units of Measure}\label{sec:units-semantics}

For the units of measure example, we set $\tyPrimSem{num} =
\tyPrimSem{rational} = \mathbb{Q}$, the set of rational numbers. We
define $\eta_{\mathit{units}} \in \Gamma_{\mathit{units}}$ are defined
to be the standard arithmetical and comparison operations on rational
numbers, and $\mathit{toRat}$ and $\mathit{fromRat}$ are defined to be
the identity functions. The division function (of type $/ : \forall
u_1,u_2. \tyPrim{num}{u_1} \to \tyPrim{num}{u_2} \to
\tyPrim{num}{u_1u^{-1}_2} + 1$) returns $\mathrm{inr}(*)$ only when
its second argument is zero.

Kennedy defines the following family of sets of relational
environments. Note that, since we have assumed the abelian group
axioms, the set $\idxTms{\Delta}{\mathsf{unit}}$ of indexing
expressions quotiented by the equational theory, is an abelian group.
\begin{displaymath}
  \relEnv{E}_{\mathit{units}}(\Delta) = \left\{ \rho^{G,h} \sepbar
    \begin{array}{l}
      G\textrm{ is a subgroup of }\idxTms{\Delta}{\mathsf{unit}} \\
      h : G \to \mathbb{Q}^{>0} \\
      h\textrm{ is a group homomorphism}
    \end{array}
  \right\}
\end{displaymath}
where $\mathbb{Q}^{>0} = \{ q \in \mathbb{Q} \sepbar q > 0 \}$ and
\begin{displaymath}
  \rho^{G,h}_{\tyPrimNm{num}}(e) = \left\{
    \begin{array}{ll}
      \{(0,0)\} & \textrm{if }e \not\in G \\
      \{(r,h(e)r) \sepbar r \in \mathbb{Q} \} & \textrm{if }u \in G
    \end{array}
  \right.
\end{displaymath}

\begin{theorem}
  The family of sets of relational environments
  $\relEnv{E}_{\mathit{units}}$ satisfies the completeness property
  \hyperref[eq:kennedy-completeness]{(\ref*{eq:kennedy-completeness})}
  above. That is, for all $\relEnv{E}'$:
  \begin{displaymath}
    (\forall \Delta.\forall \rho \in \relEnv{E}'(\Delta). (\eta_{\mathit{units}}, \eta_{\mathit{units}}) \in \rsem{\Gamma_{\mathit{units}}}{\relEnv{E}'}{\rho}) \Leftrightarrow \relEnv{E}'\subseteq \relEnv{E}_{\mathit{units}}
  \end{displaymath}
\end{theorem}

\begin{proof}
  (Following Kennedy).  From right to left, we have to check that for
  each $\rho \in \relEnv{E}'(\Delta)$, where $\relEnv{E}' \subseteq
  \relEnv{E}_{\mathit{units}}$, that each of the semantic
  interpretations of the operations satisfies
  $(\eta_{\mathit{units}}(\mathit{op}),
  \eta_{\mathit{units}}(\mathit{op})) \in
  \rsem{\Gamma(\mathit{op})}{\relEnv{E}'}\rho$. For instance,
  multiplication has to satisfy: for all subgroups $G \subseteq
  \idxTms{\Delta,u_1,u_2}{\mathsf{unit}}$ and all group homomorphisms
  $h : G \to \mathbb{Q}^{>0}$, then $(q_1,q'_1) \in \rho^{G,h}(u_1)$
  and $(q_2,q'_2) \in \rho^{G,h}(u_2)$ implies that $(q_1q_2,q'_1q'_2)
  \in \rho^{G,h}(u_1u_2)$. There are four cases, depending on whether
  $u_1 \in G$ and whether $u_2 \in G$. If $u_1 \not\in G$, then $q_1 =
  q'_1 = 0$, so $q_1q_2 = 0$ and $q'_1q'_2 = 0$. Since $(0,0) \in
  \rho^{G,h}(u')$ for any $u'$, $G$ and $h$, we are done. If $u_1 \in
  G$ and $u_2 \in G$, then we need to show that $(q_1q_2,
  h(u_1)q_1h(u_2)q_2) \in \rho^{G,h}(u_1u_2)$. By $h$ being a
  homomorphism, we have $(q_1q_2, h(u_1)q_1h(u_2)q_2) = (q_1q_1,
  h(u_1u_2)q_1q_2)$, which is in $\rho^{G,h}(u_1u_2)$. The cases for
  the other operations are similar.

  From left to right, we have the following properties of any
  relational environment $\rho_{\tyPrimNm{num}} \in
  \relEnv{E}'(\Delta)$, derived from the hypothesis that all the
  operations in $\eta_{\mathit{units}}$ satisfy their types'
  relational semantics.
  \begin{enumerate}
  \item\label{item:obsv-poly} By the existence of the function
    $\mathit{toRat}$, the relation $\rho_{\tyPrimNm{num}}(1)$ is the
    identity relation.
  \item\label{item:zero-poly} For any unit expression $e$, $(0,0) \in
    \rho_{\tyPrimNm{num}}(e)$.
  \item \label{item:one-poly} $(1,1) \in \rho_{\tyPrimNm{num}}(1)$.
  \item \label{item:mult-poly} For any unit expressions $e_1,e_2$,
    such that $(q_1,q'_1) \in \rho_{\tyPrimNm{num}}(e_1)$ and
    $(q_2,q'_2) \in \rho_{\tyPrimNm{num}}(e_2)$, we have $(q_1q_2,
    q'_1q'_2) \in \rho_{\tyPrimNm{num}}(e_1e_2)$.
  \item\label{item:div-poly} For any unit expressions $e_1,e_2$, such
    that $(q_1,q'_1) \in \rho_{\tyPrimNm{num}}(e_1)$ and $(q_2,q'_2)
    \in \rho_{\tyPrimNm{num}}(e_2)$, we have that either $q_2 = q'_2 =
    0$, or we have that $(q_1/q_2,q'_1,q'_2) \in
    \rho_{\tyPrimNm{num}}(e_1e_2^{-1})$.
  \item\label{item:compare-poly} For any unit expression $e$, such
    that $(q_1,q'_1) \in \rho_{\tyPrimNm{num}}(e)$ and $(q_2,q'_2) \in
    \rho_{\tyPrimNm{num}}(e)$, we have $q_1 < q_2$ iff $q'_1 < q'_2$.
  \end{enumerate}
  We now show that if $(q,q') \in \rho_{\tyPrimNm{num}}(e)$ for some
  unit expression $e$, then either $q = q' = 0$, or $q' = rq$ for some
  $r \in \mathbb{Q}^{>0}$, determined by $e$. We know from
  \ref{item:zero-poly} above that $q = q' = 0$ is a possibility. Now
  consider what happens if $q \not= 0$: in this case, by
  \ref{item:zero-poly} and \ref{item:compare-poly}, we know that $0 <
  q$ iff $0 < q'$, so $q' \not= 0$, and $q'$ has the same sign as
  $q$. So $q/q'$ exists and is in $\mathbb{Q}^{>0}$. Hence $q = rq'$
  for $r = q/q'$. So now we know that if $(q,q') \in
  \rho_{\tyPrimNm{num}}(e)$, and $q \not= 0$ or $q' \not= 0$ then
  there exists an $r$ such that $q = rq'$.

  We now show that the unit expression $e$ determines the value of
  $r$. Assume that we have $(q_1,r_1q_1) \in \rho_{\tyPrimNm{num}}(e)$
  and $(q_2,r_2q_2) \in \rho_{\tyPrimNm{num}}(e)$. By
  \ref{item:div-poly}, we know that $(q_1/q_2, (r_1q_1)/(r_2q_2)) \in
  \rho_{\tyPrimNm{num}}(1)$. By \ref{item:obsv-poly},
  $\rho_{\tyPrimNm{num}}(1)$ is the equality relation, so we can
  deduce that $r_1 = r_2$.

  Now let $G$ be the subgroup of $\idxTms{\Delta}{\mathsf{unit}}$ such
  that $e \in G$ implies that $\rho_{\tyPrimNm{num}}(e) \not=
  \{(0,0)\}$. By the argument above, for each $e \in G$, there is a
  unique $r \in \mathbb{Q}^{>0}$ such that $\rho_{\tyPrimNm{num}}(e) =
  \{ (q,rq) \sepbar q \in \mathbb{Q} \}$. Thus there is a function $h
  : G \to \mathbb{Q}^{>0}$. By \ref{item:one-poly} and
  \ref{item:mult-poly}, $h$ is a group homomorphism. Thus we have
  shown that $\rho_{\tyPrimNm{num}}$ has the form of
  $\rho^{G,h}_{\tyPrimNm{num}}$ for some $G$ and $h$. Since
  $\rho_{\tyPrimNm{num}}$ was an arbitrary element of
  $\relEnv{E}'(\Delta)$, and $\Delta$ was arbitrary, we have shown
  that $\relEnv{E}' \subseteq \relEnv{E}_{\mathit{units}}$.
\end{proof}

Some notes towards a generalisation:
\begin{itemize}
\item By inspecting Kennedy's proof, we can see that the operations of
  addition and subtraction do not play any role, save for an
  obligation to prove that they satisfy the relational semantics of
  their types. This follows just by distributivity of addition over
  multiplication.
\item Kennedy's proof does not rely on any particular features of
  $\mathbb{Q}$ other than the fact that it is an ordered field. By
  inspecting the proof, it is possible to see that if we remove the
  comparison operation $< : \forall u. \tyPrim{num}{u} \to
  \tyPrim{num}{u} \to \tyPrimNm{bool}$ from $\Gamma_{\mathit{units}}$,
  then the appropriate family of sets of relational environments uses
  homomorphisms into the set of non-zero rationals:
  \begin{displaymath}
    \begin{array}{l}
      \relEnv{E}_{\mathit{units}\backslash\{<\}}(\Delta) = \\
      \quad\left\{ \rho^{G,h} \sepbar
        \begin{array}{l}
          G\textrm{ is a subgroup of }\idxTms{\Delta}{\mathsf{unit}} \\
          h : G \to \mathbb{Q}^{\not=0} \\
          h\textrm{ is a group homomorphism}
        \end{array}
      \right\}
    \end{array}
  \end{displaymath}
  To complete the step in the proof where the comparison operation was
  used, we use the division operation to show that if $(q,q') \in
  \rho_{\tyPrimNm{num}}(e)$ for some $e$, and $q \not= 0$, then $q'
  \not= 0$ (but they need not necessarily have the same sign).

  Just as Kennedy's proof generalises to an arbitrary ordered field,
  if we remove the comparison operation we can generalise to an
  arbitrary field as the underlying semantics of $\tyPrimNm{num}$ and
  $\tyPrimNm{rational}$.
\end{itemize}

\subsection{Euclidean Plane Geometry}\label{sec:2d-semantics}

We set $\tyPrimSem{vec} = \mathbb{R}^2$, and $\tyPrimSem{real} =
\mathbb{R}$. The semantic interpretation $\eta_{\mathit{2D}}$ of the
operations in $\Gamma_{\mathit{2D}}$ consists of the standard vector
zero, addition, negation and scaling in $\mathbb{R}^2$, along with
projections to interpret $\mathit{getX}$ and $\mathit{getY}$, and
pairing to interpret $\mathit{vec}$.

Let
\begin{displaymath}
  \begin{array}{l}
    \relEnv{E}_{\mathit{2D}}(\Delta) = \\
    \quad\left\{ \rho^{G,h} \sepbar
      \begin{array}{l}
        G\textrm{ is a subgroup of }\idxTms{\Delta}{\mathsf{translation}} \\
        h : G \to \mathbb{R}^2 \\
        h\textrm{ is a group homomorphism}
      \end{array}
    \right\}
  \end{array}
\end{displaymath}
where
\begin{displaymath}
  \rho^{G,h}_{\tyPrimNm{vec}}(t) = \left\{
    \begin{array}{ll}
      \{\} & \textrm{if }t \not\in G \\
      \{(v,h(t) + v) \sepbar v \in \mathbb{R}^2 \} & \textrm{if }t \in G
    \end{array}
  \right.
\end{displaymath}
Note that, unlike the units of measure example above, the pair $(0,0)$
need not appear in every relation. This is because we do not have a
translation polymorphic constant like $0 : \forall u. \tyPrim{num}{u}$
in the units of measure example.

\begin{theorem}
  The family of sets of relational environments
  $\relEnv{E}_{\mathit{units}}$ satisfies the completeness property
  \hyperref[eq:kennedy-completeness]{(\ref*{eq:kennedy-completeness})}
  above. That is, for all $\relEnv{E}'$:
  \begin{displaymath}
    (\forall \Delta.\forall \rho \in \relEnv{E}'(\Delta). (\eta_{\mathit{2D}}, \eta_{\mathit{2D}}) \in \rsem{\Gamma_{\mathit{2D}}}{\relEnv{E}'}{\rho}) \Leftrightarrow \relEnv{E}'\subseteq \relEnv{E}_{\mathit{2D}}
  \end{displaymath}
\end{theorem}

\begin{proof}
  From right to left, we must check that each operation satisfies the
  relational interpretation of its type. This is very similar to the
  case for the units of measure example above.

  From left to right, we have the following properties of any
  relational environment $\rho_{\tyPrimNm{vec}} \in
  \relEnv{E}'(\Delta)$, derived from the hypothesis that all the
  operations in $\eta_{\mathit{2D}}$ satisfy their types'
  relational semantics.
  \begin{enumerate}
  \item\label{item:obsv-vec-poly} By the existence of the functions
    $\mathit{getX}$ and $\mathit{getY}$, the relation
    $\rho_{\tyPrimNm{vec}}(0)$ is the identity relation.
  \item \label{item:zero-vec-poly} $(0,0) \in \rho_{\tyPrimNm{vec}}(0)$.
  \item \label{item:add-vec-poly} For any translation expressions $t_1,t_2$,
    such that $(v_1,v'_1) \in \rho_{\tyPrimNm{vec}}(t_1)$ and
    $(v_2,v'_2) \in \rho_{\tyPrimNm{vec}}(t_2)$, we have $(v_1 + v_2,
    v'_1 + v'_2) \in \rho_{\tyPrimNm{vec}}(t_1 + t_2)$.
  \item\label{item:neg-vec-poly} For any translation expression $t$,
    such that $(v,v') \in \rho_{\tyPrimNm{vec}}(t)$, we have that
    $(-v,-v') \in \rho_{\tyPrimNm{vec}}(-t)$.
  \end{enumerate}
  We now show that if $(v,v') \in \rho_{\tyPrimNm{vec}}(t)$ for some
  translation expression $t$, then $v' = w + v$ for some $w \in
  \mathbb{R}^2$, where $w$ is determined by $t$. If we are given
  $(v,v') \in \rho_{\tyPrimNm{vec}}(t)$, then we can set $w = v' -
  v$. This is uniquely determined by $t$: if we have $(v, w + v) \in
  \rho_{\tyPrimNm{vec}}(t)$ and $(v, w' + v) \in
  \rho_{\tyPrimNm{vec}}(t)$, then by \ref{item:add-vec-poly} and
  \ref{item:neg-vec-poly}, we have $(v - v, (w + v) - (w' + v)) \in
  \rho_{\tyPrimNm{vec}}(0)$. By \ref{item:obsv-vec-poly}, we know that
  $\rho_{\tyPrimNm{vec}}(0)$ is the identity relation, so we can
  deduce that $w = w'$.

  Now define $G \subseteq \idxTms{\Delta}{\mathsf{translation}}$ to
  have $t \in G$ if $\rho_{\tyPrimNm{vec}}(t) \not= \{\}$. Since the
  translation factor $w$ is determined by $t$, we can define a
  function $h : G \to \mathbb{R}^2$. By \ref{item:zero-vec-poly} and
  \ref{item:add-vec-poly}, $h$ is a group homomorphism, and $(v,v')
  \in \rho_{\tyPrimNm{vec}}$ iff $v = h(t) + v'$. Thus
  $\rho_{\tyPrimNm{vec}}$ is of the form
  $\rho^{G,h}_{\tyPrimNm{vec}}$, as required.
\end{proof}

Some more notes:
\begin{enumerate}
\item The proof is slightly simpler than the case for the units of
  measure example above because the underlying semantics of
  $\tyPrimNm{vec}$ forms an abelian group, so we can just use inverses
  to determine the difference factor $w$, and we don't have to deal
  with the possibility of division by zero.
\item The proof above should generalise to any abelian group.
\item Generalising to non-abelian groups does not look
  straightforward: the step that shows that the translation factor $w$
  is uniquely determined by the translation expression $t$ fails. We
  end up with
  \begin{displaymath}
    0 = w + v + (-w') + (-v)
  \end{displaymath}
  from which it is not possible to conclude that $w = w'$. (Maybe
  something using normal subgroups would work?)
\item A slightly different example is obtained by considering
  rotations rather than translations (we consider rotations as an
  additive abelian group). In this case, we could have the following
  typed operations:
  \begin{eqnarray*}
    0 & : & \forall r.\ \tyPrim{vec}{r} \\
    + & : & \forall r.\ \tyPrim{vec}{r} \to \tyPrim{vec}{r} \to \tyPrim{vec}{r} \\
    - & : & \forall r.\ \tyPrim{vec}{r} \to \tyPrim{vec}{r} \\
    * & : & \forall r.\ \tyPrimNm{real} \to \tyPrim{vec}{r} \to \tyPrim{vec}{r} \\
    \mathit{norm} & : & \forall r. \tyPrim{vec}{r} \to \tyPrimNm{real} \\
    \mathit{angleOf} & : & \forall r. \tyPrim{vec}{r} \to \tyPrim{rot}{r} + 1 \\
    \mathit{rotateBy} & : & \forall r_1 r_2. \tyPrim{vec}{r_1} \to \tyPrim{rot}{r_2} \to \tyPrim{vec}{r_1 + r_2} \\
    0_{\mathit{rot}} & : & \tyPrim{rot}{0} \\
    +_{\mathit{rot}} & : & \forall r_1 r_2. \tyPrim{rot}{r_1} \to \tyPrim{rot}{r_2} \to \tyPrim{rot}{r_1 + r_2} \\
    -_{\mathit{rot}} & : & \forall r. \tyPrim{rot}{r} \to \tyPrim{rot}{-r}
  \end{eqnarray*}
  where $\tyPrimSem{vec} = \mathbb{R}^2$, as before, and
  $\tyPrimSem{rot} = \mathrm{SO}(2)$, the group of rotations of the
  plane. The operation $\mathit{angleOf}$ is intended to return
  $\mathrm{inr}(*)$ when the provided vector is zero.

  In this case, rotations form an abelian group, so we can re-use the
  proof above to give a family of sets of relational environments that
  is complete for the group operations on rotations. The fact that
  rotations are linear admits the typing of the first four
  operations. The existence of the $\mathit{angleOf}$ and
  $\mathit{rotateBy}$ functions allow us to determine ``rotation
  factors'' between arbitrary pairs of vectors.

  I conjecture that the following definition of
  $\relEnv{E}_{\mathit{2Drot}}$ satisfies the completeness criterion,
  with the standard interpretation of the operations above.
  \begin{displaymath}
    \begin{array}{l}
      \relEnv{E}_{\mathit{2Drot}}(\Delta) = \\
      \quad\left\{ \rho^{G,h} \sepbar
        \begin{array}{l}
          G\textrm{ is a subgroup of }\idxTms{\Delta}{\mathsf{rotation}} \\
          h : G \to \mathrm{SO}(2) \\
          h\textrm{ is a group homomorphism}
        \end{array}
      \right\}
    \end{array}
  \end{displaymath}
  where
  \begin{displaymath}
    \rho^{G,h}_{\tyPrimNm{vec}}(r) = \left\{
      \begin{array}{ll}
        \{(0,0)\} & \textrm{if }t \not\in G \\
        \{(v,h(r) v) \sepbar v \in \mathbb{R}^2 \} & \textrm{if }t \in G
      \end{array}
    \right.
  \end{displaymath}
  and
  \begin{displaymath}
    \rho^{G,h}_{\tyPrimNm{rot}}(r) = \left\{
      \begin{array}{ll}
        \{\} & \textrm{if }t \not\in G \\
        \{(s,h(r) s) \sepbar s \in \mathrm{SO}(2) \} & \textrm{if }t \in G
      \end{array}
    \right.
  \end{displaymath}
\end{enumerate}

\subsection{Security Typing}\label{sec:sec-semantics}

In this case, we let $\tyPrimSem{T} = \{*\}$, and the operations
$\mathit{proj}$ and $\mathit{combine}$ are given the only possible
interpretations.

I conjecture that the follow definition works:
\begin{displaymath}
  \begin{array}{l}
    \relEnv{E}_{\mathit{sec}}(\Delta) = \\
    \quad\left\{ \rho^{h} \sepbar
      \begin{array}{l}
        h : \idxTms{\Delta}{\mathsf{principal}} \to \{\top,\bot\} \\
        h\textrm{ is a boolean algebra homomorphism}
      \end{array}
    \right\}
  \end{array}
\end{displaymath}
where
\begin{displaymath}
  \rho^{h}_{\tyPrimNm{T}}(p) = \left\{
    \begin{array}{ll}
      \{\} & \textrm{if }h(p) = \bot \\
      \{(*,*) \} & \textrm{if }h(p) = \top
    \end{array}
  \right.
\end{displaymath}

One can compare this definition to the previous ones by considering
the boolean algebra homomorphism as defining a sub-boolean algebra of
$\idxTms{\Delta}{\mathsf{principal}}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensions}

\subsection{Inductive Types}

\subsection{Type Operators}

\subsection{Size indexing and Combinatorial Species}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plainnat}
\bibliography{paper}


\end{document}
