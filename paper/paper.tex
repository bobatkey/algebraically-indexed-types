\documentclass[preprint]{sigplanconf}

\usepackage[usenames]{color}
\definecolor{citationcolour}{rgb}{0,0.4,0.2}
\definecolor{linkcolour}{rgb}{0,0,0.8}
\usepackage{hyperref}
\hypersetup{colorlinks=true,
            urlcolor=linkcolour,
            linkcolor=linkcolour,
            citecolor=citationcolour,
            pdftitle=Abstraction and Invariance for Algebraically-Indexed Types,
            pdfauthor={Robert Atkey, Patricia Johann, Andrew Kennedy},
            pdfkeywords={}}  
\def\sectionautorefname{Section}
\def\subsectionautorefname{Section}
\def\subsubsectionautorefname{Section}

\title{Abstraction and Invariance for Algebraically Indexed Types}

\authorinfo{Robert Atkey\and Patricia Johann}
           {University of Strathclyde}
           {$\{$Robert.Atkey,Patricia.Johann$\}$@strath.ac.uk}

\authorinfo{Andrew Kennedy}
           {Microsoft Research Cambridge}
           {akenn@microsoft.com}

\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}

\newcommand{\todo}[1]{[\textbf{TODO}: #1]}

\newcommand{\abs}[1]{\lvert #1 \rvert}

\newcommand{\GL}[1]{\mathrm{GL}_#1}
\newcommand{\SynGL}[1]{\mathsf{GL}_#1}
\newcommand{\SE}[1]{\mathsf{SE}_#1}
\newcommand{\SynSE}[1]{\mathsf{SE}_#1}
\newcommand{\Orth}[1]{\mathrm{O}_#1}
\newcommand{\SynOrth}[1]{\mathsf{O}_#1}
\newcommand{\Transl}[1]{\mathrm{T}_#1}
\newcommand{\SynTransl}[1]{\mathsf{T}_#1}
\newcommand{\Scal}{\mathrm{Scal}}
\newcommand{\SynScal}{\mathsf{Scal}}

\newcommand{\sepbar}{\mathrel|}

\newcommand{\Rel}{\mathrm{Rel}}
\newcommand{\relArrow}{\mathrel{\widehat\to}}
\newcommand{\relTimes}{\mathrel{\widehat\times}}
\newcommand{\relSum}{\mathrel{\widehat+}}
\newcommand{\Eq}{\mathrm{Eq}}

\newcommand{\setOfIntegers}{\mathbb{Z}}
\newcommand{\setOfBooleans}{\{\tmTT, \tmFF\}}

\newcommand{\id}{\mathrm{id}}

\newcommand{\SortSet}{\mathit{Sort}}
\newcommand{\IndexOpSet}{\mathit{IndexOp}}
\newcommand{\PrimTypeSet}{\mathit{PrimType}}
\newcommand{\IndexAxiomSet}{\mathit{IndexAx}}

\newcommand{\indexOp}[1]{\textup{\texttt{#1}}}
\newcommand{\idxTms}[2]{\mathrm{IdxTm}(#1 \vdash #2)}
\newcommand{\idxTmAS}[1]{\mathrm{IdxTm}(#1)}

\newcommand{\tyInt}{\texttt{int}}
\newcommand{\tyBool}{\texttt{bool}}
\newcommand{\tyUnit}{\texttt{unit}}
\newcommand{\tyReal}{\texttt{real}}
\newcommand{\tyPrim}[2]{\textup{\texttt{#1}}\langle #2 \rangle}
\newcommand{\tyPrimNm}[1]{\textup{\texttt{#1}}}
\newcommand{\primTyArity}{\mathrm{tyArity}}
\newcommand{\indexOpArity}{\mathrm{opArity}}

\newcommand{\tyArr}{\to}
\newcommand{\tyProduct}{\times}
\newcommand{\tyX}[1]{\texttt{X}\langle #1 \rangle}
\newcommand{\isType}{\textup{\textsf{ type}}}
\newcommand{\isCtxt}{\textup{\textsf{ ctxt}}}
\newcommand{\Ty}{\textsf{Ty}}
\newcommand{\ty}{\textsf{ty}}

\newcommand{\tmTT}{\texttt{tt}}
\newcommand{\tmFF}{\texttt{ff}}

\newcommand{\relEnv}[1]{\mathcal{#1}}
%\newcommand{\tySem}[1]{\llbracket #1 \rrbracket^{\mathcal{T}}}
%\newcommand{\ctxtSem}[1]{\llbracket #1 \rrbracket^{\mathcal{C}}}
%\newcommand{\tmSem}[1]{\llbracket #1 \rrbracket^{\mathit{tm}}}
%\newcommand{\tyPrimSem}[1]{\llbracket #1 \rrbracket^{\mathcal{T}_0}}
\newcommand{\tySem}[1]{\left| #1\right|}
\newcommand{\ctxtSem}[1]{\left| #1\right|}
\newcommand{\tmSem}[1]{\left| #1\right|}
\newcommand{\tyPrimSem}[1]{\left| #1\right|}
\newcommand{\rsem}[3]{\llbracket #1 \rrbracket^{\mathcal{#2}}_{\mathcal{#3}}}
\newcommand{\extends}[2]{\mathsf{ext}(#1,#2)}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newcommand{\lemref}[1]{\hyperref[#1]{Lemma \ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem \ref*{#1}}}
\newcommand{\defref}[1]{\hyperref[#1]{Definition \ref*{#1}}}
\newcommand{\propref}[1]{\hyperref[#1]{Proposition \ref*{#1}}}
\newcommand{\corref}[1]{\hyperref[#1]{Corollary \ref*{#1}}}
\newcommand{\conref}[1]{\hyperref[#1]{Conjecture \ref*{#1}}}
\newcommand{\exref}[1]{\hyperref[#1]{Example \ref*{#1}}}
\newcommand{\statementref}[1]{\hyperref[#1]{Statement \ref*{#1}}}

\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\isDefinedAs}{\stackrel{\mathit{def}}=}

\newcommand{\Geom}{\mathit{2D}}

\newtheoremstyle{examplestyle}
  {\topsep}  % space above
  {\topsep}  % space below
  {\normalfont}% name of font to use in the body of the theorem
  {0em}% measure of space to indent
  {\bfseries}% name of head font
  {.}% punctuation between head and body
  {5pt plus 1pt minus 1pt}% space after theorem head; " " = normal interword space
  {}% Manually specify head
\theoremstyle{examplestyle}
\newtheorem{example}{Example}
\newtheorem*{example*}{Example}

\newtheoremstyle{restatementstyle}
  {\topsep}  % space above
  {\topsep}  % space below
  {\itshape}% name of font to use in the body of the theorem
  {0em}% measure of space to indent
  {\bfseries}% name of head font
  {.}% punctuation between head and body
  {5pt plus 1pt minus 1pt}% space after theorem head; " " = normal interword space
  {\thmname{#1} \thmnote{(Restatement of #3)}}% Manually specify head
\theoremstyle{restatementstyle}
\newtheorem{restateLemma}{Lemma}
\newtheorem{restateTheorem}{Theorem}

\newcommand{\fixme}[1]{\textbf{FIXME: #1}}

\begin{document}

\maketitle

\begin{abstract}
  Reynolds' relational parametricity provides a powerful way to reason
  about programs in terms of invariance under changes of data
  representation. A dazzling array of applications of Reynolds' theory
  exists, exploiting invariance to yield ``free theorems'',
  uninhabitation results, and encodings of algebraic datatypes.
  Outside computer science, invariance is a common theme running
  through many areas of mathematics and physics. For example, the area of
  a triangle is unaltered by rotation or flipping. If we scale a
  triangle, then we scale its area, maintaining an invariant
  relationship between the two. The transformations under which
  properties are invariant are often organised into groups, with the
  algebraic structure reflecting the composability and invertibility
  of transformations.

  In this paper, we investigate programming languages whose types are
  indexed by algebraic structures such as groups of geometric
  transformations. Other examples include types indexed by
  principals--for information flow security--and types indexed by
  distances--for analysis of analytic uniform continuity
  properties. Following Reynolds, we prove a general abstraction
  theorem that covers all these instances. Consequences of our
  abstraction theorem include free theorems expressing invariance
  properties of programs, type isomorphisms based on invariance
  properties, and non-definability results indicating when certain
  algebraically indexed types are uninhabited or only inhabited by
  trivial programs.  Our results have been fully formalised in Coq.
\end{abstract}

\category{D.1.1}{Programming techniques}{Applicative (functional)
  programming} \category{D.2.4}{Software Engineering}{Software/Program
  Verification} \category{D.3.3}{Programming Languages}{Language
  Constructs and Features---Data types and structures}

\terms
  Languages, Theory, Types

\keywords parametricity, units of measure, dimensional analysis,
invariance, computational geometry, information flow, metric types, uniform continuity

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{section-introduction.tex}
\input{geometry-twocolumn.tex}
\input{section-general-framework.tex}
\input{section-instantiations.tex}
\input{section-monoid.tex}
\input{section-info-flow.tex}
%\input{section-singleton.tex}
\input{section-metric.tex}
\input{section-discussion.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{thebibliography}{12}
\softraggedright

\bibitem{abadi99core} 
M. Abadi, A. Banerjee, N. Heintze, and J. G. Riecke. A Core Calculus
of Dependency. Proceedings, POPL, pp.147-160, 1999.

\bibitem{syntaxforfree}
R. Atkey.  Syntax for Free: Representing Syntax with Binding Using
Parametricity.  Proceedings, Typed Lambda Calculi and Applications,
pp. 35-49, 2009.

\bibitem{TypedSyntax}
N.~Benton, C.-K.~Hur, A.~J.~Kennedy, C.~McBride.
Strongly Typed Term Representations in {Coq}.
{\em Journal of Automated Reasoning} 49(2), pp. 141-159, 2012.

\bibitem{benton06reading}
N.~Benton, A.~Kennedy, M.~Hofmann, L.~Beringer.
Reading, Writing and Relations.
Proceedings, Asian Symposium on Programming Languages and Systems,
pp. 114-130, 2006.

\bibitem{bernardy12proofs} 
J.-P.~Bernardy, P.~Jansson, R.~Paterson.
Proofs for Free: Parametricity for Dependent Types.
{\em Journal of Functional Programming} 22(2), pp. 107-152, 2012.

\bibitem{Cardelli}
L.~Cardelli, P.~Gardner.
Processes in Space.
{\em Programs, Proofs, Processes}: Proc, 6th Conference on Computability in Europe, pp 78-87, LNCS vol. 6158, 2010.

\bibitem{CGAL}
Computational Geometry Algorithms Library (CGAL): User and Reference
Manual.  Available at {\tt http://www.cgal.org}.

\bibitem{chaudhuri10continuity}
S. Chaudhuri, S. Gulwani, and R. Lublinerman.  Continuity Analysis of
Programs.  Proceedings, POPL, pp. 57-70, 2010.

\bibitem{gallier11geometric}
J. Gallier. {\em Geometric Methods and Applications For Computer
Science and Engineering}. Springer, 2011.

\bibitem{harrison09without}
J.~Harrison.
Without Loss of Generality.
Proceedings, Theorem Proving in Higher Order Logics,
pp. 43-59, 2009.

\bibitem{hofmann08correctness}
M.~Hofmann. Correctness of Effect-based Program
Transformations. Formal Logical Methods for System Security and
Correctness, pp. 149-173, 2008.

\bibitem{jones95functional}
M.~P.~Jones.  Functional Programming with Overloading and Higher-Order
Polymorphism. Proceedings, Advanced Functional Programming,
pp. 97-136, 1995.

\bibitem{kennedy97relational} 
A.~Kennedy. Relational Parametricity and Units of Measure.
Proceedings, POPL, pp. 442-455, 1997.

\bibitem{CFGADT}
S.~Mann, N.~Litke, T.~DeRose.  A Coordinate Free Geometry {ADT}.
Technical Report CS-97-15, University of Waterloo, 1997.

\bibitem{PittsAM:parpoe}
A.~M.~Pitts.  Parametric Polymorphism and Operational Equivalence.
{\em Mathematical Structures in Computer Science} 10(3), pp. 321-359,
2000.

\bibitem{reed10distance}
J.~Reed and B.~C.~Pierce.  Distance Makes the Types Grow Stronger.
Proceedings, ICFP, pp. 157-169, 2010.

\bibitem{reynolds83types}
J.~C.~Reynolds. Types, Abstraction and Parametric Polymorphism.
{\em Information Processing} 83, pp. 513-523, 1983.

\bibitem{sabelfeld01per} 
A.~Sabelfeld and D.~Sands.  A PER Model of Secure Information Flow in
Sequential Programs.  {\em Higher-Order and Symbolic Computation} 14
(1), pp. 59-91, 2001.

\bibitem{tse04translating}
S.~Tse and S.~Zdancewic.  Translating Dependency into Parametricity.
Proceedings, ICFP,  pp.
115-125, 2004.

\bibitem{wadler89theorems}
P.~Wadler.  Theorems for Free!.  Proceedings, International Conference
on Functional Programming Languages and Computer Architecture,
pp. 347-359, 1989.

\end{thebibliography}

%\bibliographystyle{plainnat}
%\renewcommand{\bibfont}{\normalsize}
%\bibliography{paper}

% \newpage
% \appendix

% \input{appendix-proofs.tex}

\end{document}
