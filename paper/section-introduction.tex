\section{Introduction}
\label{sec:introduction}
The best way we know of describing the semantics of parametric
polymorphism is \emph{relational parametricity}, whose central result
is Reynolds' Abstraction Theorem~\cite{reynolds83types}. Its striking
consequences include the well-known ``theorems for free'' for
polymorphic types~\cite{wadler89theorems}, non-inhabitation results, and precise
correspondences between System F encodings and algebraic datatypes~\cite{PittsAM:parpoe},
abstract data types, and, most recently, higher-order encodings of
binder syntax~\cite{syntaxforfree}.

Relational parametricity is in essence a principle of
\emph{invariance}: the behaviour of polymorphic code is invariant
under changes to data representation. Invariance results also abound in
mathematics and physics. The area of a triangle is invariant with
respect to isometries of the Euclidean plane; the determinant of a
matrix is invariant under changes of basis; and Newton's laws are the
same in all inertial frames. Typically, transformations in mathematics
and physics have interesting structure; for example, translations in
the Euclidean plane form an Abelian group.

%Types express properties of programs. The statement $\mathit{b}: \tyBool$ tells
%us that $\mathit{b}$ has value $\mathtt{true}$ or $\mathtt{false}$;
%the statement $\mathit{pos}:\tyReal\tyProduct\tyReal$ says that
%$\mathit{pos}$ is a pair whose components are real numbers. More interestingly,
%the statement $\mathit{f} : \forall X. \tyPrim{list}X\tyArr\tyPrim{list}X$ tells us that
%if we apply $\mathit{f}$ to a list whose elements satisfy some property $\psi$, 
%then the result is a list whose elements also satisfy $\psi$.

%Unary predicates only go so far, and for polymorphic types
%particularly do not express everything that follows from possessing that type. 
%Imagine a function $\mathit{oddRev}$ that reverses any list whose first element
%is an odd number, otherwise behaving as the identity. It certainly
%preserves properties of the elements -- but truly parametric
%polymorphism should tell us more.

%To obtain stronger properties we must \emph{relate} multiple
%executions of the same code. The statement $\mathit{f}:\forall
%X. \tyPrim{list}X\tyArr\tyPrim{list}X$ then says that any change in
%representation of the list elements supplied to $\mathit{f}$ is
%reflected in the elements in the result.  Formally, for any function
%$g$, we have $\mathit{f}(\mathrm{map}\:\mathit{g}\:\mathit{x}) =
%\mathrm{map}\:\mathit{g}\:(\mathit{f}\:\mathit{x})$.  This is the
%essence of \emph{relational parametricity} as formulated by
%Reynolds~\cite{reynolds83types}. Its consequences are striking.  It
%immediately tells us that $\mathit{oddRev}$ cannot be given a
%polymorphic type: simply consider the change-of-representation given
%by $\lambda x. x+1$.  But more profoundly it can be used to prove blah
%blah (initial algebras, term reps, non-inhabitation, etc.).

Inspired by this connection, we study relational parametricity for
types that are \emph{indexed} by attributes that themselves have
algebraic structure.  For example, in computational geometry, points
in 2-space can be indexed by a co-ordinate frame; in physical
modelling, quantities are indexed by units-of-measure; in
information-flow security, computations are indexed by principals.
Types that are polymorphic over such indices induce invariance
properties.  

A function that computes the area of a triangle might
have simple type
\[
\mathit{areaTri} : \tyPrimNm{vec}\times\tyPrimNm{vec}\times\tyPrimNm{vec}\tyArr\tyReal
\]
but instead we can assign it a polymorphic type
\[
\mathrm{areaTri} : \forall\alpha\mathord:\SynTransl{2}.
  \tyPrim{vec}{\alpha} \times \tyPrim{vec}{\alpha} \times \tyPrim{vec}{\alpha} \to \tyReal \\
\]
in which the index $\alpha$ can be thought of as a `translation frame' that is
preserved by the vector arguments, from which we can deduce that
\[
\mathrm{areaTri}\;(t + v_1, t + v_2, t + v_3) = 
\mathrm{areaTri}\;(v_1, v_2, v_3)
\]
for any translation $t\in\Transl{2}$.

In more complex examples the invariants \emph{compose} in various
ways; moreover, the compositions satisfy algebraic laws. Consider a function
that computes the area of a circle given its radius; by ascribing it
the polymorphic type
\[
\mathrm{areaCircle} : \forall\alpha\mathord:\SynScal.\tyPrim{real}{\alpha}\to
\tyPrim{real}{\alpha\cdot\alpha}
\]
we have captured that its area varies as the square of its radius, that is, for any $s>0$,
\[
\mathrm{areaCircle}\;(s\cdot r) = s^2\cdot \mathrm{areaCircle}\;r.
\]
Here $\alpha$ can be interpreted as the \emph{units} of the argument to
$\mathrm{areaCircle}$, and `$\cdot$' composes units by forming their
product. To complete the system, we would add an inverse operation and
identity unit, together with the algebraic laws of an Abelian group,
permitting, for example, the identification of
$\tyPrim{real}{\alpha\cdot\alpha^{-1}}$ with $\tyPrim{real}{1}$.

In his original paper, Reynolds asserted that ``type structure is a
syntactic discipline for enforcing levels of abstraction''. 
We see something analogous here: supposing that all primitive operations are
given types that reflect their behaviour under translation, there is no way
to `break' this property, for example, for $\mathrm{areaTri}$ to depend
on the actual coordinates of its inputs. In fact, through types alone we can
derive so-called \emph{coordinate-free} geometry. 

The invariance properties listed above can be seen as `theorems for
free'~\cite{wadler89theorems} obtained from types alone. We can
further observe that the abstraction afforded by polymorphic indexed
types induces interesting type \emph{isomorphisms}.  The type of
$\mathrm{areaCircle}$ above is in fact isomorphic to
$\tyPrim{real}{1}$, that is, a dimensionless constant. A moment's
thought reveals why: what possible unary functions can be constructed whose
outputs scale as the square of the scaling of their inputs? Answer:
just those functions of the form~$\lambda x. k x^2$ for some constant~$k$.
(In this case, of course, we expect that~$k = \pi$.)




% Possible angles of attack:
% \begin{itemize}
% \item Parametric polymorphic types allow us to prevent
%   over-specification of the behaviour of programs. For instance, the
%   type $\forall \alpha. [\alpha] \to [\alpha]$ is a generalisation of
%   the types $[\mathsf{int}] \to [\mathsf{int}]$ and $[\mathsf{char}]
%   \to [\mathsf{char}]$. Either of the latter two types over-specify
%   the behaviour of the function.
% \item There are other cases of programs that are over-specified. The
%   leading example we just below is of geometric programs that
%   manipulate coordinate data. Often, programs that manipulate
%   coordinate data are insensitive to geometric transformations. For
%   example, a program that computes the area of a triangle described by
%   three points is insensitive to translations or rotations applied to
%   all three points.
% \item 
% \end{itemize}

% There are three main points to get across:
% \begin{enumerate}
% \item Why algebraically indexed types?
% \item Why relational parametricity?
% \item Why study them together?
% \end{enumerate}

Key lessons:

\paragraph{Relational meanings are induced by indexes}

\paragraph{Indexes can usefully have algebraic structure}

\paragraph{Relational meanings can be non-compositional}

\subsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item Formulation of a general class of type systems that can either
  be used as programming languages in their own right, or as the
  targets of type-based analyses.
\item A collection of compelling examples of algebraically indexed
  types, including a novel type system for geometry, a refined type
  system for information flow, based on logic, and a simple type
  system for basic continuity analysis.
\item Deduction of useful free theorems in each of our main examples.x
\item A refined relational interpretation in order to derive
  non-definability results. Fixing a minor problem in Kennedy's work.
\end{itemize}

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
