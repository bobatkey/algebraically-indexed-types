\section{Introduction}
\label{sec:introduction}
The best way we know of describing the semantics of parametric
polymorphism is \emph{relational parametricity}, whose central result
is Reynolds' Abstraction Theorem~\cite{reynolds83types}. Its striking
consequences include the well-known ``theorems for free'' for
polymorphic types~\cite{wadler89theorems}, non-inhabitation results, and precise
correspondences between System F encodings and algebraic datatypes~\cite{PittsAM:parpoe},
abstract data types, and, most recently, higher-order encodings of
binder syntax~\cite{syntaxforfree}.

Relational parametricity is in essence a principle of
\emph{invariance}: the behaviour of polymorphic code is invariant
under changes to data representation. Invariance results also abound in
mathematics and physics. The area of a triangle is invariant with
respect to isometries of the Euclidean plane; the determinant of a
matrix is invariant under changes of basis; and Newton's laws are the
same in all inertial frames. Typically, transformations in mathematics
and physics have interesting structure; for example, translations in
the Euclidean plane form an Abelian group.

%Types express properties of programs. The statement $\mathit{b}: \tyBool$ tells
%us that $\mathit{b}$ has value $\mathtt{true}$ or $\mathtt{false}$;
%the statement $\mathit{pos}:\tyReal\tyProduct\tyReal$ says that
%$\mathit{pos}$ is a pair whose components are real numbers. More interestingly,
%the statement $\mathit{f} : \forall X. \tyPrim{list}X\tyArr\tyPrim{list}X$ tells us that
%if we apply $\mathit{f}$ to a list whose elements satisfy some property $\psi$, 
%then the result is a list whose elements also satisfy $\psi$.

%Unary predicates only go so far, and for polymorphic types
%particularly do not express everything that follows from possessing that type. 
%Imagine a function $\mathit{oddRev}$ that reverses any list whose first element
%is an odd number, otherwise behaving as the identity. It certainly
%preserves properties of the elements -- but truly parametric
%polymorphism should tell us more.

%To obtain stronger properties we must \emph{relate} multiple
%executions of the same code. The statement $\mathit{f}:\forall
%X. \tyPrim{list}X\tyArr\tyPrim{list}X$ then says that any change in
%representation of the list elements supplied to $\mathit{f}$ is
%reflected in the elements in the result.  Formally, for any function
%$g$, we have $\mathit{f}(\mathrm{map}\:\mathit{g}\:\mathit{x}) =
%\mathrm{map}\:\mathit{g}\:(\mathit{f}\:\mathit{x})$.  This is the
%essence of \emph{relational parametricity} as formulated by
%Reynolds~\cite{reynolds83types}. Its consequences are striking.  It
%immediately tells us that $\mathit{oddRev}$ cannot be given a
%polymorphic type: simply consider the change-of-representation given
%by $\lambda x. x+1$.  But more profoundly it can be used to prove blah
%blah (initial algebras, term reps, non-inhabitation, etc.).

Inspired by this connection, we study relational parametricity for
types that are \emph{indexed} by attributes that themselves have
algebraic structure.  For example, in computational geometry, points
in 2-space can be indexed by a coordinate frame; in physical
modelling, quantities are indexed by units-of-measure; in
information-flow security, computations are indexed by principals.
Types that are polymorphic over such indices induce invariance
properties, and introduce a useful abstraction barrier.

\paragraph{Invariance}
A function $\mathit{areaTri}$ that computes the area of a triangle might
have simple type $\tyPrimNm{vec}\times\tyPrimNm{vec}\times\tyPrimNm{vec}\tyArr\tyReal$
but we can assign it a more expresive polymorphic type
\[
\mathrm{areaTri} : \forall\alpha\mathord:\SynTransl{2}.
  \tyPrim{vec}{\alpha} \times \tyPrim{vec}{\alpha} \times \tyPrim{vec}{\alpha} \to \tyReal \\
\]
in which the index $\alpha$ can be thought of as a `translation frame' that is
preserved by the vector arguments, from which we can deduce that
\[
\mathrm{areaTri}\;(t + v_1, t + v_2, t + v_3) = 
\mathrm{areaTri}\;(v_1, v_2, v_3)
\]
for any translation $t\in\Transl{2}$.

In more complex examples the transformations \emph{compose} in various
ways; moreover, the compositions satisfy algebraic laws. Consider a function
that computes the area of a circle given its radius; by ascribing it
the polymorphic type
\[
\mathrm{areaCircle} : \forall\alpha\mathord:\SynScal.\tyPrim{real}{\alpha}\to
\tyPrim{real}{\alpha\cdot\alpha}
\]
we have captured that its area varies as the square of its radius, that is, for any $s>0$,
\[
\mathrm{areaCircle}\;(s\cdot r) = s^2\cdot \mathrm{areaCircle}\;r.
\]
Here $\alpha$ can be interpreted as the \emph{units of measure} of the argument
to $\mathrm{areaCircle}$, and `$\cdot$' composes units by forming
their product. To complete the system, we would add an inverse
operation and identity unit-of-measure, together with the algebraic laws of
Abelian groups, permitting, for example, the identification of
$\tyPrim{real}{\alpha\cdot\alpha^{-1}}$ with $\tyPrim{real}{1}$.

\paragraph{Abstraction}
In his original paper on parametricity, Reynolds asserted that \emph{type structure is
  a syntactic discipline for enforcing levels of abstraction}.  We see
something analogous here: supposing that all primitive operations are
given types that reflect their behaviour under translation, there is
no way to `break' this property, for example, for $\mathrm{areaTri}$
to depend on the actual coordinates of its inputs. Furthermore, the
distinction between points and vectors that is often enforced through
abstract data types~\cite{CGAL} is here captured by the indices
instead. For example, the operation that takes two points and computes
their vector `difference' can be assigned the type
$\forall\alpha\mathord:\SynTransl.\tyPrim{vec}\alpha\times\tyPrim{vec}\alpha\to\tyPrim{vec}0$,
reflecting the invariance of the result (a pure vector) under
translations of the point arguments. In essence, through types alone
we can derive so-called \emph{coordinate-free} geometry~\cite{CFGADT}.

The invariance properties listed above can be seen as `theorems for
free'~\cite{wadler89theorems} obtained from types alone. We can
further observe that the abstraction afforded by polymorphic indexed
types induces interesting type \emph{isomorphisms}.  The type of
$\mathrm{areaCircle}$ above is in fact isomorphic to
$\tyPrim{real}{1}$, that is, a dimensionless constant. A moment's
thought reveals why: what possible unary functions can be constructed whose
outputs scale as the square of the scaling of their inputs? Answer:
just those functions of the form~$\lambda x. k x^2$ for some constant~$k$.
In this case, of course, we expect that~$k = \pi$.

\paragraph{Relational parametricity}
In order to derive such invariance and abstraction properties of types, we
adopt the techniques of relational parametricity. Over an underlying index-erasure semantics
we construct binary
relations parameterized by an environment $\rho$ that describes how values of primitive type
are related according to their indices. 
For example, values $v$ and
$w$ of type $\tyPrim{real}\alpha$ are related when $v$ `scales to' $w$
according to an interpretation of $\alpha$ (that is, $w=\rho(\alpha)\cdot v$).
Values of polymorphic type are related exactly when they are related for
all possible interpretations of the quantified variable. For example, 
values $v$ and $w$ of type $\forall\alpha\mathord:\SynTransl.\tyPrim{vec}\alpha\to
\tyPrim{vec}\alpha$ are related when they are related at type 
$\tyPrim{vec}\alpha\to\tyPrim{vec}\alpha$ for all 
translations $t\in\Transl{2}$ associated with $\alpha$. 

As it happens, these examples can be expressed using unary functions
rather than binary relations: we can write functions that scale, or
translate, one value to another according to their type, even for
higher-order function types. Also note that the interpretation of
indices can be built up compositionally, by recursion over the
syntactic structure. For example, we have $\rho(\alpha\cdot\alpha) =
\rho(\alpha)\cdot\rho(\alpha)$ where product of units-of-measure is interpreted by
product of scale factors.

For more sophisticated applications we need the fully generality of
binary relations. First, as is also the case with type polymorphism,
it provides the appropriate meaning for nested quantifiers in types
such as
$(\forall\alpha\mathord:\SynScal.\tyPrim{real}\alpha\to\tyPrim{real}\alpha)\to\tyBool$.
More interestingly, we sometimes use relations that are not built up
in a compositional way -- we can, for instance, use such relations to
prove that there are no non-trivial functions of type
$\forall\alpha\mathord:\SynScal.\tyPrim{real}{\alpha\cdot\alpha}\to\tyPrim{real}\alpha$.
Finally, there are interesting applications in which even the basic
relations are not functional. Consider a type system in which the
index in $\tyPrim{real}\alpha$ is interpreted not as a
unit-of-measure, but as a measure of \emph{closeness}. Two values $x$
and $y$ of this type are related if $|x-y| < \rho(\alpha)$, in which
$\rho(\alpha)$ is a positive real number.  Rather beautifully, the
standard notion of continuous functions can then be expressed as a
type:
\begin{displaymath}
  \forall \epsilon \mathord: \mathsf{R}^{>0}.\ \exists \delta\mathord: \mathsf{R}^{>0}.\ \tyPrim{real}{\delta} \to \tyPrim{real}{\epsilon}
\end{displaymath}





% Possible angles of attack:
% \begin{itemize}
% \item Parametric polymorphic types allow us to prevent
%   over-specification of the behaviour of programs. For instance, the
%   type $\forall \alpha. [\alpha] \to [\alpha]$ is a generalisation of
%   the types $[\mathsf{int}] \to [\mathsf{int}]$ and $[\mathsf{char}]
%   \to [\mathsf{char}]$. Either of the latter two types over-specify
%   the behaviour of the function.
% \item There are other cases of programs that are over-specified. The
%   leading example we just below is of geometric programs that
%   manipulate coordinate data. Often, programs that manipulate
%   coordinate data are insensitive to geometric transformations. For
%   example, a program that computes the area of a triangle described by
%   three points is insensitive to translations or rotations applied to
%   all three points.
% \item 
% \end{itemize}

% There are three main points to get across:
% \begin{enumerate}
% \item Why algebraically indexed types?
% \item Why relational parametricity?
% \item Why study them together?
% \end{enumerate}

\subsection{Contributions}
\label{sec:contributions}

We make the following contributions. 
\begin{itemize}
\item 
We present a collection of compelling examples of algebraically indexed
types, including a novel type system for geometry, a type system for
tracking taint marking (or provenance) of strings, a refined type
system for information flow, based on logic, and a simple type
system for basic continuity analysis.
\item 
We formulate a general class of type systems that can either be
used as programming languages in their own right, or as the targets of
type-based analyses. The type system consists of the usual type
constructors together with a collection of indexed primitive types,
universal and existential quantification over the indices, and a
multi-sorted equational theory for indices. 
\item
We describe a relational semantics for the type system and prove an analogue
of Reynolds' Abstraction Theorem. We pin down precise conditions on sets of
relation environments for which the theorem holds.
\item
For each of our main examples we deduce free theorems that are consequences of
the Abstraction Theorem, prove non-definability results, and derive interesting
type isomorphisms.
\end{itemize}
We have fully formalized the framework and Abstraction Theorem using the Coq proof assistant,
making use of strongly-typed term representations throughout~\cite{TypedSyntax}.

%%% Local Variables:
%%% TeX-master: "paper"
%%% End:
