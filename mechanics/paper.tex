\documentclass{sigplanconf}

\pdfpagewidth=8.5in
\pdfpageheight=11in

\newcommand{\sepbar}{\mathrel|}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}

\title{From Parametricity to Conservation Laws, via Noether's Theorem}

\authorinfo{Robert Atkey}{}{bob.atkey@gmail.com}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{proposition}{Proposition}
\newcommand{\lemref}[1]{\hyperref[#1]{Lemma~\ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem~\ref*{#1}}}
\newcommand{\defref}[1]{\hyperref[#1]{Definition~\ref*{#1}}}
\newcommand{\propref}[1]{\hyperref[#1]{Proposition~\ref*{#1}}}
\newcommand{\corref}[1]{\hyperref[#1]{Corollary~\ref*{#1}}}
\newcommand{\conref}[1]{\hyperref[#1]{Conjecture~\ref*{#1}}}
\newcommand{\exref}[1]{\hyperref[#1]{Example~\ref*{#1}}}
\newcommand{\statementref}[1]{\hyperref[#1]{Statement~\ref*{#1}}}

\newcommand{\comp}{\mathrel{>\kern-0.45em>\kern-0.45em>}}

\newcommand{\smoothrightarrow}{\stackrel{C^\infty}\longrightarrow}
\newcommand{\typeOfCartSp}[1]{\lbag #1 \rbag}
\newcommand{\elab}[1]{\lfloor #1 \rfloor}

\newcommand{\abs}[1]{\lvert #1 \rvert}

\newtheoremstyle{examplestyle}
  {\topsep}  % space above
  {\topsep}  % space below
  {\normalfont}% name of font to use in the body of the theorem
  {0em}% measure of space to indent
  {\bfseries}% name of head font
  {.}% punctuation between head and body
  {5pt plus 1pt minus 1pt}% space after theorem head; " " = normal interword space
  {}% Manually specify head
\theoremstyle{examplestyle}
\newtheorem{example}{Example}
\newtheorem*{example*}{Example}

\newcommand{\fomega}{F$\omega$}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Rel}{\mathsf{Rel}}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\frel}[1]{\langle #1 \rangle}
\newcommand{\coq}[1]{\textsf{#1}}
\newcommand{\CIC}{\textsc{CIC}}

\newcommand{\semKU}[1]{\llbracket #1 \rrbracket^O}
\newcommand{\semKR}[1]{\llbracket #1 \rrbracket^R}
\newcommand{\semKI}[1]{\llbracket #1 \rrbracket^{\mathrm{id}}}

\begin{document}

\exclusivelicense
\conferenceinfo{POPL~'14}{January 22--24, 2014, San Diego, CA, USA}
\copyrightyear{2014}
\copyrightdata{978-1-4503-2544-8/14/01}
\doi{2535838.2535867}

\maketitle

\begin{abstract}
  Invariance is of paramount importance in programming languages and
  in physics. In programming languages, John Reynolds' theory of
  relational parametricity demonstrates that parametric polymorphic
  programs are invariant under change of data representation, a
  property that yields ``free'' theorems about programs just from
  their types. In physics, Emmy Noether showed that if the action of a
  physical system is invariant under change of coordinates, then the
  physical system has a conserved quantity: a quantity that remains
  constant for all time. Knowledge of conserved quantities can reveal
  deep properties of physical systems. For example, the conservation
  of energy is by Noether's theorem a consequence of a system's
  invariance under time-shifting.

  In this paper, we link Reynolds' relational parametricity with
  Noether's theorem for deriving conserved quantities. We propose an
  extension of System F$\omega$ with new kinds, types and term
  constants for writing programs that describe classical mechanical
  systems in terms of their Lagrangians. We show, by constructing a
  relationally parametric model of our extension of F$\omega$, that
  relational parametricity is enough to satisfy the hypotheses of
  Noether's theorem, and so to derive conserved quantities for free,
  directly from the polymorphic types of Lagrangians expressed in our
  system.
\end{abstract}

\category{D.3.1}{Programming Languages}{Formal Definitions and Theory}
\category{J.2}{Physical Sciences and Engineering}{Physics}

\terms
  Languages, Theory, Types, Physics

\keywords
  classical mechanics; relational parametricity; higher-kinded types; invariance; conservation laws

\section{Introduction}

Reynolds' theory of relational parametricity \cite{reynolds83types}
tells us that parametrically polymorphic programs automatically
satisfy invariance properties. Such invariance properties are often
called \emph{Free Theorems}, after Wadler \cite{wadler89theorems},
since they follow ``for free'' from the types of programs, rather than
through detailed study of the program text. An illustrative example is
the free theorem for programs $f$ with the following type:
\begin{displaymath}
  f : \forall \alpha.~\mathsf{List}~\alpha \to \mathsf{Nat}
\end{displaymath}
Such programs take lists of $\alpha$s, for any type $\alpha$, and
return natural numbers. Using Reynolds' theory of relational
parametricity, Wadler showed that \emph{any} $f$ with this type
satisfies the following property:
\begin{displaymath}
  \forall \alpha, \beta, g : \alpha \to \beta, l : \mathsf{List}~\alpha.~f~[\alpha]~l = f~[\beta]~(\mathrm{map}~g~l)
\end{displaymath}
Thus, any $f$ with the type given above is invariant under mapping
some arbitrary function $g$ over its input. Thinking in terms of
abstract data types and change of data representation, this free
theorem states that $f$ is invariant under change of data
representation from an arbitrary type $\alpha$ to another arbitrary
type $\beta$, via $g$.

The use of invariance under change to derive useful consequences is a
technique much older than programming languages. In physics,
\emph{Noether's theorem} \cite{noether71} provides a general way to
derive conservation laws for physical systems from invariance
properties. Informally speaking, Noether's theorem states that every
continuous symmetry of a physical system implies the existence of a
corresponding conserved quantity. A conserved quantity is a function
of the state of the system that is constant for all time. We
illustrate the use of Noether's theorem with a simple example of a
classical system consisting of two particles of equal mass $m$
connected by a spring with spring constant $k$, such that the
particles are constrained to move one-dimensionally.

% Picture here?

Noether's theorem applies to systems described in terms of
\emph{Lagrangians}. For classical mechanics, a Lagrangian is a
function of time and the positions and velocities of all the
particles in the system, to the difference between the kinetic energy
and the potential energy of the system. For our system with two
particles at positions $x_1$ and $x_2$ with velocities $\dot{x_1}$ and
$\dot{x_2}$ the Lagrangian is:
\begin{equation}\label{eq:coupled-spring-lagrangian}
  L(t,x_1,x_2,\dot{x_1},\dot{x_2}) = \frac{1}{2}m(\dot{x_1}^2 + \dot{x_2}^2) - \frac{1}{2}k(x_1 - x_2)^2
\end{equation}
The first summand represents the total kinetic energy of the system in
terms of the mass and velocities, while the second summand represents
the potential energy contained within the spring due to the distance
between the particles.

From the Lagrangian (\ref{eq:coupled-spring-lagrangian}), using the
\emph{principle of stationary action}, we can derive the following two
equations of motion for this system. (We describe the principle of
stationary action, and the process for deriving the equations of
motion fully in Section~\ref{sec:conservation-laws-from-symmetry}.)
For this system, the equations of motion are a pair of ordinary
differential equations (ODEs) that describe how the positions and
velocities of the particles evolve over time (the second derivative
with respect to time, $\ddot{x_i}$, denotes the acceleration of the
$i$th particle):
\begin{mathpar}
  m\ddot{x_1} = - k(x_1 - x_2)

  m\ddot{x_2} = - k(x_2 - x_1)
\end{mathpar}
We could now proceed to solve these ODEs to further analyse the
behaviour of this system. However, Noether's theorem gives us a
powerful way of gaining insight into properties of these ODEs ``for
free'', without necessarily having to find solutions to them. This is
accomplished by finding invariance properties of the Lagrangian.

The Lagrangian (\ref{eq:coupled-spring-lagrangian}) does not refer to
any fixed point in space; only the relative distance between the two
particles, along with their velocities, is relevant. Therefore, the
Lagrangian (\ref{eq:coupled-spring-lagrangian}) is invariant under
translation in space by some arbitrary displacement $y$:
\begin{equation}\label{eq:coupled-spring-translation-invariance}
  L(t,x_1,x_2,\dot{x_1},\dot{x_2}) = L(t,x_1+y,x_2+y,\dot{x_1},\dot{x_2})
\end{equation}
By Noether's theorem, invariance under spatial translation implies
that the linear momentum of the whole system is constant for all
time. For this system, conservation of linear momentum is stated
mathematically as the vanishing of the derivative with respect to time
of the total linear momentum of the system:
\begin{equation}\label{eq:coupled-spring-linear-momentum}
  \frac{d}{\mathit{dt}}~m(\dot{x}_1 + \dot{x_2}) = 0
\end{equation}
In general, Noether's theorem gives us a way of deriving conserved
properties like (\ref{eq:coupled-spring-linear-momentum}) from
invariance properties like
(\ref{eq:coupled-spring-translation-invariance}). In this case, we
have used invariance under translation in space to derive conservation
of linear momentum. Other common examples include invariance under
translation in time, yielding conservation of energy, and invariance
under rotation, yielding conservation of angular momentum. We will see
examples of each of these kinds of invariance, and their consequent
conservation laws, in Section~\ref{sec:examples}.

The invariance property stated in
Equation~(\ref{eq:coupled-spring-translation-invariance}) is highly
reminiscent of the free theorem we stated for the polymorphic program
at the start of this introduction. A change in representation in the
input, whether a change in data representation from a type $\alpha$ to
a type $\beta$, or a change in where time zero is counted from,
results in no change in the output. Since Reynolds' relational
parametricity allowed us to derive the invariance properties for the
program $f$ just by looking at its type, we ask the following
question:

\medskip

\noindent
\textbf{Question:} \emph{Is it possible to use Reynolds' theory of
  relational parametricity to derive the invariance properties of
  Lagrangians required for Noether's theorem to derive conservation
  laws?}

\medskip

In this paper, we answer this question positively. We show that it is
indeed the case that we can use a generalised version of Reynolds'
theory of relational parametricity to prove the geometric invariance
properties required for the hypotheses of Noether's theorem. We
construct an extension of System F$\omega$ suitable for writing
invariant Lagrangians, with a relationally parametric model that
allows us to prove invariance properties as free theorems. In our
system, the Lagrangian (\ref{eq:coupled-spring-lagrangian}) we gave
above for describing a system of two particles coupled by a spring
will have the type:
\begin{displaymath}
  \begin{array}{@{}l}
  \forall y \mathord: \mathsf{T}(1).\\
  \quad C^\infty(\mathbb{R}\langle 1, 0 \rangle \times \mathbb{R}\langle 1, y \rangle \times \mathbb{R}\langle 1, y \rangle \times \mathbb{R}\langle 1, 0 \rangle \times \mathbb{R}\langle 1, 0 \rangle, \mathbb{R}\langle 1, 0 \rangle)
\end{array}
\end{displaymath}
We explain this type by breaking it down from left to right. The
quantifier $\forall y \mathord: \mathsf{T}(1)$ indicates that we are
quantifying over all translations $y$ in one-dimensional space, just
as we did implicitly in Equation
(\ref{eq:coupled-spring-translation-invariance}). The notation
$C^\infty(-,-)$ denotes the type of \emph{smooth} functions between
spaces. (A smooth function is a function that is infinitely
differentiable.) All the functions that we wish to use as Lagrangians
must be smooth (at least up to second order) for the theory to
work. The type $\mathbb{R}\langle g, x \rangle$ denotes real numbers
that vary with some linear transformation $g$ and translation $x$. In
this case, all the linear transformations are $1$, indicating no
transformation. Likewise, when the translation component is $0$, there
is no translation. Thus a value of type $\mathbb{R}\langle 1, 0
\rangle$ is invariant, but a value of type $\mathbb{R}\langle 1, y
\rangle$ varies with the translation $y$. In the smooth function type
above, the domain space consists of vectors of five real numbers: the
time, the two particle positions, which vary with the translation $y$,
and the two particle velocities.

Atkey, Johann and Kennedy \cite{atkey13abstraction}, building on
work by Kennedy \cite{kennedy97relational}, have already presented a
polymorphic type system for expressing geometric invariance properties
similar to the translation invariance property in Equation
(\ref{eq:coupled-spring-translation-invariance}). In the present work,
we extend their type system by embedding it within System
F$\omega$. The benefits of this embedding are twofold. Firstly, by
using the richer type-level structure of System F$\omega$, we can
easily add useful indexed types like length indexed vectors and smooth
function types, both of which would have required special treatment in
the special purpose type system presented by Atkey \emph{et
  al.}. Secondly, by using System F$\omega$ as our base, we are able
to reuse the reflexive graph-based relationally parametric semantics
presented by Atkey \cite{atkey12relational}, extending it as
appropriate for our geometric setting.

\paragraph{Contributions}

Our core contributions are threefold:
\begin{enumerate}
\item We reformulate the type system for geometric invariance of
  Atkey, Johann and Kennedy \cite{atkey13abstraction} as an extension
  of System F$\omega$. This shows that the special status of the
  group-indexed types in Atkey \emph{et al.}'s work can be
  incorporated into a standard framework for indexed types.
\item We present a relationally parametric semantics of our extension
  of System F$\omega$. In this model, following Atkey's model for
  basic System F$\omega$ \cite{atkey12relational}, each kind is
  interpreted as a reflexive graph. Our key technical contribution is
  to note that the many geometric groups that we wish to incorporate
  are expressible as groupoids, and hence as reflexive graphs. We
  therefore show that Reynolds' theory of relational parametricity,
  suitably generalised to indexed types by considering reflexive
  graphs, already accommodates geometric invariance properties.
\item Finally, we connect the free theorems derivable from our
  relationally parametric semantics with Noether's theorem for
  deriving conservation laws. We present many examples of invariant
  Lagrangians expressible in our type system, along with the
  consequent conservation laws for physical systems. In each case, the
  necessary invariance property is derived from the type of the
  Lagrangian.
\end{enumerate}

\paragraph{Outline}

\begin{itemize}
\item In the next section,
  Section~\ref{sec:conservation-laws-from-symmetry}, we describe the
  necessary background to understand Noether's theorem and the
  conservation laws it generates. We briefly introduce the Lagrangian
  formulation of classical mechanics, define precisely what it means
  for a physical system to be invariant under transformations, and
  state Noether's theorem.
\item Having shown how invariance generates conservation laws in
  Section~\ref{sec:conservation-laws-from-symmetry}, in
  Section~\ref{sec:symmetry-from-types} we show how to derive
  invariance properties from indexed types. We present a relationally
  parametric semantics for System F$\omega$, and show how geometric
  invariance properties can be accomodated within this semantics.
\item In Section~\ref{sec:types-for-classical-mech} we construct a
  type system for classical mechanics by extending System F$\omega$
  with the necessary constants for smooth function types and
  combinators for constructing smooth functions. Programming directly
  with our combinators in raw System F$\omega$ is awkward, due to the
  point-free style required, so in Section~\ref{sec:surface-syntax} we
  define a surface syntax for defining smooth functions that is
  translated into our applied System F$\omega$.
\item In Section~\ref{sec:examples} we present several examples of
  using our extension of System F$\omega$ for writing invariant
  Lagrangians that describe physical systems.
\item Section~\ref{sec:conclusions} concludes, and offers directions
  for further work.
\end{itemize}

\section{Conservation Laws from Invariance}
\label{sec:conservation-laws-from-symmetry}

Noether's theorem applies to systems described using the formalism of
Lagrangian mechanics, a reformulation of Newtonian classical
mechanics. In this section we can only offer a very brief introduction
to the concepts of Lagrangian mechanics. The reader is referred to
other sources, such as Landau and Lifschitz \cite{landau60mechanics}
or Arnol'd \cite{arnold89mathematical} for the necessary background in
the mathematical theory of classical mechanics. Lagrangian mechanics,
and Noether's theorem, make crucial use of the Calculus of
Variations. Gelfand and Fomin \cite{gelfand00calculus} provide a good
introduction to this topic.

In this section, we will endeavour to keep the presentation relatively
elementary. However, some knowledge of differential and integral
calculus will be required. Knowledge of basic Newtonian mechanics will
also be helpful. We will use standard notation from physics and
mathematics for integrals and (partial) derivatives. In particular,
when discussing derivatives with respect to time, we use dot notation:
$\dot{x}$ for the first derivative of $x$ with respect to time, and
$\ddot{x}$ for the second derivative.

\subsection{Lagrangian Mechanics}

Lagrangian mechanics is a branch of analytical mechanics, along with
Hamiltonian mechanics
\cite{landau60mechanics,arnold89mathematical}. Analytical mechanics
seeks to discover the underlying structure of Newtonian classical
mechanics by reformulating it in different terms.

\paragraph{Lagrangian and Action}

For Lagrangian mechanics, classical mechanical systems are described
in terms of \emph{Lagrangians} $L = T - V$, where $T$ is the total
kinetic energy of the system, and $V$ is the total potential
energy. The Lagrangian is a function of time, the positions of all the
particles in the system, and their velocities. This is usually written
like so, with abuse of notation for $\dot{q}$ which is a variable
here, not the derivative of a function:
\begin{displaymath}
  L(t, q, \dot{q}) = T - V
\end{displaymath}
In this expression, $q$ and $\dot{q}$ are actually vectors containing
the components of the position and velocity vectors for each
particle. A key feature of Lagrangian mechanics is that the coordinate
system used to describe the system need not necessarily be the usual
cartesian coordinates. For example, one of the components of $q$ might
be the angle of swing of a pendulum. This use of generalised
coordinates is one of the advantages of Lagrangian mechanics over the
Newtonian presentation in terms of positions and forces.

The Lagrangian for a particular system is used to define the
\emph{action} of that system. For a particular path $q : \mathbb{R}
\to \mathbb{R}^n$ and endpoints $a < b$ in time, the action of the
Lagrangian $L$ over this path is defined by the following integral:
\begin{displaymath}
  \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
\end{displaymath}
Below, we will use the principle of stationary action to select the
physically realisable paths from all the possible paths $q :
\mathbb{R} \to \mathbb{R}^n$.

\begin{example}
  We have already seen an example of a Lagrangian, in the
  introduction, describing a system of two particles coupled by a
  spring. Another example of a Lagrangian describes a system
  consisting of a single particle of mass $m$ acted upon by a constant
  downward gravitational field with gravitational potential $g$:
  \begin{equation}\label{eq:simple-g-lagrangian}
    L(t,x,y,\dot{x},\dot{y}) = \frac{1}{2}m(\dot{x}^2 + \dot{y}^2) - mgy
  \end{equation}
  Again, the left summand represents the kinetic energy of the system
  in terms of the mass and horizontal and vertical velocities of the
  particle. The right summand represents the potential energy of the
  system due to the gravitational field's strength determined by the
  particle's distance from a fixed baseline at $y = 0$.
\end{example}

\paragraph{The Principle of Stationary Action}

The \emph{principle of stationary action} states that the physically
realisable paths $q$ are the paths that yield stationary points (i.e.,
either minima or maxima) of the action $\mathcal{S}[q;a;b]$, for all
$a$ and $b$. Defining what is exactly meant by a stationary point of
the action is beyond the scope of this paper, and can be found in
standard references on the calculus of variations, such as Gelfand and
Fomin \cite{gelfand00calculus}. The key point for our purposes is that
a path $q$ satisfies the principle of stationary action if and only if
it satisfies a system of ODEs derived from the Lagrangian $L$, called
the Euler-Lagrange equations:
\begin{equation}\label{eq:euler-lagrange}
  \frac{d}{dt}\frac{\partial L}{\partial \dot{q_i}} - \frac{\partial L}{\partial q_i} = 0
\end{equation}
The ODEs derived from the Lagrangian for a classical mechanical system
are called the \emph{equations of motion} for the system.

The notation in the Euler-Lagrange equation, while standard, is not
exactly clear, especially to a programming language theorist used to a
more careful treatment of variables. The two partial derivatives
$\frac{\partial L}{\partial \dot{q_i}}$ and $\frac{\partial
  L}{\partial q_i}$ take partial derivatives of $L$ with respect to
$\dot{q_i}$ and $q_i$ \emph{as variables}. The derivative with respect
to time, $\frac{d}{dt}$, then treats $\dot{q_i}$ as a function of
time, hence the appearance of the second derivatives $\ddot{q_i}$ in
the equations of motion. Sussman and Wisdom \cite{sussman01structure}
criticise the standard presentation of Lagrangian mechanics for this
kind of confusing notation, and define a clearer notation based on the
Scheme programming language. We elect to stick with the standard
notation as used in physics textbooks just for familiarity.

\begin{example}
  Computing the Euler-Lagrange equations for the Lagrangian
  (\ref{eq:simple-g-lagrangian}), above, yields a pair of ODEs, one
  each for the $x$ and $y$ coordinates of the single particle of the
  system:
  \begin{mathpar}
    m\ddot{x} = 0

    m\ddot{y} = -mg
  \end{mathpar}
  Note that both these ODEs have the form $F = m\ddot{x}$, just as in
  Newton's second law. Lagrangian mechanics allows, from the principle
  of stationary action, the derivation of Newton's second law, instead
  of postulating it as an axiom.
\end{example}

\subsection{Noether's Theorem} 

As we described in the introduction, Noether's theorem provides us
with deep insights into the properties of the solutions of the
Euler-Lagrange equations. Formally, Noether's theorem requires the
invariance of the action $\mathcal{S}$, rather than invariance of the
Lagrangian itself. We therefore first define what is meant by
invariance of the action, and then state Noether's theorem.

\paragraph{Invariance of the Action} Let
\begin{displaymath}
  \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
\end{displaymath}
be the action of some physical system described by the Lagrangian
$L$. Assume a differentiable invertible function $\Phi : \mathbb{R}
\to \mathbb{R}$ that transforms time in some way and a function
$\Psi : \mathbb{R}^n \to \mathbb{R}^n$ that transforms the vector of
generalised coordinates $\vec{q}$ to another vector of generalised
coordinates $\Psi(\vec{q})$.

The action $\mathcal{S}$ is \emph{invariant} between the endpoints $a$
and $b$, under the transformations $\Phi$ and $\Psi$, if it is the
case that for all paths $q$:
\begin{equation}\label{eq:invariance}
    \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
    = \int_{\Phi(a)}^{\Phi(b)} L(s, q^*(s), \frac{d q^*}{ds}(s)) \mathit{ds}
\end{equation}
where $q^*(s) = (\Psi \circ q \circ \Phi^{-1})(s)$ is the path $q$
transformed by $\Phi$ and $\Psi$.  By change of variables, the right
hand integral in the above equation is equal to the following
integral:
\begin{displaymath}
  \int_a^b L(\Phi(t), q^*(\Phi(t)), \frac{d q^*}{ds}(\Phi(t)))\cdot \abs{\dot{\Phi}(t)} \mathit{dt}
\end{displaymath}
For our application to classical mechanics, the endpoints $a$ and $b$
are arbitrary, so we can rewrite Equation (\ref{eq:invariance}) to the
following equation between applications of the Lagrangian:
\begin{equation}\label{eq:simplified-invariance}
  L(t,q(t),\dot{q}(t)) = L(\Phi(t), q^*(\Phi(t)), \frac{d q^*}{ds}(\Phi(t)))\cdot \abs{\dot{\Phi}(t)}
\end{equation}
For most examples, it will be the case that $\Phi$ has the form
$\Phi(t) = t + t'$ and $\Psi$ is an affine transformation $\Psi(q)
= Gq + x$, where $G$ is an $n\mathord\times n$ real matrix and $x \in
\mathbb{R}^n$. In this case, Equation (\ref{eq:simplified-invariance})
simplifies further, using the definition of $q^*$ and the chain rule
of differentiation, to:
\begin{equation}
  \label{eq:simple-invariance}
  L(t,q(t),\dot{q}(t)) = L(t + t', Gq(t) + x, G\dot{q}(t))
\end{equation}
Equation (\ref{eq:simple-invariance}) is obviously implied by the
following equation, where we treat $q$ and $\dot{q}$ as universally
quantified variables, instead of as functions of time:
\begin{equation}
  \label{eq:simplest-invariance}
  L(t,q,\dot{q}) = L(t + t', Gq + x, G\dot{q})
\end{equation}
Equation (\ref{eq:simplest-invariance}) is the form of invariance that
the free theorems we derive from the types of our typed language for
classical mechanics will usually take. We define our type system for
classical mechanics in Sections~\ref{sec:symmetry-from-types}
and~\ref{sec:types-for-classical-mech} below.

\begin{example}\label{ex:invariance-examples}
  In the introduction, we stated that the Lagrangian
  (\ref{eq:coupled-spring-lagrangian}) describing the spring-coupled
  system is invariant under translation in space. Our running example
  in this section, the Lagrangian (\ref{eq:simple-g-lagrangian}) for
  the single particle under gravity, is not invariant under all
  spatial translations, due to the reference in the potential energy
  term to the distance from the fixed baseline at $y = 0$. It is
  invariant under translations along the $x$-axis, however. Both
  Lagrangians are also invariant under translations in time, a special
  case of Equation~(\ref{eq:simplest-invariance}):
  \begin{displaymath}
    L(t,q,\dot{q}) = L(t+t',q,\dot{q})
  \end{displaymath}
  This invariance property is simply a consequence of the fact that
  neither Lagrangian explicitly mentions the time $t$.
\end{example}

\paragraph{Noether's Theorem} Noether's theorem applies to actions
that are \emph{continuously} invariant. Being continuously invariant
means that, instead of having fixed transformations $\Phi$ and $\Psi$,
we have two families of transformations, $\Phi_\epsilon$ and
$\Psi_\epsilon$, differentiably indexed by a real parameter
$\epsilon$, such that $\Phi_0$ and $\Psi_0$ are the identity function.

\begin{theorem}[Noether]\label{thm:noether}
  If the action
  \begin{displaymath}
    \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t))~dt
  \end{displaymath}
  is invariant under $\epsilon$-indexed families of transformations
  $\Phi_\epsilon$ and $\Psi_\epsilon$, then the equation
  \begin{equation}
    \label{eq:conservation-law}
    \frac{d}{dt}\left(\sum_{i=1}^n \frac{\partial L}{\partial \dot{q_i}}\psi_i + \left(L - \sum_{i=1}^n \dot{q_i}\frac{\partial L}{\partial \dot{q_i}}\right) \phi \right) = 0
  \end{equation}
  holds for all paths $q$ satisfying the Euler-Lagrange equations
  (\ref{eq:euler-lagrange}), where $\psi = \left. \frac{\partial
      \Psi}{\partial \epsilon} \right|_{\epsilon = 0}$ and $\phi =
  \left. \frac{\partial \Phi}{\partial \epsilon} \right|_{\epsilon =
    0}$.
\end{theorem}

\begin{proof}
  E.g., Gelfand and Fomin \cite{gelfand00calculus}, Section 20.
\end{proof}

% Theorem \ref{thm:noether} is a special case of what is known as
% Noether's ``first theorem''. The general case of Theorem
% \ref{thm:noether} applies to situations where the action is an
% integral over regions of $n$-dimensional space, and the
% transformations $\Psi$ can also depend on time. Noether's second
% theorem generalises further to the case when there are infinitely many
% parameters $\epsilon$. This is the case when considering local
% symmetries that vary at different points in spacetime.

\begin{example}\label{ex:conservation-laws}
  In Example~\ref{ex:invariance-examples}, we noted that the
  Lagrangians (\ref{eq:coupled-spring-lagrangian}) and
  (\ref{eq:simple-g-lagrangian}) are both invariant under arbitrary
  translations in time. In terms of continuous invariance, their
  corresponding actions are invariant under the families
  $\Phi_\epsilon(t) = t + \epsilon$ and $\Psi_\epsilon(q) =
  q$. Plugging these definitions into
  Equation~(\ref{eq:conservation-law}), we learn that, for these
  systems:
  \begin{displaymath}
    \frac{d}{dt}~\left(L - \sum_{i=1}^2 \dot{q_i}\frac{\partial L}{\partial \dot{q_i}} \right) = 0
  \end{displaymath}
  For the spring-coupled particles Lagrangian,
  (\ref{eq:coupled-spring-lagrangian}), we obtain:
  \begin{displaymath}
    \frac{d}{dt}~\left(\frac{1}{2}m(\dot{x_1}^2 + \dot{x_2}^2) + \frac{1}{2}k(x_1 - x_2)^2 \right) = 0
  \end{displaymath}
  and for the single particle under gravity Lagrangian
  (\ref{eq:simple-g-lagrangian}), we obtain:
  \begin{displaymath}
    \frac{d}{dt}~\left(\frac{1}{2}m(\dot{x}^2 + \dot{y}^2) + mgy\right) = 0
  \end{displaymath}
  In both cases, we have discovered that, as a consequence of
  invariance under translation in time, the total energy of the system
  is conserved (note that the $-$ signs in the original Lagrangians
  have turned into $+$s). In general, invariance under translation in
  time implies, via Noether's theorem, conservation of energy.
\end{example}

This finishes our short introduction to Lagrangian mechanics and
Noether's theorem. We have shown how Noether's theorem can be used to
derive conservation laws from invariance properties. We now go on to
showing how suitable invariance properties can be derived from types,
building towards Section~\ref{sec:types-for-classical-mech}, where we
construct a type system for writing Lagrangians that expresses
invariance properties directly in the types. In
Section~\ref{sec:examples}, we give examples of invariant Lagrangians
and their consequent conservation laws.

\section{Invariance from Types}
\label{sec:symmetry-from-types}

We derive invariance properties from types by constructing a
relationally parametric model of System F$\omega$, which we then
extend with suitable kind-, type-, and term-level constants for
writing invariant Lagrangians. Our relationally parametric model is
based on the reflexive graph model presented by
Atkey~\cite{atkey12relational} (based on previous work on reflexive
graph models of relational parametricity by Robinson and
Rosolini~\cite{robinson94reflexive} and
Hasegawa~\cite{hasegawa94relational}). In reflexive graph models of
relational parametricity, the kinds of System F$\omega$ are
interpreted as reflexive graphs, while types are interpreted as
morphisms of reflexive graphs. As demonstrated by Atkey, uniformly
interpreting kinds as reflexive graphs allows for a straightforward
interpretation of higher kinds like $* \to *$. In the present setting,
reflexive graphs will allow us to accomodate arbitrary groupoids as
kinds (Section~\ref{sec:groupoid-kinds}). Groupoid kinds are the key
technical tool that we need to derive the kinds of geometric
invariance properties we need for Noether's theorem.

\subsection{System F$\omega$: Syntax and Relationally Parametric Model}
\label{sec:refl-graphs-for-fomega}

We now present the syntax and relationally parametric semantics of
System F$\omega$. Since we will incrementally extend the syntax of the
system throughout this section and the next, we do not state a final
triple of theorems stating that we have correctly interpreted kinds,
types and terms. Rather, we state the necessary properties of the
interpretation as three separate properties
(Properties~\ref{property:semantic-kinds},
\ref{property:semantic-types}, and~\ref{property:semantic-terms},
below), and maintain them as we extend the system.

We deviate from the standard presentation of System F$\omega$ in that
we distinguish between large and small kinds, and only allow
quantification over small kinds. In particular, the kind of types $*$
is \emph{not} small. The reason for this choice is that we desire a
simple set-theoretic model. However, requiring that we have a set of
sets closed under large products, in order to interpret quantification
over the kind $*$, would force us to use an intuitionistic metatheory
\cite{pitts87polymorphism}. The basic results of the Calculus of
Variations that we are relying on, such as the derivation of the
Euler-Lagrange equations, use excluded middle in their proofs, so an
intuitionistic metatheory is not an option. We therefore just assume
that we have a set of ``small'' sets, which includes the real numbers
and is closed under subsets, products, function spaces and
set comprehensions.

\paragraph{Syntax} The kinds of System F$\omega$ include at least the
base kind of types, $*$, and function and product kinds, as generated
by the following grammar:
\begin{displaymath}
  \kappa ::= * \sepbar \kappa_1 \to \kappa_2 \sepbar \kappa_1 \times \kappa_2 \sepbar \cdots
\end{displaymath}
We will extend the collection of kinds in
Section~\ref{sec:discrete-kinds} with type-level natural numbers, and
in Section~\ref{sec:groupoid-kinds} with groupoid kinds.

We use the judgement $\kappa~\mathrm{small}$ to denote when the kind
$\kappa$ will be interpreted by a small reflexive graph (to be defined
below). The kind $*$ is not small, but the construction of function
and product kinds preserves smallness:
\begin{mathpar}
  \inferrule*
  {\kappa_1~\mathrm{small} \\ \kappa_2~\mathrm{small}}
  {\kappa_1 \to \kappa_2~\mathrm{small}}

  \inferrule*
  {\kappa_1~\mathrm{small} \\ \kappa_2~\mathrm{small}}
  {\kappa_1 \times \kappa_2~\mathrm{small}}
\end{mathpar}
The additional kinds we introduce below will all be small.

The well-kinded types, type equalities, and well-typed terms of System
F$\omega$ are shown in Figures~\ref{fig:types},
\ref{fig:type-equality} and~\ref{fig:terms}, respectively. Kinding
contexts $\alpha_1 : \kappa_1, ..., \alpha_n : \kappa_n$ are denoted
by $\Theta$ and typing contexts $x_1 : A_1, ..., x_n : A_n$ are
denoted by $\Gamma$. Note that typing contexts $\Gamma$ only contain
well-kinded types of kind $*$. Terms also have an equational theory,
with $\beta\eta$-laws for functions, products, and universal
quantification, which we omit. Our presentation of System F$\omega$ is
entirely standard (see, e.g., Pierce~\cite{pierce02types}), except for
the restriction to small kinds in the formation of universal kinds
$\forall \alpha\mathord:\kappa. A$. As is the case for kinds, we will
extend the types, type equalities, and terms in
Sections~\ref{sec:discrete-kinds},~\ref{sec:groupoid-kinds}
and~\ref{sec:types-for-classical-mech}, below.

\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule*
    {\alpha : \kappa \in \Theta}
    {\Theta \vdash \alpha : \kappa}

    \inferrule*
    {\Theta, \alpha : \kappa_1 \vdash A : \kappa_2}
    {\Theta \vdash \lambda \alpha : \kappa_1.\ A : \kappa_1 \to \kappa_2}

    \inferrule*
    {\Theta \vdash F : \kappa_1 \to \kappa_2 \\ \Theta \vdash A : \kappa_1}
    {\Theta \vdash F A : \kappa_2}

    \inferrule*
    {\Theta \vdash A : \kappa_1 \\ \Theta \vdash B : \kappa_2}
    {\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}

    \inferrule* [right=${i \in \{1,2\}}$]
    {\Theta \vdash A : \kappa_1 \times \kappa_2}
    {\Theta \vdash \pi_i~A : \kappa_i}

    \inferrule*
    {\Theta \vdash A : * \\ \Theta \vdash B : *}
    {\Theta \vdash A \times B : *}

    \inferrule*
    {\Theta \vdash A : * \\ \Theta \vdash B : *}
    {\Theta \vdash A \to B : *}

    \inferrule*
    {\Theta, \alpha : \kappa \vdash A : * \\ \kappa\textrm{ small}}
    {\Theta \vdash \forall\alpha\mathord:\kappa.\ A : *}
  \end{mathpar}
  \caption{Types and their Kinds}
  \label{fig:types}
\end{figure}

\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule* [right=$\beta$]
    {\Theta, \alpha : \kappa_1 \vdash A : \kappa_2 \\
      \Theta \vdash B : \kappa_1}
    {\Theta \vdash (\lambda \alpha : \kappa_1. A)~B \equiv A\{B/\alpha\} : \kappa_2}

    \inferrule* [right=$\eta$]
    {\Theta \vdash A : \kappa_1 \to \kappa_2}
    {\Theta \vdash (\lambda \alpha : \kappa_1.A~\alpha) \equiv A : \kappa_1 \to \kappa_2}

    \inferrule* [right=$\beta$]
    {\Theta \vdash A_1 : \kappa_1 \\ \Theta \vdash A_2 : \kappa_2}
    {\Theta \vdash \pi_i~\langle A_1, A_2 \rangle \equiv A_i : \kappa_i}

    \inferrule* [right=$\eta$]
    {\Theta \vdash A : \kappa_1 \times \kappa_2}
    {\Theta \vdash \langle \pi_1 A, \pi_2 A \rangle \equiv A : \kappa_1 \times \kappa_2}
  \end{mathpar}
  {\tiny plus: reflexivity, symmetry, transitivity and congruence}
  \caption{Type equality}
  \label{fig:type-equality}
\end{figure}

\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule*
    {x : A \in \Gamma}
    {\Theta \sepbar \Gamma \vdash x : A}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e : A \\ \Theta \vdash A \equiv B : *}
    {\Theta \sepbar \Gamma \vdash e : B}
  \end{mathpar}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : A_1 \\\\
      \Theta \sepbar \Gamma \vdash e_2 : A_2}
    {\Theta \sepbar \Gamma \vdash (e_1, e_2) : A_1 \times A_2}

    \inferrule* [right=${i \in \{1,2\}}$]
    {\Theta \sepbar \Gamma \vdash e : A_1 \times A_2}
    {\Theta \sepbar \Gamma \vdash \pi_i e : A_i}
  \end{mathpar}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma, x : A \vdash e : B}
    {\Theta \sepbar \Gamma \vdash \lambda x : A.\ e : A \to B}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : A \to B \\
      \Theta \sepbar \Gamma \vdash e_2 : A}
    {\Theta \sepbar \Gamma \vdash e_1 e_2 : B}

    \inferrule*
    {\Theta, \alpha : \kappa \sepbar \Gamma \vdash e : A \\ \alpha \not\in \mathit{fv}(\Gamma)}
    {\Theta \sepbar \Gamma \vdash \Lambda \alpha \mathord: \kappa.\ e : \forall \alpha \mathord:\kappa. A}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e : \forall \alpha\mathord:\kappa. A \\ \Theta \vdash B : \kappa}
    {\Theta \sepbar \Gamma \vdash e\ [B] : A\{B/\alpha\}}
  \end{mathpar}
  \caption{Terms and their Types}
  \label{fig:terms}
\end{figure}


\paragraph{Reflexive Graphs and the Interpretation of Kinds} We will
interpret every kind $\kappa$ as a reflexive graph, which we now
define. A \emph{reflexive graph} is a triple $(O, R, \mathrm{id})$,
where $O$ is a large set of objects, $R : O \times O \to \Set$ assigns
a small set of directed `edges' to each pair of objects, and
$\mathrm{id} : \Pi o \in O.~R(o,o)$ assigns a distinguished
`identity' edge from every object to itself. We think of the edges of
a reflexive graph as abstract ``relations'' between the
objects. Indeed, in the interpretation of the kind of types, $*$,
below, the edges will be exactly relations.

A \emph{small} reflexive graph is a reflexive graph $(O, R,
\mathrm{id})$ where $O$ is a small set of objects. We use small
reflexive graphs as the semantic interpretation of small kinds.

The interpretation of kinds as reflexive graphs, and small kinds as
small reflexive graphs is a key property of our semantics that we will
maintain as we add additional kinds in
Sections~\ref{sec:discrete-kinds} and~\ref{sec:groupoid-kinds},
below. We state this as Property~\ref{property:semantic-kinds} of our
semantics:

\begin{property}\label{property:semantic-kinds}
  Each kind $\kappa$ is interpreted as a reflexive graph
  $\sem{\kappa}$. If $\kappa~\mathrm{small}$, then $\sem{\kappa}$ is a
  small reflexive graph.
\end{property}

An appealing interpretation of reflexive graphs is as ``categories
without composition''. Following this intuition, we define morphisms
of reflexive graphs as ``functors'', without the preservation of
composition condition. A \emph{morphism of reflexive graphs}
$(O_1,R_1,\mathrm{id}_1)$ and $(O_2, R_2, \mathrm{id}_2)$ is a pair of
mappings $f : O_1 \to O_2$ and $r : \forall o, o' \in
O_1.~R_1(o,o') \to R_2(f~o, f~o')$ such that identities are
preserved: $r~o~o~(\mathrm{id}_1~o) = \mathrm{id}_2~(f~o)$. We use
morphisms of reflexive graphs below to interpret well-kinded types.

We will use the notation $-^O$, $-^R$ and $-^{\mathrm{id}}$ for the
first, second and third projections out of tuples representing
reflexive graphs. Similarly, we use $-^f$ and $-^r$ for the first and
second projections out of tuples representing reflexive graph
morphisms.

We now define the interpretations of the basic kinds of System
F$\omega$ we defined above, making sure that we maintain
Property~\ref{property:semantic-kinds}. At base kind, the collection
of objects is simply the (large) set of all small sets; edges between
$A$ and $B$ are binary relations on $A$ and $B$ (i.e., subsets of $A
\times B$); and the distinguished identity edge is exactly the
equality relation:
\begin{displaymath}
  \sem{*} = (\Set, \Rel, \equiv)
\end{displaymath}
The reflexive graph $\sem{*}$ is not small, due to the collection of
all small sets $\Set$ not forming a small set.

For higher kinds $\kappa_1 \to \kappa_2$, the collection of objects
consists of reflexive graph morphisms from the interpretation of
$\kappa_1$ to the interpretation of $\kappa_2$; the edges between
morphisms $(f, r)$ and $(f', r')$ are edge transformers; and the
distinguished identity relation for $(f,r)$ is just $r$:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\kappa_1 \to \kappa_2} = \\
    \begin{array}[t]{l@{}l@{}}
      (& \{ (f,r) \sepbar (f, r) : \sem{\kappa_1} \to \sem{\kappa_2} \},\\
      &((f,r),(f',r')) \mapsto \Pi o,o'. \semKR{\kappa_1}(o,o') \to \semKR{\kappa_2}(f~o, f'~o'), \\
      &(f,r) \mapsto r\ )
    \end{array}
  \end{array}
\end{displaymath}
By the assumption that our collection of small sets is closed under
the formation of function spaces and set comprehension, if
$\sem{\kappa_1}$ and $\sem{\kappa_2}$ are small reflexive graphs, then
so is $\sem{\kappa_1 \to \kappa_2}$.

Product kinds are interpreted by taking the product of their
interpretations as reflexive graphs:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\kappa_1 \times \kappa_2} = \\
    \begin{array}[t]{l@{}l}
      (& \semKU{\kappa_1} \times \semKU{\kappa_2}, \\
      & ((o_1,o_2),(o_1',o_2')) \mapsto \semKR{\kappa_1}(o_1,o_1') \times \semKR{\kappa_2}(o_2,o_2'), \\
      & (o_1,o_2) \mapsto (\semKI{\kappa_1}(o_1), \semKI{\kappa_2}(o_2)))
    \end{array}
  \end{array}
\end{displaymath}
The collection of objects of the interpretation of a product kind is
the product of the underlying collections of objects of the two parts,
and the relational component is simply the product of the relational
components. This naturally leads to the identity component being
defined as the tuple of the identity components of the two
parts. Again, by assumption that our collection of small sets is
closed under products, if $\sem{\kappa_1}$ and $\sem{\kappa_2}$ are
small reflexive graphs, then so is $\sem{\kappa_1 \times
  \kappa_2}$. Product kinds generalise to the interpretation of
kinding contexts $\Theta = \alpha_1 : \kappa_1, ..., \alpha_n :
\kappa_n$, which are interpreted as the product of the reflexive graph
interpretations of $\kappa_1, ..., \kappa_n$:
\begin{displaymath}
  \begin{array}{l}
    \sem{\alpha_1 : \kappa_1, ..., \alpha_n : \kappa_n} = \\
    \begin{array}[t]{l@{}l}
      (&\semKU{\kappa_1} \times ... \times \semKU{\kappa_n}, \\
      &(\theta,\theta') \mapsto \semKR{\kappa_1}(\pi_1\theta, \pi_1\theta') \times ... \times \semKR{\kappa_n}(\pi_n\theta, \pi_n\theta'), \\
      &\theta \mapsto (\semKI{\kappa_1}(\pi_1 \theta), ..., \semKI{\kappa_n}(\pi_n \theta)))
    \end{array}
  \end{array}
\end{displaymath}

In Sections~\ref{sec:discrete-kinds} and~\ref{sec:groupoid-kinds}
below, we will extend System F$\omega$ with additional kinds, and
assign them reflexive graph interpretations, making sure that we
maintain Property~\ref{property:semantic-kinds}.

\begin{figure*}[t]
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \sem{\Theta \vdash \alpha_i : \kappa_i}^f \theta & = & \pi_i \theta \\
      \sem{\Theta \vdash \alpha_i : \kappa_i}^r\theta\theta' \rho & = & \pi_i \rho \\
      \\
      \sem{\Theta \vdash \lambda \alpha \mathord: \kappa_1.~A : \kappa_1 \to \kappa_2}^f \theta & = & (
      \begin{array}[t]{@{}l}
        \lambda o \in \semKU{\kappa_1}.\ \sem{A}^f(\theta, o), 
        \lambda o, o' \in \semKU{\kappa_1}, r \in \semKR{\kappa_1}(o,o').\ \sem{A}^r(\theta,o)(\theta,o')(\semKI{\Theta}\theta, r))
      \end{array}\\
      \sem{\Theta \vdash \lambda \alpha \mathord: \kappa_1.~A : \kappa_1 \to \kappa_2}^r \theta\theta' \rho & = &
      \lambda o,o' \in \semKU{\kappa_1}, r \in \semKR{\kappa_1}(o,o').\ \sem{A}^r(\theta,o)(\theta',o')(\rho, r) \\
      \\
      \sem{\Theta \vdash F A : \kappa_2}^f \theta & = & \pi_1 (\sem{F}^f\ \theta)\ (\sem{A}^f\ \theta)\\
      \sem{\Theta \vdash F A : \kappa_2}^r\theta\theta'\rho & = & \sem{F}^r\theta\theta'\rho\ (\sem{A}^f \theta)(\sem{A}^f \theta')(\sem{A}^r\theta\theta'\rho) \\
      \\
      \sem{\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}^f \theta & = & (\sem{A}^f \theta, \sem{B}^f \theta) \\
      \sem{\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}^r \theta \theta' \rho & = & (\sem{A}^r \theta \theta' \rho, \sem{B}^r \theta \theta' \rho) \\
      \\
      \sem{\Theta \vdash \pi_i A : \kappa_i}^f \theta & = & \pi_i (\sem{A}^f \theta) \\
      \sem{\Theta \vdash \pi_i A : \kappa_i}^r \theta \theta' \rho & = & \pi_i (\sem{A}^r \theta \theta' \rho)
    \end{array}
  \end{displaymath}
  \caption{Interpretation of type-level $\lambda$-calculus as reflexive graph morphisms}
  \label{fig:type-level-lambda-calc}
\end{figure*}

\begin{figure*}[t]
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \sem{\Theta \vdash A \to B : *}^f \theta & = & \sem{A}^f\theta \to \sem{B}^f\theta \\
      \sem{\Theta \vdash A \to B : *}^r\theta\theta'\rho & = &
      \{ (f,f') \sepbar \forall (a,a') \in \sem{A}^r\theta\theta'\rho.\ (f~a, f'~a') \in \sem{B}^r\theta\theta'\rho \} \\
      \\
      \sem{\Theta \vdash A \times B : *}^f \theta & = & \sem{A}^f\theta \times \sem{B}^f\theta \\
      \sem{\Theta \vdash A \times B : *}^r\theta\theta'\rho & = &
      \{ ((a,b),(a',b')) \sepbar (a,a') \in \sem{A}^r\theta\theta'\rho, (b,b') \in \sem{B}^r\theta\theta'\rho \} \\
      \\
      \sem{\Theta \vdash \forall \alpha\mathord:\kappa.~A : *}^f \theta &=& \{
      \begin{array}[t]{@{}l}
        x \in (\forall o \in \semKU{\kappa}.\ \sem{A}^f(\theta, o)) \sepbar
        \forall o,o',r \in \semKR{\kappa}(o,o').\ (x~o, x~o') \in \sem{A}^r(\theta,o)(\theta,o')(\semKI{\Theta} \theta, r) \}
      \end{array} \\
      \sem{\Theta \vdash \forall \alpha\mathord:\kappa.~A : *}^r\theta\theta'\rho &=& \{ (x,x') \sepbar \forall o, o', r \in \semKR{\kappa}(o,o').\ (x~o, x'~o') \in \sem{A}^r(\theta,o)(\theta',o')(\rho, r) \}
    \end{array}
  \end{displaymath}
  \caption{Interpretation of basic types as reflexive graph morphisms}
  \label{fig:basic-type-interpretation}
\end{figure*}

\paragraph{Interpretation of Types} Well-kinded types $\Theta \vdash A
: \kappa$ from Figure~\ref{fig:types} are interpreted as reflexive
graph morphisms $\sem{A} : \sem{\Theta} \to \sem{\kappa}$. We sum this
up as a property of our semantics:
\begin{property}\label{property:semantic-types}
  Each well-kinded type $\Theta \vdash A : \kappa$ is interpreted as a
  reflexive graph morphism $\sem{A} : \sem{\Theta} \to \sem{\kappa}$,
  such that if $\Theta \vdash A \equiv B : \kappa$ then $\sem{A} =
  \sem{B}$.
\end{property}
%
% That is, every well-kinded type is interpreted as a pair $(\sem{A}^f,
% \sem{A}^r)$ of functions $\sem{A}^f : \sem{\Theta}^O \to
% \sem{\kappa}^O$ and $\sem{A}^r : \forall o, o'.~\sem{\Theta}^R(o,o')
% \to \sem{\kappa}^R(\sem{A}^f~o, \sem{A}^f~o')$, such that identity
% edges are preserved.
%
The interpretation of the $\lambda$-calculus fragment (i.e.,
variables, $\lambda$-abstraction and application, and products) of the
language of well-kinded types is displayed in
Figure~\ref{fig:type-level-lambda-calc}. The interpretations are
unsurprising given the reflexive graph interpretation of the kinds
$\kappa_1 \to \kappa_2$ and $\kappa_1 \times \kappa_2$ we gave above.

Figure~\ref{fig:basic-type-interpretation} shows the interpretations
of the basic type constructors for function and product types, and
of universal quantification. Each of these constructs builds an object of
kind $*$, so the object-level interpretation is a small set in $\Set$,
and the relation-level interpretation is an actual relation. In the
cases of the function and product types, the object-level
interpretation is just as set-theoretic function and product
respectively, and the relation-level interpretation uses the standard
logical relations interpretations of these type
constructors. Universal quantification, $\forall
\alpha\mathord:\kappa.~A$, is interpreted at the object level by
taking the dependent product over the objects of the interpretation of
$\kappa$ (this product exists because we have stipulated that $\kappa$
must be small), and then restricting to those elements of the
dependent product that preserve relations. This restriction is
required for this interpretation to preserve identity edges, and so be
a reflexive graph morphism. The relation-level interpretation of
universal quantification is the standard relational interpretation of
such types, albeit here generalised to kinds interpreted as arbitrary
reflexive graphs.

Well-kinded typing contexts $\Theta \vdash \Gamma$ are interpreted as
reflexive graph morphisms $\sem{\Gamma} : \sem{\Theta} \to \sem{*}$ by
taking the product of the interpretations of their constituent types,
similar to the interpretation of the product types $A \times B$.

We will extend basic System F$\omega$ with additional types and type
equalities in Sections~\ref{sec:discrete-kinds},
\ref{sec:groupoid-kinds}, and~\ref{sec:types-for-classical-mech},
below. These new types will also be assigned interpretations as
reflexive graph morphisms, and we will ensure that
Property~\ref{property:semantic-types} is maintained.

\paragraph{Interpretation of Terms} We omit the straightforward and
relatively uninteresting interpretation of well-typed terms $\Theta
\sepbar \Gamma \vdash e : A$, and just state that there is a
well-defined function interpreting each well-typed term, with the
property that it takes related environments to related results; this
is the fundamental theorem of logical relations for System F$\omega$:

\begin{property}\label{property:semantic-terms}
  For all well-typed terms $\Theta \sepbar \Gamma \vdash e : A$ there
  is a function $\sem{e} \in (\forall \theta \in \semKU{\Theta}.\
  \sem{\Gamma}^f\theta \to \sem{A}^f\theta)$, such that, for all
  $\theta, \theta' \in \semKU{\Theta}$, $\rho \in
  \semKR{\Theta}(\theta,\theta')$, $\gamma \in \sem{\Gamma}^f\theta$
  and $\gamma' \in \sem{\Gamma}^f\theta'$, if $(\gamma, \gamma') \in
  \sem{\Gamma}^r\theta\theta'\rho$ then $(\sem{e}\theta\gamma,
  \sem{e}\theta'\gamma') \in \sem{A}^r\theta\theta'\rho$.  Moreover,
  this interpretation is sound for the $\beta\eta$ equational theory
  of terms.
\end{property}

\subsection{Discrete Kinds}
\label{sec:discrete-kinds}

In Section~\ref{sec:refl-graphs-for-fomega}, we only had a single base
kind: the kind $*$ of proper types, with a specific interpretation as
the reflexive graph of sets and relations. We now describe two
families of base kinds with interpretations that are particular sorts
of reflexive graph. In this section, we look at discrete kinds; kinds
whose reflexive graph interpretations are such that the reflexive
edges are the only edges between objects. In the following section
(Section~\ref{sec:groupoid-kinds}), we look at groupoid kinds, where
edges are composable and invertible.

Discrete kinds can be seen as the natural way of lifting types up to
the kind level. For our purposes, we will only require a kind of
natural numbers, which we will use for constructing $n$-ary vectors of
positions and velocities when we use our type system for writing
Lagrangians in Section~\ref{sec:types-for-classical-mech}. The kind of
natural numbers is small:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{nat}

  \inferrule*
  { }
  {\mathsf{nat}~\mathrm{small}}
\end{mathpar}
The interpretation of this kind as a reflexive graph goes as follows:
\begin{displaymath}
  \sem{\mathsf{nat}} = (\mathbb{N}, (n_1,n_2) \mapsto \{ * \sepbar n_1 = n_2 \}, n \mapsto *)
\end{displaymath}
The collection of objects of this reflexive graph is simply the set of
natural numbers. The only edges in the graph are unique edges between
equal numbers. Since we have assumed that our collection of small sets
contains the natural numbers, we have clearly maintained
Property~\ref{property:semantic-kinds} of our semantics.

We add new type-level constructs for the kind $\mathsf{Nat}$ of
natural numbers, representing zero and successor, and a kind-generic
recursion operator:
\begin{mathpar}
  \inferrule*
  { }
  {\Theta \vdash \mathit{zero} : \mathsf{nat}}

  \inferrule*
  {\Theta \vdash A : \mathsf{nat}}
  {\Theta \vdash \mathit{succ}~A : \mathsf{nat}}

  \inferrule*
  {\Theta \vdash A : \mathsf{nat} \\
    \Theta \vdash B : \kappa \\
    \Theta \vdash C : \kappa \to \kappa}
  {\Theta \vdash \mathit{natrec}_\kappa~A~B~C : \kappa}
\end{mathpar}
These three constructs all have the evident interpretations in terms
of the inductive structure of the natural numbers, and satisfy the
following $\beta$-laws, maintaining
Property~\ref{property:semantic-types} of our semantics:
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathit{natrec}_\kappa~\mathit{zero}~B~C & \equiv & B \\
    \mathit{natrec}_\kappa~(\mathit{succ}~A)~B~C & \equiv & C~(\mathit{natrec}_\kappa~A~B~C)
  \end{array}
\end{displaymath}


\subsection{Groupoid Kinds}
\label{sec:groupoid-kinds}

Discrete kinds are useful for lifting types up to the kind level, but
they do not really exploit the flexibility of reflexive
graphs. Moreover, they do not provide us with the invariance
properties we require to apply Noether's theorem. By considering kinds
whose interpretations are groupoids, we will be able to derive the
invariance properties that we need.

Recall that a groupoid is a category in which all morphisms have
inverses \cite{maclane98categories}. Functors between categories
always preserve isomorphisms, so morphisms of groupoids are just
functors. Every group is a groupoid with one object, and a morphism
from this object to itself for every element of the group: composition
is the group operation, inverses are given by the group inverses, and
the identity morphism is given by the group unit. Homomorphisms
between groups are in one-to-one correspondence with functors between
the corresponding groupoids. An example of a groupoid that is not a
group is given by the collection of cartesian spaces (i.e.,
$\mathbb{R}^n$ for some $n$), with all diffeomorphisms (smooth
functions with smooth inverses) as the morphisms.

Trivially, every groupoid is a reflexive graph, simply by forgetting
the composition and inverses. Likewise, every functor between
groupoids is a morphism of reflexive graphs, by forgetting the
preservation of composition. Therefore, given any groupoid, we can add
a new kind to System F$\omega$ that is interpreted by that groupoid,
and given any functor $f : \sem{\mathsf{G_1}} \to \sem{\mathsf{G_2}}$
between groupoids interpreting kinds $\mathsf{G_1}$ and
$\mathsf{G_2}$, we obtain a type constant of kind $\mathsf{G_1} \to
\mathsf{G_2}$, with interpretation $f$.

\paragraph{Integers} Our first groupoid kind is $\mathsf{Z}$,
interpreted by additive group of integers. We will use this kind to
state the types of the trigonometric functions $\sin$ and $\cos$ in
Section~\ref{sec:types-for-classical-mech-1}, which are periodic with
period $2\pi$. The kind $\mathsf{Z}$ is small:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{Z}

  \inferrule*{ }{\mathsf{Z}~\mathrm{small}}
\end{mathpar}
The kind $\mathsf{Z}$ has the following interpretation as a reflexive
graph:
\begin{displaymath}
  \sem{\mathsf{Z}} = (\{*\}, \lambda (*, *).~\mathbb{Z}, \lambda \mathord*.~0)
\end{displaymath}
Note the difference between this interpretation and the interpretation
of the kind $\mathsf{Nat}$ in the previous section. In the
interpretation of $\mathsf{Nat}$, the objects were complex and the
relations were trivial. The reflexive graph interpreting $\mathsf{Z}$
has a trivial collection of objects, but a rich structure at the
relation level, given by the group of integers. This structure means
that we can add the following type-level constants to our system:
\begin{mathpar}
  \inferrule*
  { }
  {\Theta \vdash 0 : \mathsf{Z}}

  \inferrule*
  {\Theta \vdash A : \mathsf{Z} \\ \Theta \vdash B : \mathsf{Z}}
  {\Theta \vdash A + B : \mathsf{Z}}

  \inferrule*
  {\Theta \vdash A : \mathsf{Z}}
  {\Theta \vdash -A : \mathsf{Z}}
\end{mathpar}
Each of these constants has a trivial object-level interpretation, due
to the trivial collection of objects in the reflexive graph
$\sem{\mathsf{Z}}$. At the relation-level, the interpretations are
simply given using the group structure of the integers. These
interpretations satisfy the abelian group axioms, so we add these
axioms to the type-level equations.

\paragraph{Translation and Linear Transformation Groups} The group of
integers is not suitable for stating the invariance properties we
require to apply Noether's theorem. To do so, we require groups of
translations and invertible linear transformations. We extend our type
system with small kinds representing $n$-dimensional ($n \geq 0$)
translations, invertible linear transformations, and orthogonal
transformations:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{T}(n) \sepbar \mathsf{GL}(n) \sepbar \mathsf{O}(n)

  \inferrule*{ }{\mathsf{T}(n), \mathsf{GL}(n), \mathsf{O}(n)~\mathrm{small}}
\end{mathpar}
The interpretations of these kinds follow the same pattern as for the
kind $\mathsf{Z}$ above. Each interpretation is a reflexive graph with
a trivial collection of objects, and relations taken from the
appropriate group:
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\mathsf{T}(n)} &=& (\{*\}, \lambda (*,*).~\mathbb{R}^n, \lambda \mathord*.~\vec{0}) \\
    \sem{\mathsf{GL}(n)} &=& (\{*\}, \lambda (*,*).~\mathrm{GL}(n), \lambda \mathord*. I) \\
    \sem{\mathsf{O}(n)} &=& (\{*\}, \lambda (*,*).~\mathrm{O}(n), \lambda \mathord*. I)
  \end{array}
\end{displaymath}
Here, we take $\mathrm{GL}(n)$ to be exactly the group of invertible
real $n\times n$ matricies, and $\mathrm{O}(n)$ to be the group of
$n\times n$ orthogonal matricies (recall that an orthogonal matrix is
one whose transpose is equal to its inverse).  We add the group
operations and group axioms for each of these groupoid kinds in the
same way as we did for the kind $\mathsf{Z}$ above, except that we use
multiplicative notation for the kinds $\mathsf{GL}(n)$ and
$\mathsf{O}(n)$. Note that, except for $\mathsf{GL}(0)$,
$\mathsf{GL}(1)$, $\mathsf{O}(0)$ and $\mathsf{O}(1)$, the groups
$\mathsf{GL}(n)$ and $\mathsf{O}(n)$ are not abelian.

We also extend our type system with the following type-level
constants. Each of these is interpreted by the correspondingly named
homomorphism between the groups involved. For example,
$\mathit{scale}_n$ is interpreted by the homomorphism $\mathrm{GL}(1)
\to \mathrm{GL}(n)$ that takes a non-zero real number $s$ to the
matrix with $s$s along the diagonal and zeros elsewhere.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathit{exp} &:& \mathsf{T}(1) \to \mathsf{GL}(1) \\
    \mathit{ortho}_n &:& \mathsf{O}(n) \to \mathsf{GL}(n) \\
    \mathit{scale}_n &:& \mathsf{GL}(1) \to \mathsf{GL}(n) \\
    \underline{c}*- &:& \mathsf{Z} \to \mathsf{T}(1) 
  \end{array}
\end{displaymath}
In the last of these $\underline{c}$ stands for an arbitrary real
constant.  Since each of these is interpreted by a group homomorphism,
we are justified in adding the group homomorphism laws as axioms to
our type-level equational theory, maintaining
Property~\ref{property:semantic-types}.

\paragraph{The Groupoid of Cartesian Spaces} Finally in this section,
we introduce the groupoid kind of cartesian spaces, which we will use
for the configuration spaces of the classical mechanical systems we
describe in our system. As we noted above, the collection of cartesian
spaces is a groupoid with a non-trivial collection of objects. We
extend our system with a kind of cartesian spaces:
\begin{displaymath}
  \kappa ::= \cdots \sepbar \mathsf{CartSp}
\end{displaymath}
with the following interpretation:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\mathsf{CartSp}} = \\
    \quad (\mathbb{N}, \lambda m,n.~\{ f : \mathbb{R}^m \to \mathbb{R}^n \sepbar f\textrm{ a diffeomorphism}\}, \lambda n.~\mathrm{id}_{\mathbb{R}^n})
  \end{array}
\end{displaymath}
We have chosen to represent cartesian spaces of dimension $n$ just as
the natural number $n$. This gives us a canonical representation of
$n$-dimensional space for each $n$, avoiding tricky problems with
isomorphic constructions of the same space.

Cartesian spaces are closed under products:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp} \\ \Theta \vdash Y : \mathsf{CartSp}}
  {\Theta \vdash X \times Y : \mathsf{CartSp}}
\end{displaymath}
with the following interpretation, where the cartesian product of
cartesian spaces adds their dimensions, and composes diffeomorphisms
``in parallel'':
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{X \times Y}^f \theta & = & \sem{X}^f \theta + \sem{Y}^f \theta \\
    \sem{X \times Y}^r \theta \theta' \rho & = & \lambda (\vec{x},\vec{y}).~(\sem{X}^r\theta\theta'\rho \vec{x}, \sem{Y}^r\theta\theta'\rho \vec{y})
  \end{array}
\end{displaymath}

Cartesian spaces are generated by the following construct that yields
the $n$-dimensional cartesian space ($n \geq 0$) that varies with the
given invertible linear transformation and translation:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash G : \mathsf{GL}(n) \\ \Theta \vdash T : \mathsf{T}(n)}
  {\Theta \vdash \mathbb{R}^n\langle G, T \rangle : \mathsf{CartSp}}
\end{displaymath}
As a notational convenience, we write $\mathbb{R}^1\langle G, T
\rangle$ as just $\mathbb{R}\langle G, T \rangle$ and
$\mathbb{R}^0\langle G, T \rangle$ as just $\mathbb{R}^0$.

The type $\mathbb{R}^n\langle G, T \rangle$ has the following
interpretation as a reflexive graph morphism:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\mathbb{R}^n\langle G, T \rangle}^f \theta & = & n \\
    \sem{\mathbb{R}^n\langle G, T \rangle}^r \theta \theta' \rho & = & \lambda \vec{x}.~(\sem{G}^r \theta \theta' \rho) \vec{x} + \sem{T}^r \theta \theta' \rho
  \end{array}
\end{displaymath}
Note that $\sem{\mathbb{R}^n\langle G, T \rangle}^r \theta \theta'
(\semKI{\Theta}\theta)$ is the identity diffeomorphism, so this
interpretation preserves identity edges, exactly as required in the
definition of reflexive graph morphisms. Consequently, the
interpretation of $\mathbb{R}^n\langle G, T \rangle$, and also the
interpretation for products of cartesian spaces, preserves
Property~\ref{property:semantic-types}.

Using the type-level natural numbers and their recursion operator, we
can define a type of $n$-ary products of a cartesian space:
\begin{displaymath}
  \mathit{vec} = \lambda n\mathord:\mathsf{Nat}, X\mathord:\mathsf{CartSp}.~\mathit{natrec}~n~\mathbb{R}^0~(\lambda x.~X \times x)
\end{displaymath}
$n$-ary products of cartesian spaces will be useful in
Section~\ref{sec:examples} when we define Lagrangians describing
systems that are generic in the number of particles involved.

Finally, we include an operator that takes any cartesian space to
its corresponding proper type:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp}}
  {\Theta \vdash \typeOfCartSp{X} : *}
\end{displaymath}
with the following straightforward interpretation:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\typeOfCartSp{X}}^f\theta & = & \mathbb{R}^{\sem{X}^f\theta} \\
    \sem{\typeOfCartSp{X}}^r\theta\theta'\rho & = & \{ (\vec{x}, \vec{x'}) \sepbar (\sem{X}^r\theta\theta'\rho)\vec{x} = \vec{x'} \}
  \end{array}
\end{displaymath}



% \subsection{Why not Groupoids Everywhere?}

% Given that we crucially use groupoid kinds in our model in order 

% Explain why we aren't using groupoids as kinds: don't need to, doesn't
% directly generalise relational parametricity, see Robinson's
% paper. Distance-indexed types.

\section{A Type System for Classical Mechanics}
\label{sec:types-for-classical-mech}

In the previous section we constructed a way to derive invariance
properties from types. In
Section~\ref{sec:conservation-laws-from-symmetry}, we saw that
Noether's theorem is a method for deriving conservation laws for
classical mechanical systems from their invariance properties. In this
section, we construct a type system for constructing invariant
Lagrangians. In the following section, Section~\ref{sec:examples}, we
present several uses of our type system for defining invariant
Lagrangians that describe many different kinds of classical mechanical
systems.

\subsection{Extending System F$\omega$ with Smooth Functions}
\label{sec:types-for-classical-mech-1}

\paragraph{The Type of Smooth Functions} Given a pair of cartesian
spaces $X$ and $Y$ we provide a way to construct the type of smooth
invariant smooth functions from $X$ to $Y$:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp} \\
    \Theta \vdash Y : \mathsf{CartSp}}
  {\Theta \vdash C^\infty(X, Y) : *}
\end{displaymath}
with the following interpretation. Since $C^\infty(X,Y)$ is a proper
type, the relational interpretation in this case is a genuine
relation. We relate functions that are invariant under the
diffeomorphism interpretations of $X$ and $Y$ in the current
relational context $\rho$:
\begin{displaymath}
  \begin{array}{@{\hspace{0.05em}}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{C^\infty(X,Y)}^f\theta & = & \{ f : \mathbb{R}^{\sem{X}^f\theta} \to \mathbb{R}^{\sem{Y}^f\theta} \sepbar f\textrm{ smooth} \} \\
    \sem{C^\infty(X,Y)}^f\theta\theta'\rho & = & \{
    \begin{array}[t]{@{}l}
      (f,f') \sepbar \forall \vec{x} \in \mathbb{R}^{\sem{X}^f\theta}.\\
      \quad (\sem{Y}^r\theta\theta'\rho)(f~\vec{x}) = f'~(\sem{X}^r\theta\theta'\rho \vec{x}) \}
    \end{array}
  \end{array}
\end{displaymath}

\paragraph{An Example Free Theorem} We are now in a position to
formally show how we can use the relationally parametric model we have
defined to derive invariance properties. Consider a closed term with
the following type:
\begin{displaymath}
  e : \forall o : \mathsf{O}(n).~C^\infty(\mathbb{R}^n\langle \mathit{ortho}_n(o), 0 \rangle, \mathbb{R}\langle 1, 0 \rangle)
\end{displaymath}
We can deduce, from Property~\ref{property:semantic-terms} and the
relational interpretations of all the types involved, that the
denotation of $e$ satisfies the following free theorem:
\begin{displaymath}
  \forall O \in \mathrm{O}(n).~\forall \vec{x} \in \mathbb{R}^n.~\sem{e}(O\vec{x}) = \sem{e}(\vec{x})
\end{displaymath}
This free theorem is exactly the kind of invariance property we
require to apply Noether's theorem. Compare the form of the statement
here, with the mildly more general statement of
Equation~\ref{eq:simplest-invariance}, back in
Section~\ref{sec:conservation-laws-from-symmetry}. Moreover, $\sem{e}$
is a smooth function from $\mathbb{R}^n$ to $\mathbb{R}$, just as we
require for Lagrangian mechanics.

\paragraph{Combinators for Smooth Functions} Of course, such free
theorems are pointless without ways to build elements of the smooth
function spaces. We now extend our type system, for the last time,
with a set of term-level constants for constructing smooth functions,
invariant under linear transformations and translations.

Our first set of combinators constructs constant and identity smooth
functions, and composes smooth functions between cartesian spaces. We
also have combinators for pairing and projection for the product of
cartesian spaces.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathrm{const} &:& \typeOfCartSp{Y} \to C^\infty(X, Y) \\
    \mathrm{id} &:& C^\infty(X,X) \\
    (\comp) &:& C^\infty(X,Y) \to C^\infty(Y,Z) \to C^\infty(X,Z) \\
    \mathrm{pair} &:& C^\infty(X,Y) \to C^\infty(X,Z) \to C^\infty(X, Y \times Z) \\
    \mathrm{proj_1}&:& C^\infty(X \times Y, X) \\
    \mathrm{proj_2}&:& C^\infty(X \times Y, Y) \\
  \end{array}
\end{displaymath}

Next, we include combinators for constant, invariant, vectors, the
zero vector, vector addition, subtraction and scaling. We also include
the Euclidean dot product of vectors. The type dot product operation
is where the orthogonal group kind $\mathsf{O}(n)$ is used: the dot
product of vectors is invariant under orthogonal transformations.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \underline{\vec{c}} &:& \typeOfCartSp{\mathbb{R}^n\langle 1, 0 \rangle} \\
    0 &:& \forall g \mathord: \mathsf{GL}(n).~\typeOfCartSp{\mathbb{R}^n\langle g, 0 \rangle} \\
    (+) &:&
    \begin{array}[t]{@{}l}
      \forall g \mathord: \mathsf{GL}(n), t_1,t_2 \mathord: \mathsf{T}(n). \\
      \hspace{1.5cm} C^\infty(\mathbb{R}^n\langle g, t_1 \rangle \times \mathbb{R}^n\langle g, t_2 \rangle, \mathbb{R}^n\langle g, t_1 + t_2 \rangle)\\
    \end{array} \\
    (-) &:&
    \begin{array}[t]{@{}l}
      \forall g \mathord: \mathsf{GL}(n), t_1,t_2 \mathord: \mathsf{T}(n). \\
      \hspace{1.5cm} C^\infty(\mathbb{R}^n\langle g, t_1 \rangle \times \mathbb{R}^n\langle g, t_2 \rangle, \mathbb{R}^n\langle g, t_1 - t_2 \rangle)\\
    \end{array} \\
    (*) &:&
    \begin{array}[t]{@{}l}
      \forall g_1 \mathord: \mathsf{GL}(1), g_2 \mathord: \mathsf{GL}(n).\\
      \quad C^\infty(\mathbb{R}\langle g_1, 0 \rangle \times \mathbb{R}^n\langle g_2, 0\rangle, \mathbb{R}^n\langle \mathit{scale}_n(g_1)g_2, 0 \rangle)
    \end{array}
    \\
    (\cdot) &:& 
    \begin{array}[t]{@{}l}
      \forall g \mathord: \mathsf{GL}(1), o \mathord: \mathsf{O}(n).~\\
      C^\infty(\mathbb{R}^n\langle (\mathit{scale}_n~g)(\mathit{ortho}_n~o), 0 \rangle \times \\
      \quad\quad\; \mathbb{R}^n\langle (\mathit{scale}_n~g)(\mathit{ortho}_n~o), 0\rangle, \mathbb{R}\langle (\mathit{scale}_n~g)^2, 0 \rangle)
    \end{array}
  \end{array}
\end{displaymath}
Each of these combinators has a straightforward interpretation as a
smooth function, and the proof that the fundamental theorem of logical
relations is maintained for our system (i.e., that
Property~\ref{property:semantic-terms} is maintained) follows
directly from elementary facts about linear algebra.

It will be useful for our examples to have the following trigonometric
functions, exponential function and division operation. The types of
each of these functions describes some of their invariance properties,
such as the periodicity of the $\sin$ and $\cos$ functions. A
technical problem with our current system is that we do not account
for the non-definedness of division at $0$, nor do we account for the
square root of negative numbers. However, division and square root
will be useful in our examples in Section~\ref{sec:examples}, so we
take a pragmatic approach, in common with most physics textbooks, and
informally treat them as total functions.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sin &:& \forall z \mathord: \mathsf{Z}.~C^\infty(\mathbb{R}\langle 1, \underline{2\pi} * z \rangle, \mathbb{R} \langle 1, 0 \rangle) \\
    \cos &:& \forall z \mathord: \mathsf{Z}.~C^\infty(\mathbb{R}\langle 1, \underline{2\pi} * z \rangle, \mathbb{R} \langle 1, 0 \rangle) \\
    \mathrm{exp} &:& \forall t \mathord: \mathsf{T}(1).~C^\infty(\mathbb{R}\langle 1, t \rangle, \mathbb{R}\langle \mathit{exp}~t, 0 \rangle) \\
    (/) &:& \forall g_1, g_2 \mathord: \mathsf{GL}(1).~C^\infty(\mathbb{R}\langle g_1, 0 \rangle \times \mathbb{R}\langle g_2, 0\rangle, \mathbb{R}\langle g_1g_2^{-1}, 0 \rangle) \\
    \mathrm{sqrt} &:& \forall g \mathord: \mathsf{GL}(1).~C^\infty(\mathbb{R}\langle g\cdot g, 0 \rangle, \mathbb{R}\langle g, 0 \rangle)
  \end{array}
\end{displaymath}

Finally, we include three primitive combinators for dealing with
$n$-ary products of vectors. These combinators will be useful when
defining Lagrangians that are generic in the number of particles.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathrm{sum} &:& \forall n \mathord: \mathsf{Nat}, g \mathord: \mathsf{GL}(1). C^\infty(\mathit{vec}~n~(\mathbb{R}\langle g, 0 \rangle), \mathbb{R}\langle g, 0\rangle) \\
    \mathrm{map} &:& \forall n \mathord: \mathsf{Nat}. C^\infty(Z \times X,Y) \to C^\infty(Z \times \mathrm{vec}~n~X, \mathrm{vec}~n~Y) \\
    \mathrm{cross} &:& 
    \begin{array}[t]{@{}l}
      \forall m,n \mathord: \mathsf{Nat}.\\
      \quad\quad C^\infty(\mathit{vec}~m~X \times \mathit{vec}~n~Y, \mathit{vec}~(m*n)~(X \times Y))
    \end{array}
  \end{array}
\end{displaymath}
The combinator $\mathrm{sum}$ sums the list of real numbers it is
given, while $\mathrm{cross}$ takes the cartesian product of two
vectors of elements of cartesian spaces, and $\mathrm{map}$ maps the
given smooth function over a vector. The multiplication of natural
numbers $m*n$ is straightforwardly defined in terms of the
$\mathit{natrec}$ recursion operator. We will use $\mathrm{cross}$ in
Section~\ref{sec:examples} to define Lagrangians in terms of the
interactions between systems of particles.

\subsection{A Surface Syntax for Smooth Functions}
\label{sec:surface-syntax}

\begin{figure*}[t]
  \centering
  \textbf{Administrative rules}
  \begin{mathpar}
    \inferrule*
    {z : \typeOfCartSp{X} \in \Gamma}
    {\Theta \sepbar \Gamma; \Delta \vdash z : X}

    \inferrule*
    {x : X \in \Delta}
    {\Theta \sepbar \Gamma; \Delta \vdash x : X}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : X_1 \times ... \times X_n \\
      \Theta \sepbar \Gamma; \Delta, x_1 : X_1, ..., x_n : X_n \vdash e_2 : Y}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{let}~x_1, ..., x_n = e_1~\mathrm{in}~e_2 : Y}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : C^\infty(X, Y) \\\\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : X}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 (e_2) : Y}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : X \\
      ... \\
      \Theta \sepbar \Gamma; \Delta \vdash e_n : X_n}
    {\Theta \sepbar \Gamma; \Delta \vdash (e_1, ..., e_n) : X_1 \times ... \times X_n}
  \end{mathpar}

  \medskip
  \textbf{Vector space operations, and dot product}
  \begin{mathpar}
    \inferrule*
    {\vec{c} \in \mathbb{R}^n}
    {\Theta \sepbar \Gamma; \Delta \vdash \vec{c} : \mathbb{R}^n\langle 1, 0 \rangle}

    \inferrule*
    {\Theta \vdash G : \mathsf{GL}(n)}
    {\Theta \sepbar \Gamma; \Delta \vdash 0 : \mathbb{R}^n\langle G, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle G, T_1 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle G, T_2 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 + e_2 : \mathbb{R}^n\langle G, T_1 + T_2 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle G, T_1 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle G, T_2 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 - e_2 : \mathbb{R}^n\langle G, T_1 - T_2 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}\langle G_1, 0 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle G_2, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 e_2 : \mathbb{R}^n\langle \mathit{scale}_n(G_1)G_2, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle \mathit{scale}_n(G)\mathit{ortho}_n(O), 0 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle \mathit{scale}_n(G)\mathit{ortho}_n(O), 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 \cdot e_2 : \mathbb{R}\langle\mathit{scale}_n(G)^2, 0 \rangle}
  \end{mathpar}

  \medskip
  \textbf{Transcendental functions}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 1, T \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{exp}~e : \mathbb{R}\langle \mathit{exp}~T, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 1, \underline{2\pi} * Z \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{sin}~e : \mathbb{R}\langle 1, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 1, \underline{2\pi} * Z \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{cos}~e : \mathbb{R}\langle 1, 0 \rangle}
  \end{mathpar}

  \medskip
  \textbf{Division, square root, sum, and cross}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}\langle G_1, 0 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}\langle G_2, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \frac{e_1}{e_2} : \mathbb{R}\langle G_1G_2^{-1}, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle G^2, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{sqrt}~e : \mathbb{R}\langle G, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathit{vec}~N~(\mathbb{R}\langle G, 0 \rangle)}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{sum}~e : \mathbb{R}\langle G, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta, x : X \vdash e_1 : Y \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathit{vec}~N~X}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{map}~(x.~e_1)~e_2 : \mathit{vec}~N~Y}
    
    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathit{vec}~M~X \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathit{vec}~N~Y}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{cross}~e_1~e_2 : \mathit{vec}~(M*N)~(X \times Y)}
  \end{mathpar}

  \caption{A surface syntax for smooth functions}
  \label{fig:smooth-terms}
\end{figure*}

\begin{figure}
  \centering
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \elab{z}_\Delta & = & \mathrm{const}~z \\
      \elab{x}_\Delta & = & \underline{\mathrm{project}_\Delta}(x) \\
      \elab{\mathrm{let}~\vec{x} = e_1\textrm{ in }e_2}_\Delta & = & \mathrm{pair}~\mathrm{id}~\elab{e_1}_\Delta \comp \elab{e_2}_{\Delta, \vec{x}} \\
      \elab{(e_1,...,e_n)}_\Delta &=& \underline{\mathrm{pair}_n}(\elab{e_1}_\Delta, ..., \elab{e_n}_\Delta) \\
      \elab{e_1(e_2)}_\Delta &=& \elab{e_2}_\Delta \comp e_1 \\
      \elab{\vec{c}}_\Delta &=& \mathrm{const}~\vec{c} \\
      \elab{0}_\Delta &=& \mathrm{const}~0 \\
      \elab{e_1 + e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp (+) \\
      \elab{e_1 - e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp (-) \\
      \elab{e_1 e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp (*) \\
      \elab{e_1 \cdot e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp (\cdot) \\
      \elab{\sin~e}_\Delta &=& \elab{e}_\Delta \comp \sin \\
      \elab{\cos~e}_\Delta &=& \elab{e}_\Delta \comp \cos \\
      \elab{\mathrm{exp}~e}_\Delta &=& \elab{e}_\Delta \comp \mathrm{exp} \\
      \elab{e_1 / e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp (/) \\
      \elab{\mathrm{sqrt}~e}_\Delta &=& \elab{e}_\Delta \comp \mathrm{sqrt} \\
      \elab{\mathrm{sum}~e}_\Delta &=& \elab{e}_\Delta \comp \mathrm{sum} \\
      \elab{\mathrm{map}~(x.~e_1)~e_2}_\Delta &=& \mathrm{pair}~\mathrm{id}~\elab{e_2}_\Delta \comp (\mathrm{map}~\elab{e_1}_{\Delta,x}) \\
      \elab{\mathrm{cross}~e_1~e_2}_\Delta &=& \mathrm{pair}~\elab{e_1}_\Delta~\elab{e_2}_\Delta \comp \mathrm{cross}
    \end{array}
  \end{displaymath}
  \caption{Desugaring of the surface syntax}
  \label{fig:desugar}
\end{figure}

The combinators we have presented allow the construction of smooth
invariant functions, but doing so is painful due to the point-free
style that they force. In order to be able to actually define readable
Lagrangians in our calculus, we define a surface syntax for writing
smooth functions that is desugared into our extended version of System
F$\omega$.

We define a typing judgement of smooth terms $\Theta \sepbar \Gamma;
\Delta \vdash e : X$ by the rules in Figure~\ref{fig:smooth-terms},
where $\Theta$ and $\Gamma$ are the kinding and typing contexts of our
extension of F$\omega$, and $\Delta = x_1 : X_1, ..., x_n : X_n$ is a
context of cartesian spaces. That is, for each $x : X$ in $\Delta$, we
have $\Theta \vdash X : \mathsf{CartSp}$.

The desugaring of smooth function terms into our extension of System
F$\omega$ is via the operation $\elab{-}_\Delta$, defined in
Figure~\ref{fig:desugar}. In this definition, we make use of two
derived combinators for projection and pairing:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \underline{\mathrm{project}_{x : X, \Delta}}(x) & = & \mathrm{proj_1} \\
    \underline{\mathrm{project}_{y : Y, \Delta}}(x) & = & \mathrm{proj_2} \comp \underline{\mathrm{project}_\Delta}(x) \quad (x \not= y)
  \end{array}
\end{displaymath}
and
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \underline{\mathrm{pair}_1}(e) & = & e \\
    \underline{\mathrm{pair}_{n+1}}(e, \vec{e}) & = & \mathrm{pair}~e~(\underline{\mathrm{pair}_n}(\vec{e}))
  \end{array}
\end{displaymath}
The following theorem follows easily by induction on the typing
derivations of smooth terms, where $\elab{\Delta} = \elab{x_1 : X_1,
  ..., x_n : X_n} = X_1 \times ... \times X_n$:
\begin{theorem}
  If $\Theta |\Gamma; \Delta \vdash e : X$ then $\Theta |
  \Gamma \vdash \elab{e}_\Delta : C^\infty(\elab{\Delta}, X)$.
\end{theorem}

\section{Examples of Conservation Laws from Types}
\label{sec:examples}

We now present a number of examples of classical mechanical systems
expressible in the type system we constructed in the previous section,
and derive the free theorems and consequent conserved properties for
each one. These examples are all standard examples demonstrating the
application of Lagrangian mechanics (see, for example, Landau and
Lifschitz \cite{landau60mechanics}). Our contribution here is to
express them in a type system that makes clear their invariance
properties.

\subsection{Single Particles}

% $- \sepbar V : \forall ... . C^\infty(\mathbb{R}^3\langle o, t \rangle, \mathbb{R}\langle 1, 0 \rangle); t : \mathbb{R}\langle 1, t_t \rangle, q : \mathbb{R}^3\langle o, t_q \rangle, \dot{q} : \mathbb{R}^3\langle o, 0 \rangle \vdash \frac{1}{2} * m * (\dot{q} \cdot \dot{q}) - V(q) : \mathbb{R}\langle 1, 0 \rangle$

\paragraph{Free Particle}

Our first example is of a simple Lagrangian for a single free particle
in $3$-dimensional space, with no external forces. We define the
Lagrangian using the syntax for smooth terms we defined in the
previous section, in the following kinding, typing and cartesian space
contexts:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & t_t : \mathsf{T}(1), t_x : \mathsf{T}(3), o : \mathsf{O}(3) \\
    \Gamma = & m : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle} \\
    \Delta = & t : \mathbb{R}\langle 1, t_t \rangle, x : \mathbb{R}^3\langle \mathit{ortho}_3(o), t_x \rangle, \dot{x} : \mathbb{R}^3\langle \mathit{ortho}_3(o), 0 \rangle
  \end{array}
\end{displaymath}
where $o$ represents an arbitrary orthogonal transformation of the
space, $t_t$ represents a translation in time, $t_x$ represents a
$3$-dimensional translation in space, $m$ is the constant mass of the
free particle, $t$ is the current time, $x$ is the current position of
the particle, and $\dot{x}$ is the current velocity.

We write the Lagrangian like so, which in the absence of external
forces just consists of the kinetic energy term:
\begin{displaymath}
  L = \frac{1}{2}m(\dot{x} \cdot \dot{x}) : \mathbb{R}\langle 1, 0 \rangle
\end{displaymath}

By the fundamental theorem of logical relations for our calculus
(Property~\ref{property:semantic-terms}), we can derive the following
free theorems, one each for the three group parameters $t_t$, $t_x$
and $o$. Quantifying over translations in time, $t_t$, gives us
invariance under translation in time:
\begin{displaymath}
  \forall t_t \in \mathbb{R}.~\sem{L}(t + t_t, \vec{x}, \dot{\vec{x}}) = \sem{L}(t, \vec{x}, \dot{\vec{x}})
\end{displaymath}
As we saw in Example~\ref{ex:conservation-laws}, Noether's theorem
tells us that invariance under translation in time yields conservation
of energy. Likewise, quantifying over translations in space, $t_x$,
gives us invariance under translation in space:
\begin{displaymath}
  \forall \vec{t_x} \in \mathbb{R}^3.~\sem{L}(t, \vec{x} + \vec{t_x}, \dot{\vec{x}}) = \sem{L}(t, \vec{x}, \dot{\vec{x}})
\end{displaymath}
Similar to the example of the spring-coupled particles in the
introduction, invariance under translations in space yields
conservation of linear momentum.

Quantification over orthogonal transformations $o : \mathsf{O}(3)$
yields the following free theorem, which states that the Lagrangian is
invariant under modification of the positions and velocities by
arbitrary orthogonal transformations $O$:
\begin{displaymath}
  \forall O \in \mathrm{O}(3).~\sem{L}(t, O\vec{x}, O\dot{\vec{x}}) = \sem{L}(t, \vec{x}, \dot{\vec{x}})
\end{displaymath}
We are particularly interested in the orthogonal transformations
derived from rotations, since these will give us the continuous
transformations we need to apply Noether's theorem. For example,
rotation by an angle $\epsilon$ around the $x_3$-axis is given by the
following $\epsilon$-indexed family of orthogonal matricies:
\begin{displaymath}
  O_\epsilon =
  \left(
    \begin{array}{ccc}
      \cos \epsilon  & \sin \epsilon & 0 \\
      -\sin \epsilon & \cos \epsilon & 0 \\
      0 & 0 & 1
    \end{array}
  \right)
\end{displaymath}
This leads to the following $\epsilon$-indexed family of
transformations, suitable for Noether's theorem:
\begin{displaymath}
  \Psi_\epsilon\left(\begin{array}{@{}c@{}} x_1 \\ x_2 \\ x_3 \end{array}\right) =
  O_\epsilon \left(\begin{array}{@{}c@{}} x_1 \\ x_2 \\ x_3 \end{array}\right) =
  \left(\begin{array}{@{}c@{}} x_1 \cos \epsilon + x_2 \sin \epsilon \\ - x_1 \sin \epsilon + x_2 \cos \epsilon \\ x_3 \end{array}\right)
\end{displaymath}
Plugging this into Equation~\ref{eq:conservation-law}, and using the
definition of $L$ above, we obtain the following conservation law:
\begin{displaymath}
  \frac{d}{dt}(m\dot{x}x_2 - m\dot{x}x_1) = 0
\end{displaymath}
This is exactly conservation of angular momentum around the $x_3$-axis
\cite{landau60mechanics}. By considering the families of orthogonal
matrices for rotation around other axes, we can also derive
conservation laws for angular momentum around arbitrary axes.

\paragraph{Particle in a Potential Field}

If we now extend the typing context of our example with an arbitrary
potential energy function $V$, depending on the position of the
particle, we can define the Lagrangian for a single particle acted
upon by a potential field that depends on the position of the
particle. The invariance properties of the whole system will depend
upon the invariance properties of the potential field. If we assume
the following contexts:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & t_t : \mathsf{T}(1), o : \mathsf{O}(3) \\
    \Gamma = &
    \begin{array}[t]{@{}l}
      m : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle}, \\
      V : \forall o \mathord: \mathsf{O}(3).~C^\infty(\mathbb{R}^3\langle \mathit{ortho}_3(o), 0 \rangle, \mathbb{R}\langle 1, 0 \rangle)
    \end{array}\\
    \Delta = & t : \mathbb{R}\langle 1, t_t \rangle, x : \mathbb{R}^3\langle \mathit{ortho}_3(o), 0 \rangle, \dot{x} : \mathbb{R}^3\langle \mathit{ortho}_3(o), 0 \rangle
  \end{array}
\end{displaymath}
where everything is as in the previous example, except for the
addition of the polymophic potential energy function $V$. We
incorporate this into our Lagrangian like so:
\begin{displaymath}
  L = \frac{1}{2}m(\dot{x} \cdot \dot{x}) - V(x) : \mathbb{R}\langle 1, 0 \rangle
\end{displaymath}
Even though $V$ is left abstract, the types of $t$, $x$, $\dot{x}$ and
$L$ tell us that this Lagrangian is invariant under translations in
time and also under all orthogonal transformations. Hence, by
Noether's theorem, the system this Lagrangian describes has energy and
angular momentum as conserved quantities.

\subsection{The $n$-Body Problem}

Using the constructs of our calculus for dealing with $n$-ary vectors
of positions and velocities, we can compactly write Lagrangians that
describe systems of $n$ particles interacting through Newtonian
gravitational attraction. We use the following kinding, typing and
cartesian space contexts, where the type-level parameter $n$
represents the number of particles that we are considering. For
simplicity, we assume that all the bodies involved in the system have
equal mass $m$.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & n : \mathsf{Nat}, t_t : \mathsf{T}(1), t_x : \mathsf{T}(3), o : \mathsf{O}(3) \\
    \Gamma = & m : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle} \\
    \Delta = &
    \begin{array}[t]{@{}l}
      t : \mathbb{R}\langle 1, t_t \rangle, \\
      x : \mathit{vec}~n~(\mathbb{R}^3\langle \mathit{ortho}_3(o), t_x \rangle), \\
      \dot{x} : \mathit{vec}~n~(\mathbb{R}^3\langle \mathit{ortho}_3(o), 0 \rangle)
    \end{array}
  \end{array}
\end{displaymath}
The Lagrangian for this system is defined as follows in our surface
syntax for smooth terms. The kinetic energy component is the sum of
the kinetic energies of all the particles in the system. The potential
energy components sums up all the gravitational potential energies due
to the interactions between each pair of bodies, where $G$ is the
gravitational constant.
\begin{displaymath}
  L =
  \begin{array}[t]{@{}l}
    \frac{1}{2}m(\mathrm{sum}~(\mathrm{map}~(\dot{x_i}.~\dot{x_i}\cdot\dot{x_i}))~\dot{x}) - \\
    \quad \mathrm{sum}~(\mathrm{map}~((x_i,x_j).~Gm^2/|x_i - x_j|)~(\mathrm{cross}~x~x)) : \mathbb{R}\langle 1, 0 \rangle
  \end{array}
\end{displaymath}
We have used the notation $|e|$ as shorthand for $\mathrm{sqrt}~(e
\cdot e)$, i.e., the norm of the vector $e$.

Again, just by looking at the types of $t$, $x$, $\dot{x}$, and $L$,
we can determine via free theorems that this Lagrangian is invariant
under translation in time and space, and under all orthogonal
transformations. Hence, by Noether's theorem, this system has energy
and linear and angular momentum as conserved quantities.

\subsection{Pendulum}

All our examples above have used rectangular coordinate systems. Part
of the power of the Lagrangian formulation of classical mechanics is
the ability to use appropriate generalised coordinates to describe
systems in simple terms. A standard example is that of a pendulum,
where we take the angle $\theta$ of swing from the vertical as the
coordinate.

We use the following kinding, typing and cartesian space contexts:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & t_t : \mathsf{T}(1), z : \mathsf{Z} \\
    \Gamma = & m : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle}, l : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle} \\
    \Delta = &
    \begin{array}[t]{@{}l}
      t : \mathbb{R}\langle 1, t_t \rangle, \theta : \mathbb{R}\langle 1, \underline{2\pi}*z \rangle, \dot{\theta} : \mathbb{R}\langle 1, 0 \rangle
\end{array}
  \end{array}
\end{displaymath}
where $m$ is the mass at the end of the pendulum (we assume the rod of
the pendulum to be massless), $l$ is the length of the pendulum,
$\theta$ is the angle of swing and $\dot{\theta}$ is the current rate
of change of the angle of swing.

Defining the Lagrangian for this system is a matter of simple
trigonometry and differential calculus:
\begin{displaymath}
  L =
  \begin{array}[t]{@{}l}
    \textrm{let }y = l\sin \theta \textrm{ in} \\
    \textrm{let }\dot{x} = l\dot{\theta}\cos \theta \textrm{ in} \\
    \textrm{let }\dot{y} = - l\dot{\theta}\sin \theta \textrm{ in} \\
    \quad \frac{1}{2}m(\dot{x}^2 + \dot{y}^2) - mgy : \mathbb{R}\langle 1, 0 \rangle
  \end{array}
\end{displaymath}
From the type of $t$, we can easily determine that this Lagrangian is
invariant under translation in time, and hence the total energy is a
conserved quantity of this system. We can also derive another free
theorem due to the quantification over the group of integers via the
variable $z$. However, this does not yield a continuous invariance of
the Lagrangian, and hence no conserved quantity via Noether's theorem.

\subsection{Oscillators}

\paragraph{Coupled Particles} Our first example of a Lagrangian in the
introduction was of a pair of particles of equal mass coupled by a
spring, for which we derived conservation of linear momentum and
energy. In terms of our type system, we have the following kinding,
typing and cartesian space contexts, where $m$ is the individual mass
of the two particles, and $k$ is the spring constant:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & t_t : \mathsf{T}(1), t_x : \mathsf{T}(1) \\
    \Gamma = & m : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle}, k : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle} \\
    \Delta = &
    \begin{array}[t]{@{}l}
      t : \mathbb{R}\langle 1, t_t \rangle, x_1 : \mathbb{R}\langle 1, t_x \rangle, x_2 : \mathbb{R}\langle 1, t_x \rangle, \\
      \dot{x_1} : \mathbb{R}\langle 1, 0 \rangle, \dot{x_2} : \mathbb{R}\langle 1, 0 \rangle
\end{array}
  \end{array}
\end{displaymath}
In our surface syntax for smooth terms, the Lagrangian is written just
as it was in the introduction:
\begin{displaymath}
  L = \frac{1}{2}m(\dot{x_1}^2 + \dot{x_2}^2) - \frac{1}{2}k^2(x_1 - x_2)^2 : \mathbb{R}\langle 1, 0 \rangle
\end{displaymath}
The free theorems for this term state the invariance in time and space
translation:
\begin{displaymath}
  \begin{array}{@{}l}
    \forall t_t : \mathbb{R}.~\sem{L}(t + t_t, x_1, x_2, \dot{x_1}, \dot{x_2}) = \sem{L}(t, x_1, x_2, \dot{x_1}, \dot{x_2}) \\
    \forall t_x : \mathbb{R}.~\sem{L}(t, x_1 + t_x, x_2 + t_x, \dot{x_1}, \dot{x_2}) = \sem{L}(t, x_1, x_2, \dot{x_1}, \dot{x_2})
  \end{array}
\end{displaymath}
As we saw in Section~\ref{sec:conservation-laws-from-symmetry}, these
invariance properties allow us to deduce conservation of energy and
linear momentum for this system.

% \paragraph{Fixed Endpoint Oscillator} We now look at the slightly
% simpler case of a single particle connected to a spring attached to a
% fixed point.

\paragraph{Damped Oscillator} All of the example Lagrangians we have
looked at so far have had no dependence on time, and so they have all
described systems with total energy as a conserved quantity. A system
with a single particle attached to a damped spring (whose other
endpoint is fixed at position $0$) provides an example of system that
does not have energy as a conserved quantity. This example is taken
from Neuenschwander's book \cite{neuenschwander11}.  We use the
following kinding, typing and cartesian space contexts:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}l}
    \Theta = & t_t : \mathsf{T}(1) \\
    \Gamma = & k : \typeOfCartSp{\mathbb{R}\langle 1, 0 \rangle} \\
    \Delta = &
    \begin{array}[t]{@{}l}
      t : \mathbb{R}\langle 1, t_t + t_t \rangle, x : \mathbb{R}\langle \mathit{exp}(-t_t), 0 \rangle, \dot{x} : \mathbb{R}\langle \mathit{exp}(-t_t), 0 \rangle
    \end{array}
  \end{array}
\end{displaymath}
Here, the position and velocity of the single particle \emph{scale}
with the exponential of the translation in time. This will account for
the exponential damping we apply to the system. For simplicity, we
assume that the mass of the particle and the spring constant are both
$1$. The Lagrangian for this system looks similar to the coupled pair
above, except for an additional damping factor:
\begin{displaymath}
  L = \left(\frac{1}{2}\dot{x}^2 - \frac{1}{2}x^2\right)\mathrm{exp}(t) : \mathbb{R}\langle 1, 0 \rangle
\end{displaymath}
From the types of $t$, $x$ and $\dot{x}$, we learn that this system is
invariant under the families of transformations $\Phi_\epsilon(t) = t
+ 2\epsilon$ and $\Psi_\epsilon(x) = e^\epsilon x$. This leads to the
following conservation law for this system, linking energy and linear
momentum:
\begin{displaymath}
  \frac{d}{dt}\left[\left(\frac{1}{2}x\dot{x} + \frac{1}{2}\dot{x}^2 + \frac{1}{2}x^2\right)e^t\right] = 0
\end{displaymath}

\section{Conclusions}
\label{sec:conclusions}

We have presented a type system for writing invariant Langrangians,
with a relationally parametric semantics that allows the derivation of
free theorems that can be used with Noether's theorem to discover
conservation laws for classical mechanical systems. Our key technical
contribution has been the observation that relationally parametric
models of System F$\omega$ admit kinds that are interpreted as
groupoids, allowing geometric invariance properties to be integrated
directly into the model.

\paragraph{Related Work} We are not aware of any other work linking
type systems or relational parametricity with invariance properties
for classical mechanics, or with Noether's theorem. We have already
mentioned the work of Atkey, Johann and Kennedy
\cite{atkey13abstraction} that uses relational parametricity with a
specialised type system to derive geometric invariance properties,
albeit in a setting without smooth functions, and without an
application to Noether's theorem. In this paper, we have placed Atkey
\emph{et al.}'s work in a more general setting by framing it as an
extension of System F$\omega$, which allows us to (a) incorporate
type-level computation, as we used to define the $n$-ary vectors of
coordinates; and (b) to reuse previous work on relationally parametric
models of System F$\omega$ by Atkey \cite{atkey12relational}.

Sussman and Wisdom \cite{sussman01structure} reformulate Lagrangian
and Hamiltonian mechanics in a more programming language style so that
it can be implemented within the programming language Scheme. In doing
so, they clear up some of the ambiguous syntax common in the standard
presentations of classical mechanics. However, they do not attempt to
incorporate invariance properties into types, as we have done here.

There has been prior work on programming languages inspired by
theoretical physics. Quantum programming languages, which hope to
exploit the properties of quantum computation in an understandable
way, have been the subject of study for several years now. We cite
Abramsky \cite{abramsky04} as an introduction to this field.

\paragraph{Future Work} We have barely scratched the surface of the
applicability of Noether's theorem to theoretical
physics. Conservation laws for classical and quantum field theories
are derivable from the much more general theorem that Noether
originally proved \cite{noether71}. Neuenschwander's book
\cite{neuenschwander11} describes in an easy to read way how Noether's
theorem applies to field theories, allowing for relativistic and
quantum systems to be studied, and how it naturally leads to the
notion of Gauge invariance, an important principle in modern theories
of particle physics.

From the type system point of view, it seems clear that greater
precision in the types will be required in order to accomodate more
detailed physical theories. Study of relational parametricity for
dependent types, as done for example by Bernardy \emph{et al.}
\cite{bernardy12proofs} and Atkey \emph{et al.}
\cite{atkey14relational} may be useful here. Also, recent work on
homotopy type theory and, in particular $\infty$-groupoid models of
type theory is almost certainly relevant \cite{hottbook2013}.

For each of the examples in Section~\ref{sec:examples}, we computed
the necessary typing derivations by hand. Type inference for the
system was have presented here, or some variant of it, is a key item
of future work. Ideally, the user would enter the description of a
Lagrangian, and the system would be able to tell them the free
theorems, and consequent conservation laws that hold. Kennedy
\cite{kennedy94} and Gundry \cite{gundry11} have studied type
inference for the related, but simpler, setting of dimension types.

\begin{thebibliography}{12}
\softraggedright

\bibitem{abramsky04}
S.~Abramsky. High-Level Methods for Quantum Computation and Information.
Proceedings, LICS, 2004.

\bibitem{arnold89mathematical} V.~I.~Arnol'd. {\em Mathematical Methods of
  Classical Mechanics}. Springer, 1989.

\bibitem{atkey12relational}
R.~Atkey. Relational Parametricity for Higher Kinds.
Proceedings, CSL, 2012.

\bibitem{atkey14relational} R.~Atkey, N.~Ghani, and P.~Johann. A
  Relationally Parametric Model of Dependent Type Theory. Proceedings,
  POPL, 2014.

\bibitem{atkey13abstraction}
R.~Atkey, P.~Johann, and A.~J.~Kennedy. Abstraction and Invariance for Algebraically Indexed Types.
Proceedings, POPL, 2013.

\bibitem{bernardy12proofs} 
J.-P.~Bernardy, P.~Jansson, R.~Paterson.
Proofs for Free: Parametricity for Dependent Types.
{\em Journal of Functional Programming} 22(2), pp. 107-152, 2012.

\bibitem{gelfand00calculus} I.~M.~Gelfand and S.~V.~Fomin,
  R.~A.~Silverman (ed.). {\em Calculus of Variations}. Dover Publications,
  2000.

\bibitem{gundry11} A.~Gundry. Type Inference for Units of
  Measure. Technical Report, University of Strathclyde, 2011.

\bibitem{hasegawa94relational} R. Hasegawa.  Relational Limits in
  General Polymorphism.  {\em Publications of the Research Institute
    for Mathematical Sciences} 30, pp. 535--576, 1994.

\bibitem{kennedy94}
A.~J.~Kennedy. Dimension Types.
Proceedings, ESOP, 1994.

\bibitem{kennedy97relational} 
A.~J.~Kennedy. Relational Parametricity and Units of Measure.
Proceedings, POPL, pp. 442-455, 1997.

\bibitem{landau60mechanics} L.~D.~Landau and
  E.~M.~Lifschitz. {\em Mechanics}. Pergamon Press. 1967.

\bibitem{neuenschwander11}
D.~E.~Neuenschwander. {\em Emmy Noether's Wonderful Theorem}.
The John Hopkins University Press, 2011.

\bibitem{noether71} E.~Noether, M.~Tavel (translator). Invariant
  Variation Problems.  {\em Transport Theory and Statistical Physics}
  1(3), pp. 186-207, 1971. Original in {\em Gott. Nachr.},
  1918:235-257, 1918.

\bibitem{maclane98categories} S.~Mac~Lane. {\em Categories for the Working
  Mathematician}, 2nd edition. Springer, 1998.

\bibitem{pierce02types} B.~Pierce. {\em Types and Programming
  Languages}. MIT Press, 2002.

\bibitem{pitts87polymorphism} A.~M.~Pitts.  Polymorphism is Set
  Theoretic, Constructively.  {\em Proc., Category Theory and Computer
    Science}, pp. 12--39, 1987.

\bibitem{reynolds83types}
J.~C.~Reynolds. Types, Abstraction and Parametric Polymorphism.
{\em Information Processing} 83, pp. 513-523, 1983.

\bibitem{robinson94reflexive} E. Robinson and G. Rosolini.  Reflexive
Graphs and Parametric Polymorphism.  {\em Proc., Logic in Computer
  Science}, pp. 364--371, 1994.

\bibitem{sussman01structure} G.~J.~Sussman and J.~Wisdom. Structure and
  Interpretation of Classical Mechanics. MIT Press, 2001

\bibitem{hottbook2013} The Univalent Foundations Program. {\em
    Homotopy Type Theory}. Institute for Advanced Study, 2013.

\bibitem{wadler89theorems}
P.~Wadler.  Theorems for Free!.  Proceedings, FPCA,
pp. 347-359, 1989.

\end{thebibliography}


\end{document}
