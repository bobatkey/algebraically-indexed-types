\documentclass[preprint]{sigplanconf}

\newcommand{\sepbar}{\mathrel|}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}

\title{From Parametricity to Conservation Laws, via Noether's Theorem}

\authorinfo{}{}{}
% \authorinfo{Robert Atkey}
%            {}
%            {bob.atkey@gmail.com}

\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{property}{Property}
\newtheorem{proposition}{Proposition}
\newcommand{\lemref}[1]{\hyperref[#1]{Lemma~\ref*{#1}}}
\newcommand{\thmref}[1]{\hyperref[#1]{Theorem~\ref*{#1}}}
\newcommand{\defref}[1]{\hyperref[#1]{Definition~\ref*{#1}}}
\newcommand{\propref}[1]{\hyperref[#1]{Proposition~\ref*{#1}}}
\newcommand{\corref}[1]{\hyperref[#1]{Corollary~\ref*{#1}}}
\newcommand{\conref}[1]{\hyperref[#1]{Conjecture~\ref*{#1}}}
\newcommand{\exref}[1]{\hyperref[#1]{Example~\ref*{#1}}}
\newcommand{\statementref}[1]{\hyperref[#1]{Statement~\ref*{#1}}}

\newcommand{\comp}{\mathrel{>\kern-0.45em>\kern-0.45em>}}

\newcommand{\smoothrightarrow}{\stackrel{C^\infty}\longrightarrow}
\newcommand{\typeOfCartSp}[1]{\lbag #1 \rbag}
\newcommand{\elab}[1]{\lfloor #1 \rfloor}

\newtheoremstyle{examplestyle}
  {\topsep}  % space above
  {\topsep}  % space below
  {\normalfont}% name of font to use in the body of the theorem
  {0em}% measure of space to indent
  {\bfseries}% name of head font
  {.}% punctuation between head and body
  {5pt plus 1pt minus 1pt}% space after theorem head; " " = normal interword space
  {}% Manually specify head
\theoremstyle{examplestyle}
\newtheorem{example}{Example}
\newtheorem*{example*}{Example}

\newcommand{\fomega}{F$\omega$}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\Set}{\mathsf{Set}}
\newcommand{\Rel}{\mathsf{Rel}}
\newcommand{\Pow}{\mathcal{P}}
\newcommand{\frel}[1]{\langle #1 \rangle}
\newcommand{\coq}[1]{\textsf{#1}}
\newcommand{\CIC}{\textsc{CIC}}

\newcommand{\semKU}[1]{\llbracket #1 \rrbracket^O}
\newcommand{\semKR}[1]{\llbracket #1 \rrbracket^R}
\newcommand{\semKI}[1]{\llbracket #1 \rrbracket^{\mathrm{id}}}

\begin{document}

\maketitle

\begin{abstract}
  Invariance is of paramount importance in programming languages and
  in physics. In programming languages, John Reynolds' theory of
  relational parametricity demonstrates that parametric polymorphic
  programs are invariant under change of data representation, a
  property that yields ``free'' theorems about programs just from
  their types. In physics, Emmy Noether showed that if the action of a
  physical system is invariant under change of coordinates, then the
  physical system has a conserved quantity: a quantity that remains
  constant for all time. Knowledge of conserved quantities can reveal
  deep properties of physical systems. For example, the conservation
  of energy, which by Noether's theorem is a consequence of a system's
  invariance under time-shifting.

  In this paper, we link Reynolds' relational parametricity with
  Noether's theorem for deriving conserved quantities. We propose an
  extension of System F$\omega$ with new kinds, types and term
  constants for writing programs that describe classical mechanical
  systems in terms of their Lagrangians. We show, by constructing a
  relationally parametric model of our extension of F$\omega$, that
  relational parametricity is enough to satisfy the hypotheses of
  Noether's theorem, and so to derive conserved quantities for free,
  directly from the polymorphic types of Lagrangians expressed in our
  system.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

Reynolds' theory of relational parametricity \cite{reynolds82} tells
us that parametrically polymorphic programs automatically satisfy
invariance properties. Such invariance properties are often called
\emph{Free Theorems}, after Wadler \cite{wadler89theorems}, since they
follow ``for free'' from the types of programs, rather than through
detailed study of the program text itself. An illustrative example is
the free theorem for programs $f$ with the following type:
\begin{displaymath}
  f : \forall \alpha.~\mathsf{List}~\alpha \to \mathsf{Nat}
\end{displaymath}
Such programs takes lists of $\alpha$s, for any type $\alpha$, to
natural numbers. Using Reynolds' theory of relational parametricity,
Wadler showed that \emph{any} $f$ with this type satisfies the
following property:
\begin{displaymath}
  \forall \alpha, \beta, g : \alpha \to \beta, l : \mathsf{List}~\alpha.~f~[\alpha]~l = f~[\beta]~(\mathrm{map}~g~l)
\end{displaymath}
Thus, any $f$ with the type given above is invariant under mapping
some arbitrary function $g$ over its input. Thinking in terms of
abstract data types and change of data representation, this free
theorem states that $f$ is invariant under change of data
representation from an arbitrary type $\alpha$ to another arbitrary
type $\beta$, via $g$.

The use of invariance under change to derive useful consequences is a
technique much older than programming languages. In physics,
\emph{Noether's theorem} \cite{noether} provides a general way to
derive conservation laws for physical systems from invariance
properties. Informally speaking, Noether's theorem states that every
continuous symmetry of a physical system implies the existence of a
corresponding conserved quantity. A conserved quantity is a function
of the state of the system that is constant for all time. We
illustrate the use of Noether's theorem with a simple example of a
classical system consisting of two particles of equal mass $m$
connected by a spring with spring constant $k$, such that the
particles are constrained to move one-dimensionally.

% Picture here?

Noether's theorem applies to systems described in terms of
\emph{Lagrangians}. For classical mechanics, a Lagrangian is a
function of time, and the positions and velocities of all the
particles in the system, to the difference between the kinetic energy
and the potential energy of the system. For our system with two
particles at positions $x_1$ and $x_2$ with velocities $\dot{x_1}$ and
$\dot{x_2}$ the Lagrangian is:
\begin{equation}\label{eq:coupled-spring-lagrangian}
  L(t,x_1,x_2,\dot{x_1},\dot{x_2}) = \frac{1}{2}m(\dot{x_1}^2 + \dot{x_2}^2) - \frac{1}{2}k(x_1 - x_2)^2
\end{equation}
The first summand represents the total kinetic energy of the system in
terms of the mass and velocities, while the second summand represents
the potential energy contained within the spring due to the distance
between the particles.

From the Lagrangian (\ref{eq:coupled-spring-lagrangian}), using the
\emph{principle of stationary action}, we can derive the following two
equations of motion for this system. (We describe the principle of
stationary action, and the process for deriving the equations of
motion fully in Section~\ref{sec:conservation-laws-from-symmetry}.)
For this system, the equations of motion are a pair of ordinary
differential equations (ODEs) that describe how the positions and
velocities of the particles evolve over time (the second deivative
with respect to time, $\ddot{x_i}$, denotes the acceleration of the
$i$th particle):
\begin{mathpar}
  m\ddot{x_1} = - k(x_1 - x_2)

  m\ddot{x_2} = - k(x_2 - x_1)
\end{mathpar}
We could now proceed to solve these ODEs to further analyse the
behaviour of this system. However, Noether's theorem gives us a
powerful way of gaining insight into properties of these ODEs ``for
free'', without necessarily having to find solutions to them. This is
accomplished by finding invariance properties of the Lagrangian.

The Lagrangian (\ref{eq:coupled-spring-lagrangian}) does not refer to
any fixed point in space; only the relative distance between the two
particles, along with their velocities, is relevant. Therefore, the
Lagrangian (\ref{eq:coupled-spring-lagrangian}) is invariant under
translation in space by some arbitrary displacement $y$:
\begin{equation}\label{eq:coupled-spring-translation-invariance}
  L(t,x_1,x_2,\dot{x_1},\dot{x_2}) = L(t,x_1+y,x_2+y,\dot{x_1},\dot{x_2})
\end{equation}
By Noether's theorem, invariance under spatial translation implies
that the linear momentum of the whole system is constant for all
time. For this system, conservation of linear momentum is stated
mathematically as the vanishing of the derivative with respect to time
of the total linear momentum of the system:
\begin{equation}\label{eq:coupled-spring-linear-momentum}
  \frac{d}{\mathit{dt}}~m(\dot{x}_1 + \dot{x_2}) = 0
\end{equation}
In general, Noether's theorem gives us a way of deriving conserved
properties like (\ref{eq:coupled-spring-linear-momentum}) from
invariance properties like
(\ref{eq:coupled-spring-translation-invariance}). In this case, we
have used invariance under translation in space to derive conservation
of linear momentum. Other common examples include invariance under
translation in time, yielding conservation of energy, and invariance
under rotation, yielding conservation of angular momentum. We will see
examples of each of these kinds of invariance, and their consequent
conservation laws, in Section~\ref{sec:examples}.

The invariance property stated in
Equation~(\ref{eq:coupled-spring-translation-invariance}) is highly
reminiscent of the free theorem we stated for the polymorphic program
at the start of this introduction. A change in representation in the
input, whether a change in data representation from a type $\alpha$ to
a type $\beta$, or a change in where time zero is counted from,
results in no change in the output. Since Reynolds' relational
parametricity was allowed us to derive the invariance properties for
the program $f$ just by looking at its type, we ask the following
question:

\medskip

\noindent
\textbf{Question:} \emph{Is it possible to use Reynolds' theory of
  relational parametricity to derive the invariance properties of
  Lagrangians required for Noether's theorem to derive conservation
  laws?}

\medskip

In this paper, we answer this question positively. We show that it is
indeed the case that we can use a generalised version of Reynolds'
theory of relational parametricity to prove the geometric invariance
properties required for the hypotheses of Noether's theorem. We
construct an extension of System F$\omega$ suitable for writing
invariant Lagrangians, with a relationally parametric model that
allows us to prove invariance properties as free theorems. In our
system, the Lagrangian (\ref{eq:coupled-spring-lagrangian}) we gave
above for describing a system of two particles coupled by a spring
will have the type:
\begin{displaymath}
  \begin{array}{@{}l}
  \forall y \mathord: \mathsf{T}(1).\\
  \quad C^\infty(\mathbb{R}\langle 1, 0 \rangle \times \mathbb{R}\langle 1, y \rangle \times \mathbb{R}\langle 1, y \rangle \times \mathbb{R}\langle 1, 0 \rangle \times \mathbb{R}\langle 1, 0 \rangle, \mathbb{R}\langle 1, 0 \rangle)
\end{array}
\end{displaymath}
We explain this type by breaking it down from left to right. The
quantifier $\forall x \mathord: \mathsf{T}(1)$ indicates that we are
quantifying over all translations $y$ in one-dimensional space, just
as we did implicity in Equation
(\ref{eq:coupled-spring-translation-invariance}). The notation
$C^\infty(-,-)$ denotes the type of \emph{smooth} functions between
spaces. (A smooth function is a function that is infinitely
differentiable.) All the functions that we wish to use as Lagrangians
must be smooth (at least up to second order) for the theory to
work. The type $\mathbb{R}\langle g, x \rangle$ denotes real numbers
that vary with some linear transformation $g$ and translation $x$. In
this case, all the linear transformations are $1$, indicating no
transformation. Likewise, when the translation component is $0$, there
is no translation. Thus a value of type $\mathbb{R}\langle 1, 0
\rangle$ is invariant, but a value of type $\mathbb{R}\langle 1, y
\rangle$ varies with the translation $y$. In the smooth function type
above, in domain space consists of vectors of five real numbers: the
time, the two particle positions, which vary with the translation $y$,
and the two particle velocities.

Atkey, Johann and Kennedy \cite{atkey13abstraction}, building on older
work by Kennedy \cite{kennedy94para}, have already presented a
polymorphic type system for expressing geometric invariance properties
similar to the translation invariance property in Equation
(\ref{eq:coupled-spring-translation-invariance}). In the present work,
we extend their type system by embedding it within System
F$\omega$. The benefits of this embedding are twofold. Firstly, by
using the richer type-level structure of System F$\omega$, we can
easily add useful indexed types like length indexed vectors and smooth
function types, both of which would have required special treatment in
the special purpose type system presented by Atkey \emph{et
  al.}. Secondly, by using System F$\omega$ as our base, we are able
to reuse the reflexive graph-based relationally parametric semantics
presented by Atkey \cite{atkey12relational}, extending it as
appropriate for our geometric setting.

\paragraph{Contributions}

Our core contributions are threefold:
\begin{enumerate}
\item We reformulate the type system for geometric invariance of
  Atkey, Johann and Kennedy \cite{atkey13abstraction} as an extension
  of System F$\omega$. This shows that the special status of the
  group-indexed types in Atkey \emph{et al.}'s work can be
  incorporated into a standard framework for presenting indexed types.
\item We present a relationally parametric semantics of our extension
  of System F$\omega$. In this model, following Atkey's model for
  basic System F$\omega$ \cite{atkey12relational}, each kind is
  interpreted as a reflexive graph. Our key technical contribution is
  to note that the many geometric groups that we wish to incorporate
  are expressible as groupoids, and hence as reflexive graphs. We
  therefore show that Reynolds' theory of relational parametricity,
  suitably generalised to indexed types by considering reflexive
  graphs, already accomodates geometric invariance properties.
\item Finally, we connect the free theorems derivable from our
  relationally parametric semantics with Noether's theorem for
  deriving conservation laws. We present many examples of invariant
  Lagrangians expressible in our type system, along with the
  consequent conservation laws for physical systems. In each case, the
  necessary invariance property is derived from the type we assign to
  the Lagrangian.
\end{enumerate}

\paragraph{Outline}

\begin{itemize}
\item In the next section,
  Section~\ref{sec:conservation-laws-from-symmetry}, we describe the
  necessary background to understand Noether's theorem and the
  conservation laws it generates. We briefly introduce the Lagrangian
  formulation of classical mechanics, define precisely what it means
  for a physical system to be invariant under transformations, and
  state Noether's theorem.
\item Having shown how invariance generates conservation laws in
  Section~\ref{sec:conservation-laws-from-symmetry}, in
  Section~\ref{sec:symmetry-from-types}, we show how to derive
  invariance properties from indexed types. We present a relationally
  parametric semantics for System F$\omega$, and show how geometric
  invariance properties can be accomodated within this semantics.
\item In Section~\ref{sec:types-for-classical-mech}, we construct a
  type system for classical mechanics, by extending System F$\omega$
  with the necessary constants for smooth function types and
  combinators for constructing smooth functions. Programming directly
  with our combinators in raw System F$\omega$ is awkward, due to the
  point-free style required, so in Section~\ref{sec:surface-syntax} we
  define a surface syntax for defining smooth functions that is
  translated into our applied System F$\omega$.
\item In Section~\ref{sec:examples} we present several examples of
  using our extension of System F$\omega$ for writing invariant
  Lagrangians that describe physical systems.
\item Section~\ref{sec:conclusions} concludes, and offers directions
  for further work.
\end{itemize}

\section{Conservation Laws from Invariance}
\label{sec:conservation-laws-from-symmetry}

Noether's theorem applies to systems described using the formalism of
Lagrangian mechanics, a reformulation of Newtonian classical
mechanics. In this section we can only offer a very brief introduction
to the concepts of Lagrangian mechanics. The reader is referred to
other sources, such as Landau and Lifschitz \cite{landau60mechanics}
or Arnol'd \cite{arnoldXXmathematical} for the necessary background in
the mathematical theory of classical mechanics. Lagrangian mechanics,
and Noether's theorem, make crucial use of the Calculus of
Variations. Gelfand and Fomin \cite{gelfandXXcalculus} provide a good
introduction to this topic.

In this section, we will endeavour to keep the presentation relatively
elementary. However, some knowledge of differential and integral
calculus will be required. Knowledge of basic Newtonian mechanics will
also be helpful. We will use standard notation from physics and
mathematics for integrals and (partial) derivatives. In particular,
when discussing derivatives with respect to time, we use dot notation:
$\dot{x}$ for the first derivative of $x$ with respect to time, and
$\ddot{x}$ for the second derivative.

\subsection{Lagrangian Mechanics}

Lagrangian mechanics is a branch of analytical mechanics, along with
Hamiltonian mechanics
\cite{landau60mechanics,arnoldXXmathematical}. Analytical mechanics
seeks to discover the underlying structure of Newtonian classical
mechanics by reformulating it in different terms.

\paragraph{Lagrangian and Action}

For Lagrangian mechanics, classical mechanical systems are described
in terms of \emph{Lagrangians} $L = T - V$, where $T$ is the total
kinetic energy of the system, and $V$ is the total potential
energy. The Lagrangian is a function of time, the positions of all the
particles in the system, and their velocities. This is usually written
like so, with abuse of notation for $\dot{q}$ which is a variable
here, not a derivative of a function:
\begin{displaymath}
  L(t, q, \dot{q}) = T - V
\end{displaymath}
In this expression, $q$ and $\dot{q}$ are actually vectors containing
the components of the position and velocity vectors for each
particle. A key feature of Lagrangian mechanics is that the coordinate
system used to describe the system need not necessarily be the usual
cartesian coordinates. For example, one of the components of $q$ might
be the angle of swing of a pendulum. This use of generalised
coordinates is one of the advantages of Lagrangian mechanics over the
Newtonian presentation in terms of positions and forces.

The Lagrangian for a particular system is used to define the
\emph{action} of that system. For a particular path $q : \mathbb{R}
\to \mathbb{R}^n$ and endpoints $a < b$ in time, the action of the
Lagrangian $L$ over this path is defined by the following integral:
\begin{displaymath}
  \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
\end{displaymath}
Below, we will use the principle of stationary action to select the
physically realisable paths from all the possible paths $q :
\mathbb{R} \to \mathbb{R}^n$.

\begin{example}
  We have already seen an example of a Lagrangian, in the
  introduction, describing a system of two particles coupled by a
  spring. Another example of a Lagrangian describes a system
  consisting of a single particle of mass $m$ acted upon by a constant
  downward gravitational field with gravitational potential $g$:
  \begin{equation}\label{eq:simple-g-lagrangian}
    L(t,x,y,\dot{x},\dot{y}) = \frac{1}{2}m(\dot{x}^2 + \dot{y}^2) - mgy
  \end{equation}
  Again, the left summand represents the kinetic energy of the system
  in terms of the mass and horizontal and vertical velocities of the
  particle. The right summand represents the potential energy of the
  system due to the gravitational field's strength determined by the
  particle's distance from a fixed baseline at $y = 0$.
\end{example}

\paragraph{The Principle of Stationary Action}

The \emph{principle of stationary action} states that the physically
realisable paths $q$ are the paths that yield stationary points (i.e.,
either minima or maxima) of the action $\mathcal{S}[q;a;b]$, for all
$a$ and $b$. Defining what is exactly meant by a stationary point of
the action is beyond the scope of this paper, and can be found in
standard references on the calculus of variations, such as Gelfand and
Fomin \cite{gelfandXXcalculus}. The key point for our purposes is that
a path $q$ satisfies the principle of stationary action if and only if
it satisfies a system of ODEs derived from the Lagrangian $L$, called
the Euler-Lagrange equations:
\begin{equation}\label{eq:euler-lagrange}
  \frac{d}{dt}\frac{\partial L}{\partial \dot{q_i}} - \frac{\partial L}{\partial q_i} = 0
\end{equation}
The ODEs derived from the Lagrangian for a classical mechanical system
are called the \emph{equations of motion} for the system.

The notation in the Euler-Lagrange equation, while standard, is not
exactly clear, especially to a programming language theorist used to a
more careful treatment of variables. The two partial derivatives
$\frac{\partial L}{\partial \dot{q_i}}$ and $\frac{\partial
  L}{\partial q_i}$ take partial derivatives of $L$ with respect to
$\dot{q_i}$ and $q_i$ \emph{as variables}. The derivative with respect
to time, $\frac{d}{dt}$ then treats $\dot{q_i}$ as a function of time,
hence the appearance of the second derivatives $\ddot{q_i}$ in the
equations of motion. Sussman and Wisdom \cite{sussman} criticise the
standard presentation of Lagrangian mechanics for this kind of
confusing notation, and define a clearer notation based on the Scheme
programming language. We elect to stick with the standard notation as
used in physics textbooks just for familiarity.

\begin{example}
  Computing the Euler-Lagrange equations for the Lagrangian
  (\ref{eq:simple-g-lagrangian}), above, yields a pair of ODEs, one
  each for the $x$ and $y$ coordinates of the single particle of the
  system:
  \begin{mathpar}
    m\ddot{x} = 0

    m\ddot{y} = -mg
  \end{mathpar}
  Note that both these ODEs have the form $F = m\ddot{x}$, just as in
  Newton's second law. Lagrangian mechanics allows, from the principle
  of stationary action, the derivation of Newton's second law, instead
  of postulating it as an axiom.
\end{example}

\subsection{Noether's Theorem} 

As we described in the introduction, Noether's theorem provides us
with deep insights into the properties of the solutions of the
Euler-Lagrange equations. Formally, Noether's theorem requires the
invariance of the action $\mathcal{S}$, rather than invariance of the
Lagrangian itself. We therefore first define what is meant by
invariance of the action, and then state Noether's theorem.

\paragraph{Invariance of the Action} Let
\begin{displaymath}
  \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
\end{displaymath}
be the action of some physical system described by the Lagrangian
$L$. Assume a differentiable invertible function $\Phi : \mathbb{R}
\to \mathbb{R}$ that transforms time in some way and a function
$\Psi : \mathbb{R}^n \to \mathbb{R}^n$ that transforms the vector of
generalised coordinates $\vec{q}$ to another vector of generalised
coordinates $\Psi(\vec{q})$.

The action $\mathcal{S}$ is \emph{invariant} between the endpoints $a$
and $b$, under the transformations $\Phi$ and $\Psi$, if it is the
case that for all paths $q$:
\begin{equation}\label{eq:invariance}
    \int_a^b L(t,q(t),\dot{q}(t)) \mathit{dt}
    = \int_{\Phi(a)}^{\Phi(b)} L(s, q^*(s), \dot{q^*}(s)) \mathit{ds}
\end{equation}
where $q^*(s) = (\Psi \circ q \circ \Phi^{-1})(s)$ is the path $q$
transformed by $\Phi$ and $\Psi$.  By change of variables, the right
hand integral in the above equation is equal to the following
integral:
\begin{displaymath}
  \int_a^b L(\Phi(t), q^*(\Phi(t)), \dot{q^*}(\Phi(t)))\cdot \dot{\Phi}(t) \mathit{dt}
\end{displaymath}
For our application to classical mechanics, the endpoints $a$ and $b$
are arbitrary, so we can rewrite Equation (\ref{eq:invariance}) to the
following equation between applications of the Lagrangian:
\begin{equation}\label{eq:simplified-invariance}
  L(t,q(t),\dot{q}(t)) = L(\Phi(t), q^*(\Phi(t)), \dot{q^*}(\Phi(t)))\cdot \dot{\Phi}(t)
\end{equation}
For most examples, it will be the case that $\Phi$ has the form
$\Phi(t) = t + t'$ and $\Psi$ is an affine transformation $\Psi(q)
= Gq + x$, where $G$ is an $n\mathord\times n$ real matrix and $x \in
\mathbb{R}^n$. In this case, Equation (\ref{eq:simplified-invariance})
simplifies further, using the definition of $q^*$ and the chain rule
of differentiation, to:
\begin{equation}
  \label{eq:simple-invariance}
  L(t,q(t),\dot{q}(t)) = L(t + t', Gq(t) + x, G\dot{q}(t))
\end{equation}
Equation (\ref{eq:simple-invariance}) is obviously implied by the
following equation, where we treat $q$ and $\dot{q}$ as universally
quantified variables, instead of as functions of time:
\begin{equation}
  \label{eq:simplest-invariance}
  L(t,q,\dot{q}) = L(t + t', Gq + x, G\dot{q})
\end{equation}
Equation (\ref{eq:simplest-invariance}) is the form of invariance that
the free theorems we derive from the types of our typed language for
classical mechanics will usually take. We define our type system for
classical mechanics in Sections~\ref{sec:symmetry-from-types}
and~\ref{sec:types-for-classical-mech} below.

\begin{example}\label{ex:invariance-examples}
  In the introduction, we stated that the Lagrangian
  (\ref{eq:coupled-spring-lagrangian}) describing the spring-coupled
  system is invariant under translation in space. Our running example
  in this section, the Lagrangian (\ref{eq:simple-g-lagrangian}) for
  the single particle under gravity, is not invariant under all
  spatial translations, due to the reference in the potential energy
  term to the distance from the fixed baseline at $y = 0$. It is
  invariant under translations along the $x$-axis, however. Both
  Lagrangians are also invariant in translations in time, a special
  case of Equation~(\ref{eq:simplest-invariance}):
  \begin{displaymath}
    L(t,q,\dot{q}) = L(t+t',q,\dot{q})
  \end{displaymath}
  This invariance property is simply a consequence of the fact that
  neither Lagrangian explicitly mentions the time $t$.
\end{example}

\paragraph{Noether's Theorem} Noether's theorem applies to actions
that are \emph{continuously} invariant. Being continuously invariant
means that, instead of having fixed transformations $\Phi$ and $\Psi$,
we have two families of transformations, $\Phi_\epsilon$ and
$\Psi_\epsilon$, differentiably indexed by a real parameter
$\epsilon$, such that $\Phi_0$ and $\Psi_0$ are the identity function.

\begin{theorem}[Noether]
  If the action
  \begin{displaymath}
    \mathcal{S}[q;a;b] = \int_a^b L(t,q(t),\dot{q}(t))~dt
  \end{displaymath}
  is invariant under $\epsilon$-indexed families of transformations
  $\Phi_\epsilon$ and $\Psi_\epsilon$, then the equation
  \begin{equation}
    \label{eq:conservation-law}
    \frac{d}{dt}\left(\sum_{i=1}^n \frac{\partial L}{\partial \dot{q_i}}\psi_i + \left(L - \sum_{i=1}^n \dot{q_i}\frac{\partial L}{\partial \dot{q_i}}\right) \phi \right) = 0
  \end{equation}
  holds for all paths $q$ satisfying the Euler-Lagrange equations
  (\ref{eq:euler-lagrange}), where $\psi = \left. \frac{\partial
      \Psi}{\partial \epsilon} \right|_{\epsilon = 0}$ and $\phi =
  \left. \frac{\partial \Phi}{\partial \epsilon} \right|_{\epsilon =
    0}$.
\end{theorem}

\begin{proof}
  E.g., Gelfand and Fomin \cite{gelfandXXcalculus}, Section 20.
\end{proof}

\begin{example}
  In Example~\ref{ex:invariance-examples}, we noted that the
  Lagrangians (\ref{eq:coupled-spring-lagrangian}) and
  (\ref{eq:simple-g-lagrangian}) are both invariant under arbitrary
  translations in time. In terms of continuous invariance, their
  corresponding actions are invariant under the families
  $\Phi_\epsilon(t) = t + \epsilon$ and $\Psi_\epsilon(q) =
  q$. Plugging these definitions into
  Equation~(\ref{eq:conservation-law}), we learn that, for these
  systems:
  \begin{displaymath}
    \frac{d}{dt}~\left(L - \sum_{i=1}^2 \dot{q_i}\frac{\partial L}{\partial \dot{q_i}} \right) = 0
  \end{displaymath}
  For the spring-coupled particles Lagrangian,
  (\ref{eq:coupled-spring-lagrangian}), we obtain:
  \begin{displaymath}
    \frac{d}{dt}~\left(\frac{1}{2}m(\dot{x_1}^2 + \dot{x_2}^2) + \frac{1}{2}k(x_1 - x_2)^2 \right) = 0
  \end{displaymath}
  and for the single particle under gravity Lagrangian
  (\ref{eq:simple-g-lagrangian}), we obtain:
  \begin{displaymath}
    \frac{d}{dt}~\left(\frac{1}{2}m(\dot{x}^2 + \dot{y}^2) + mgy\right) = 0
  \end{displaymath}
  In both cases, we have discovered that, as a consequence of
  invariance under translation in time, the total energy of the system
  is conserved (note that the $-$ signs in the original Lagrangians
  have turned into $+$s). In general, invariance under translation in
  time implies, via Noether's theorem, conservation of energy.
\end{example}

This finishes our short introduction to Lagrangian mechanics and
Noether's theorem. We have shown how Noether's theorem can be used to
derive conservation laws from invariance properties. We now go on to
showing how suitable invariance properties can be derived from types,
building towards Section~\ref{sec:types-for-classical-mech}, where we
construct a type system for writing Lagrangians that expresses
invariance properties directly in the types. In
Section~\ref{sec:examples}, we give examples of invariant Lagrangians
and their consequent conservation laws.

\section{Invariance from Types}
\label{sec:symmetry-from-types}

We derive invariance properties from types by constructing a
relationally parametric model of System F$\omega$, which we then
extend with suitable kind-, type-, and term-level constants for
writing invariant Lagrangians. Our relationally parametric model is
based on the reflexive graph model presented by
Atkey~\cite{atkey12relational} (based on previous work on reflexive
graph models of relational parametricity by Robinson and
Rosolini~\cite{robinson94} and Hasegawa~\cite{hasegawa94}). In
reflexive graph models of relational parametricity, the kinds of
System F$\omega$ are interpreted as reflexive graphs, while types are
interpreted as morphisms of reflexive graphs. As demonstrated by
Atkey, uniformly interpreting kinds as reflexive graphs allows for a
straightforward interpretation of higher kinds like $* \to *$. In the
present setting, reflexive graphs will allow us to accomodate
arbitrary groupoids as kinds
(Section~\ref{sec:groupoid-kinds}). Groupoid kinds are the key
technical tool that we need to derive the kinds of geometric
invariance properties we need for Noether's theorem.

\subsection{System F$\omega$: Syntax and Relationally Parametric Model}
\label{sec:refl-graphs-for-fomega}

We now present the syntax and relationally parametric semantics of
System F$\omega$. Since we will incrementally extend the syntax of the
system throughout this section and the next, we do not state a final
triple of theorems stating that we have correctly interpreted kinds,
types and terms. Rather, we state the necessary properties of the
interpretation as three separate properties
(Properties~\ref{property:semantic-kinds},
\ref{property:semantic-types}, and~\ref{property:semantic-terms},
below), and maintain them as we extend the system.

We deviate from the standard presentation of System F$\omega$ in that
we distinguish between large and small kinds, and only allow
quantification over small kinds. In particular, the kind of types $*$
is \emph{not} small. The reason for this is that we desire a simple
set-theoretic model. However, requiring that we have a set of sets
closed under large products, in order to interpret quantification over
the kind $*$, would force us to use an intuitionistic metatheory
\cite{pitts}. The basic results of the calculus of variations that we
are relying on, such as the derivation of the Euler-Lagrange
equations, use excluded middle in their proofs, so an intuitionistic
metatheory is not an option. We therefore just assume that we have a
set of ``small'' sets, which includes the real numbers and is closed
under subsets, products, function space and comprehension.

\paragraph{Syntax} The kinds of System F$\omega$ include at least the
base kind of types, $*$, and function and product kinds, as generated
by the following grammar:
\begin{displaymath}
  \kappa ::= * \sepbar \kappa_1 \to \kappa_2 \sepbar \kappa_1 \times \kappa_2 \sepbar \cdots
\end{displaymath}
We will extend the collection of kinds in
Section~\ref{sec:discrete-kinds} with type-level natural numbers, and
in Section~\ref{sec:groupoid-kinds}

We use the judgement $\kappa~\mathrm{small}$ to denote when the kind
$\kappa$ will be interpreted by a small reflexive graph (to be defined
below). The kind $*$ is not small, but the construction of function
and product kinds preserves smallness:
\begin{mathpar}
  \inferrule*
  {\kappa_1~\mathrm{small} \\ \kappa_2~\mathrm{small}}
  {\kappa_1 \to \kappa_2~\mathrm{small}}

  \inferrule*
  {\kappa_1~\mathrm{small} \\ \kappa_2~\mathrm{small}}
  {\kappa_1 \times \kappa_2~\mathrm{small}}
\end{mathpar}
The additional kinds we introduce below will all be small.

The well-kinded types, type equalities, and well-typed terms of System
F$\omega$ are shown in Figures~\ref{fig:types},
\ref{fig:type-equality} and~\ref{fig:terms}, respectively. Note that
typing contexts $\Gamma$ only contain well-kinded types of kind
$*$. Terms also have an equational theory, with $\beta\eta$-laws for
functions, products, and universal quantification, which we omit. Our
presentation of System F$\omega$ is entirely standard (see, e.g.,
Pierce~\cite{pierce01types}), except for the restriction to small
kinds in the formation of universal kinds $\forall
\alpha\mathord:\kappa. A$. As is the case for kinds, we will extend
the types, type equalities and terms in
Sections~\ref{sec:discrete-kinds},~\ref{sec:groupoid-kinds}
and~\ref{sec:types-for-classical-mech}, below.

\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule*
    {\alpha : \kappa \in \Theta}
    {\Theta \vdash \alpha : \kappa}

    \inferrule*
    {\Theta, \alpha : \kappa_1 \vdash A : \kappa_2}
    {\Theta \vdash \lambda \alpha : \kappa_1.\ A : \kappa_1 \to \kappa_2}

    \inferrule*
    {\Theta \vdash F : \kappa_1 \to \kappa_2 \\ \Theta \vdash A : \kappa_1}
    {\Theta \vdash F A : \kappa_2}

    \inferrule*
    {\Theta \vdash A : \kappa_1 \\ \Theta \vdash B : \kappa_2}
    {\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}

    \inferrule* [right=${i \in \{1,2\}}$]
    {\Theta \vdash A : \kappa_1 \times \kappa_2}
    {\Theta \vdash \pi_i~A : \kappa_i}

    \inferrule*
    {\Theta \vdash A : * \\ \Theta \vdash B : *}
    {\Theta \vdash A \times B : *}

    \inferrule*
    {\Theta \vdash A : * \\ \Theta \vdash B : *}
    {\Theta \vdash A \to B : *}

    \inferrule*
    {\Theta, \alpha : \kappa \vdash A : * \\ \kappa\textrm{ small}}
    {\Theta \vdash \forall\alpha\mathord:\kappa.\ A : *}
  \end{mathpar}
  \caption{Types and their Kinds}
  \label{fig:types}
\end{figure}

\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule* [right=$\beta$]
    {\Theta, \alpha : \kappa_1 \vdash A : \kappa_2 \\
      \Theta \vdash B : \kappa_1}
    {\Theta \vdash (\lambda \alpha : \kappa_1. A)~B \equiv A\{B/\alpha\} : \kappa_2}

    \inferrule* [right=$\eta$]
    {\Theta \vdash A : \kappa_1 \to \kappa_2}
    {\Theta \vdash (\lambda \alpha : \kappa_1.A~\alpha) \equiv A : \kappa_1 \to \kappa_2}

    \inferrule* [right=$\beta$]
    {\Theta \vdash A_1 : \kappa_1 \\ \Theta \vdash A_2 : \kappa_2}
    {\Theta \vdash \pi_i~\langle A_1, A_2 \rangle \equiv A_i : \kappa_i}

    \inferrule* [right=$\eta$]
    {\Theta \vdash A : \kappa_1 \times \kappa_2}
    {\Theta \vdash \langle \pi_1 A, \pi_2 A \rangle \equiv A : \kappa_1 \times \kappa_2}
  \end{mathpar}
  {\tiny plus: reflexivity, symmetry, transitivity and congruence}
  \caption{Type equality}
  \label{fig:type-equality}
\end{figure}

\begin{figure}[t]
  \centering
  \begin{mathpar}
    \inferrule*
    {x : A \in \Gamma}
    {\Theta \sepbar \Gamma \vdash x : A}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e : A \\ \Theta \vdash A \equiv B : *}
    {\Theta \sepbar \Gamma \vdash e : B}
  \end{mathpar}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : A_1 \\\\
      \Theta \sepbar \Gamma \vdash e_2 : A_2}
    {\Theta \sepbar \Gamma \vdash (e_1, e_2) : A_1 \times A_2}

    \inferrule* [right=${i \in \{1,2\}}$]
    {\Theta \sepbar \Gamma \vdash e : A_1 \times A_2}
    {\Theta \sepbar \Gamma \vdash \pi_i e : A_i}
  \end{mathpar}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma, x : A \vdash e : B}
    {\Theta \sepbar \Gamma \vdash \lambda x : A.\ e : A \to B}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : A \to B \\
      \Theta \sepbar \Gamma \vdash e_2 : A}
    {\Theta \sepbar \Gamma \vdash e_1 e_2 : B}

    \inferrule*
    {\Theta, \alpha : \kappa \sepbar \Gamma \vdash e : A \\ \alpha \not\in \mathit{fv}(\Gamma)}
    {\Theta \sepbar \Gamma \vdash \Lambda \alpha \mathord: \kappa.\ e : \forall \alpha \mathord:\kappa. A}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e : \forall \alpha\mathord:\kappa. A \\ \Theta \vdash B : \kappa}
    {\Theta \sepbar \Gamma \vdash e\ [B] : A\{B/\alpha\}}
  \end{mathpar}
  \caption{Terms and their Types}
  \label{fig:terms}
\end{figure}


\paragraph{Reflexive Graphs and the Interpretation of Kinds} We will
interpret every kind $\kappa$ is as a reflexive graph, which we now
define. A \emph{reflexive graph} is a triple $(O, R, \mathrm{id})$,
where $O$ is a large set of objects, $R : O \times O \to \Set$ assigns
a small set of directed `edges' to each pair of objects, and
$\mathrm{id} : \forall o \in O.~R(o,o)$ assigns a distinguished
`identity' edge from every object to itself. We think of the edges of
a reflexive graph as abstract ``relations'' between the
objects. Indeed, in the interpretation of the kind of types, $*$,
below, the edges will be exactly relations.

A \emph{small} reflexive graph is a reflexive graph $(O, R,
\mathrm{id})$ where $O$ is a small set of objects. We use small
reflexive graphs as the semantic interpretation of small kinds.

The interpretation of kinds as reflexive graphs, and small kinds as
small reflexive graphs is a key property of our semantics that we will
maintain as we add additional kinds in
Sections~\ref{sec:discrete-kinds} and~\ref{sec:groupoid-kinds},
below. We state this as Property~\ref{property:semantic-kinds} of our
semantics:

\begin{property}\label{property:semantic-kinds}
  Each kind $\kappa$ is interpreted as a reflexive graph
  $\sem{\kappa}$. If $\kappa~\mathrm{small}$, then $\sem{\kappa}$ is a
  small reflexive graph.
\end{property}

An appealing interpretation of reflexive graphs is as ``categories
without composition''. Following this intuition, we define morphisms
of reflexive graphs as ``functors'', without the preservation of
composition condition. A \emph{morphism of reflexive graphs}
$(O_1,R_1,\mathrm{id}_1)$ and $(O_2, R_2, \mathrm{id}_2)$ is a pair of
mappings $f : O_1 \to O_2$ and $r : \forall o, o' \in
O_1.~R_1(o,o') \to R_2(f~o, f~o')$ such that identities are
preserved: $r~o~o~(\mathrm{id}_1~o) = \mathrm{id}_2~(f~o)$. We use
morphisms of reflexive graphs below to interpret well-kinded types.

We will use the notation $-^O$, $-^R$ and $-^{\mathrm{id}}$ for the
first, second and third projections out of tuples representing
reflexive graphs. Similarly, we use $-^f$ and $-^r$ for the first and
second projections out of tuples representing reflexive graph
morphisms.

We now define the interpretations of the basic kinds of System
F$\omega$ we defined above, making sure that we maintain
Property~\ref{property:semantic-kinds}. At base kind, the collection
of objects is simply the type of all small sets; edges between $A$ and
$B$ are binary relations on $A$ and $B$ (i.e., subsets of $A \times
B$); and the distinguished identity edge is exactly the equality
relation:
\begin{displaymath}
  \sem{*} = (\Set, \Rel, \equiv)
\end{displaymath}
The reflexive graph $\sem{*}$ is not small, due to the collection of
all small sets $\Set$ not forming a small set.

For higher kinds $\kappa_1 \to \kappa_2$, the collection of objects
consists of reflexive graph morphisms from the interpretation of
$\kappa_1$ to the interpretation of $\kappa_2$; the edges between
morphisms $(f, r)$ and $(f', r')$ are edge transformers; and the
distinguished identity relation for $(f,r)$ is just $r$:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\kappa_1 \to \kappa_2} = \\
    \begin{array}[t]{l@{}l@{}}
      (& \{ (f,r) \sepbar (f, r) : \sem{\kappa_1} \to \sem{\kappa_2} \},\\
      &((f,r),(f',r')) \mapsto \forall o,o'. \semKR{\kappa_1}(o,o') \to \semKR{\kappa_2}(f~o, f'~o'), \\
      &(f,r) \mapsto r\ )
    \end{array}
  \end{array}
\end{displaymath}
By the assumption that our collection of small sets is closed under
the formation of function spaces and set comprehension, if
$\sem{\kappa_1}$ and $\sem{\kappa_2}$ are small reflexive graphs, then
so is $\sem{\kappa_1 \to \kappa_2}$.

Product kinds are interpreted by taking the product of their
interpretations as reflexive graphs:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\kappa_1 \times \kappa_2} = \\
    \begin{array}[t]{l@{}l}
      (& \semKU{\kappa_1} \times \semKU{\kappa_2}, \\
      & ((o_1,o_2),(o_1',o_2')) \mapsto \semKR{\kappa_1}(o_1,o_1') \times \semKR{\kappa_2}(o_2,o_2'), \\
      & (o_1,o_2) \mapsto (\semKI{\kappa_1}(o_1), \semKI{\kappa_2}(o_2)))
    \end{array}
  \end{array}
\end{displaymath}
The collection of objects of the interpretation of a product kind is
the product of the underlying collections of objects of the two parts,
and the relational component is simply the product of the relational
components. This naturally leads to the identity component being
defined as the tuple of the identity components of the two
parts. Again, by assumption that our collection of small sets is
closed under products, if $\sem{\kappa_1}$ and $\sem{\kappa_2}$ are
small reflexive graphs, then so is $\sem{\kappa_1 \times
  \kappa_2}$. Product kinds generalise to the interpretation of
kinding contexts $\Theta = \alpha_1 : \kappa_1, ..., \alpha_n :
\kappa_n$, which are interpreted as the product of the reflexive graph
interpretations of $\kappa_1, ..., \kappa_n$:
\begin{displaymath}
  \begin{array}{l}
    \sem{\alpha_1 : \kappa_1, ..., \alpha_n : \kappa_n} = \\
    \begin{array}[t]{l@{}l}
      (&\semKU{\kappa_1} \times ... \times \semKU{\kappa_n}, \\
      &(\theta,\theta') \mapsto \semKR{\kappa_1}(\pi_1\theta, \pi_1\theta') \times ... \times \semKR{\kappa_n}(\pi_n\theta, \pi_n\theta'), \\
      &\theta \mapsto (\semKI{\kappa_1}(\pi_1 \theta), ..., \semKI{\kappa_n}(\pi_n \theta)))
    \end{array}
  \end{array}
\end{displaymath}

In Sections~\ref{sec:discrete-kinds} and~\ref{sec:groupoid-kinds}
below, we will extend System F$\omega$ with additional kinds, and
assign them reflexive graph interpretations, making sure that we
maintain Property~\ref{property:semantic-kinds}.

\begin{figure*}[t]
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \sem{\Theta \vdash \alpha_i : \kappa_i}^f \theta & = & \pi_i \theta \\
      \sem{\Theta \vdash \alpha_i : \kappa_i}^r\theta\theta' \rho & = & \pi_i \rho \\
      \\
      \sem{\Theta \vdash \lambda \alpha \mathord: \kappa_1.~A : \kappa_1 \to \kappa_2}^f \theta & = & (
      \begin{array}[t]{@{}l}
        \lambda o \in \semKU{\kappa_1}.\ \sem{A}^f(\theta, o), 
        \lambda o, o' \in \semKU{\kappa_1}, r \in \semKR{\kappa_1}(o,o').\ \sem{A}^r(\theta,o)(\theta,o')(\semKI{\Theta}\theta, r))
      \end{array}\\
      \sem{\Theta \vdash \lambda \alpha \mathord: \kappa_1.~A : \kappa_1 \to \kappa_2}^r \theta\theta' \rho & = &
      \lambda o,o' \in \semKU{\kappa_1}, r \in \semKR{\kappa_1}(o,o').\ \sem{A}^r(\theta,o)(\theta',o')(\rho, r) \\
      \\
      \sem{\Theta \vdash F A : \kappa_2}^f \theta & = & \pi_1 (\sem{F}^f\ \theta)\ (\sem{A}^f\ \theta)\\
      \sem{\Theta \vdash F A : \kappa_2}^r\theta\theta'\rho & = & \sem{F}^r\theta\theta'\rho\ (\sem{A}^f \theta)(\sem{A}^f \theta')(\sem{A}^r\theta\theta'\rho) \\
      \\
      \sem{\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}^f \theta & = & (\sem{A}^f \theta, \sem{B}^f \theta) \\
      \sem{\Theta \vdash \langle A, B \rangle : \kappa_1 \times \kappa_2}^r \theta \theta' \rho & = & (\sem{A}^r \theta \theta' \rho, \sem{B}^r \theta \theta' \rho) \\
      \\
      \sem{\Theta \vdash \pi_i A : \kappa_i}^f \theta & = & \pi_i (\sem{A}^f \theta) \\
      \sem{\Theta \vdash \pi_i A : \kappa_i}^r \theta \theta' \rho & = & \pi_i (\sem{A}^r \theta \theta' \rho)
    \end{array}
  \end{displaymath}
  \caption{Interpretation of type-level $\lambda$-calculus as reflexive graph morphisms}
  \label{fig:type-level-lambda-calc}
\end{figure*}

\begin{figure*}[t]
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \sem{\Theta \vdash A \to B : *}^f \theta & = & \sem{A}^f\theta \to \sem{B}^f\theta \\
      \sem{\Theta \vdash A \to B : *}^r\theta\theta'\rho & = &
      \{ (f,f') \sepbar \forall (a,a') \in \sem{A}^r\theta\theta'\rho.\ (f~a, f'~a') \in \sem{B}^r\theta\theta'\rho \} \\
      \\
      \sem{\Theta \vdash A \times B : *}^f \theta & = & \sem{A}^f\theta \times \sem{B}^f\theta \\
      \sem{\Theta \vdash A \times B : *}^r\theta\theta'\rho & = &
      \{ ((a,b),(a',b')) \sepbar (a,a') \in \sem{A}^r\theta\theta'\rho, (b,b') \in \sem{B}^r\theta\theta'\rho \} \\
      \\
      \sem{\Theta \vdash \forall \alpha\mathord:\kappa.~A : *}^f \theta &=& \{
      \begin{array}[t]{@{}l}
        x \in (\forall o \in \semKU{\kappa}.\ \sem{A}^f(\theta, o)) \sepbar
        \forall o,o',r \in \semKR{\kappa}(o,o').\ (x~o, x~o') \in \sem{A}^r(\theta,o)(\theta,o')(\semKI{\Theta} \theta, r) \}
      \end{array} \\
      \sem{\Theta \vdash \forall \alpha\mathord:\kappa.~A : *}^r\theta\theta'\rho &=& \{ (x,x') \sepbar \forall o, o', r \in \semKR{\kappa}(o,o').\ (x~o, x'~o') \in \sem{A}^r(\theta,o)(\theta',o')(\rho, r) \}
    \end{array}
  \end{displaymath}
  \caption{Interpretation of basic types as reflexive graph morphisms}
  \label{fig:basic-type-interpretation}
\end{figure*}

\paragraph{Interpretation of Types} Well-kinded types $\Theta \vdash A
: \kappa$ from Figure~\ref{fig:types} are interpreted as reflexive
graph morphisms $\sem{A} : \sem{\Theta} \to \sem{\kappa}$. We sum this
up as a property of our semantics:
\begin{property}\label{property:semantic-types}
  Each well-kinded type $\Theta \vdash A : \kappa$ is interpreted as a
  reflexive graph morphism $\sem{A} : \sem{\Theta} \to \sem{\kappa}$,
  such that if $\Theta \vdash A \equiv B : \kappa$, then $\sem{A} =
  \sem{B}$.
\end{property}
%
% That is, every well-kinded type is interpreted as a pair $(\sem{A}^f,
% \sem{A}^r)$ of functions $\sem{A}^f : \sem{\Theta}^O \to
% \sem{\kappa}^O$ and $\sem{A}^r : \forall o, o'.~\sem{\Theta}^R(o,o')
% \to \sem{\kappa}^R(\sem{A}^f~o, \sem{A}^f~o')$, such that identity
% edges are preserved.
%
The interpretation of the $\lambda$-calculus fragment (i.e.,
variables, $\lambda$-abstraction and application, and products) of the
language of well-kinded types is displayed in
Figure~\ref{fig:type-level-lambda-calc}. The interpretations are
unsurprising given the reflexive graph interpretation of the kinds
$\kappa_1 \to \kappa_2$ and $\kappa_1 \times \kappa_2$ we gave above.

Figure~\ref{fig:basic-type-interpretation} shows the interpretations
of the basic type constructors for function and product types, and
universal quantification. Each of these constructs builds an object of
kind $*$, so the object-level interpretation is a small set in $\Set$,
and the relation-level interpretation is an actual relation. In the
cases of the function and product types, the object-level
interpretation is just as set-theoretic function and product
respectively, and the relation-level interpretation uses the standard
logical relations interpretations of these type
constructors. Universal quantification, $\forall
\alpha\mathord:\kappa.~A$, is interpreted at the object level by
taking the dependent product over the objects of the interpretation of
$\kappa$ (this product exists because we have stipulated that $\kappa$
must be small), and then restricting to those elements of the
dependent product that preserve relations. This restriction is
required for this interpretation to preserve identity edges, and so be
a reflexive graph morphism. The relation-level interpretation of
universal quantification is the standard relational interpretation of
such types, albeit here generalised to kinds interpreted as arbitrary
reflexive graphs.

Well-kinded typing contexts $\Theta \vdash \Gamma$ are interpreted as
reflexive graph morphisms $\sem{\Gamma} : \sem{\Theta} \to \sem{*}$ by
taking the product of the interpretations of their constituent types,
similar to the interpretation of the product types $A \times B$.

We will extend basic System F$\omega$ with additional types and type
equalities in Sections~\ref{sec:discrete-kinds},
\ref{sec:groupoid-kinds}, and~\ref{sec:types-for-classical-mech},
below. These new types will also be assigned interpretations as
reflexive graph morphisms, and we will ensure that
Property~\ref{property:semantic-types} is maintained.

\paragraph{Interpretation of Terms} We omit the straightforward and
relatively uninteresting interpretation of well-typed terms $\Theta
\sepbar \Gamma \vdash e : A$, and just state that there is a
well-defined function interpreting each well-typed term, with the
property that it takes related environments to related results, this
is the fundamental theorem of logical relations for System F$\omega$:

\begin{property}\label{property:semantic-terms}
  For all well-typed terms $\Theta \sepbar \Gamma \vdash e : A$ there
  is a function $\sem{e} \in (\forall \theta \in \semKU{\Theta}.\
  \sem{\Gamma}^f\theta \to \sem{A}^f\theta)$, such that, for all
  $\theta, \theta' \in \semKU{\Theta}$, $\rho \in
  \semKR{\Theta}(\theta,\theta')$, $\gamma \in \sem{\Gamma}^f\theta$
  and $\gamma' \in \sem{\Gamma}^f\theta'$, if $(\gamma, \gamma') \in
  \sem{\Gamma}^r\theta\theta'\rho$ then $(\sem{e}\theta\gamma,
  \sem{e}\theta'\gamma') \in \sem{A}^r\theta\theta'\rho$.  Moreover,
  this interpretation is sound for the $\beta\eta$ equational theory
  of terms.
\end{property}

\subsection{Discrete Kinds}
\label{sec:discrete-kinds}

In Section~\ref{sec:refl-graphs-for-fomega}, we only had a single base
kind: the kind $*$ of proper types, with a specific interpretation as
the reflexive graph of sets and relations. We now describe two
families of base kinds with interpretations that are particular sorts
of reflexive graph. In this section, we look at discrete kinds; kinds
whose reflexive graph interpretations are such that the reflexive
edges are the only edges between objects. In the following section
(Section~\ref{sec:groupoid-kinds}), we look at groupoid kinds, where
edges are composable and invertible.

Discrete kinds can be seen as the natural way of lifting types up to
the kind level. For our purposes, we will only require a kind of
natural numbers, which we will use for constructing $n$-ary vectors of
positions and velocities when we use our type system for writing
Lagrangians in Section~\ref{sec:types-for-classical-mech}. The kind of
natural numbers is small:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{nat}

  \inferrule*
  { }
  {\mathsf{nat}~\mathrm{small}}
\end{mathpar}
The interpretation of this kind as a reflexive graph goes as follows:
\begin{displaymath}
  \sem{\mathsf{nat}} = (\mathbb{N}, (n_1,n_2) \mapsto \{ * \sepbar n_1 = n_2 \}, n \mapsto *)
\end{displaymath}
The collection of objects of this reflexive graph is simply the set of
natural numbers. The only edges in the graph are unique edges between
equal numbers. Since we have assumed that our collection of small sets
contains the natural numbers, we have clearly maintained
Property~\ref{property:semantic-kinds} of our semantics.

We add new type-level constructs for the kind $\mathsf{Nat}$ of
natural numbers, representing zero and successor, and a kind-generic
recursion operator:
\begin{mathpar}
  \inferrule*
  { }
  {\Theta \vdash \mathit{zero} : \mathsf{nat}}

  \inferrule*
  {\Theta \vdash A : \mathsf{nat}}
  {\Theta \vdash \mathit{succ}~A : \mathsf{nat}}

  \inferrule*
  {\Theta \vdash A : \mathsf{nat} \\
    \Theta \vdash B : \kappa \\
    \Theta \vdash C : \kappa \to \kappa}
  {\Theta \vdash \mathit{natrec}_\kappa~A~B~C : \kappa}
\end{mathpar}
These three constructs all have the evident interpretations in terms
of the inductive structure of the natural numbers, and satisfy the
following $\beta$-laws, maintaining
Property~\ref{property:semantic-types} of our semantics:
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathit{natrec}_\kappa~\mathit{zero}~B~C & \equiv & B \\
    \mathit{natrec}_\kappa~(\mathit{succ}~A)~B~C & \equiv & C~(\mathit{natrec}_\kappa~A~B~C)
  \end{array}
\end{displaymath}


\subsection{Groupoid Kinds}
\label{sec:groupoid-kinds}

Discrete kinds are useful for lifting types up to the kind level, but
they do not really exploit the flexibility of reflexive
graphs. Moreover, they do not provide us with the invariance
properties we require to apply Noether's theorem. By considering kinds
whose interpretations are groupoids, we will be able to derive the
invariance properties that we need.

Recall that a groupoid is a category in which all morphisms have
inverses \cite{maclane98categories}. Functors between categories
always preserve isomorphisms, so morphisms of groupoids are just
functors. Every group is a groupoid with one object and a morphism for
every element of the group: composition is the group operation,
inverses are given by the group inverses, and the identity morphism is
given by the group unit. Homomorphisms between groups are in
one-to-one correspondence with functors between the corresponding
groupoids. An example of a groupoid that is not a group is given by
the collection of cartesian spaces (i.e., $\mathbb{R}^n$ for some
$n$), with all diffeomorphisms (smooth invertible functions) as the
morphisms.

Trivially, every groupoid is a reflexive graph, simply by forgetting
the composition and inverses. Likewise, every functor between
groupoids is a morphism of reflexive graphs, by forgetting the
preservation of composition. Therefore, given any groupoid, we can add
a new kind to System F$\omega$ that is interpreted by that groupoid,
and given any functor $f : \sem{\mathsf{G_1}} \to \sem{\mathsf{G_2}}$
between groupoids interpreting kinds $\mathsf{G_1}$ and
$\mathsf{G_2}$, we obtain a type constant of kind $\mathsf{G_1} \to
\mathsf{G_2}$, with interpretation $f$.

\paragraph{Integers} Our first groupoid kind is $\mathsf{Z}$,
interpreted by additive group of integers. We will use this kind to
state the types of the trigonometric functions $\sin$ and $\cos$ in
Section~\ref{sec:types-for-classical-mech-1}, which are periodic with
period $2\pi$. The kind $\mathsf{Z}$ is small:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{Z}

  \inferrule*{ }{\mathsf{Z}~\mathrm{small}}
\end{mathpar}
The kind $\mathsf{Z}$ has the following interpretation as a reflexive
graph:
\begin{displaymath}
  \sem{\mathsf{Z}} = (\{*\}, \lambda *, *.~\mathbb{Z}, \lambda \mathord*.~0)
\end{displaymath}
Note the difference between this interpretation, and the
interpretation of the kind $\mathsf{Nat}$ in the previous section. In
the interpretation of $\mathsf{Nat}$, the objects were complex and the
relations were trivial. The reflexive graph interpreting $\mathsf{Z}$
has a trivial collection of objects, but a rich structure at the
relation level, given by the group of integers. This structure means
that we can add the following type-level constants to our system:
\begin{mathpar}
  \inferrule*
  { }
  {\Theta \vdash 0 : \mathsf{Z}}

  \inferrule*
  {\Theta \vdash A : \mathsf{Z} \\ \Theta \vdash B : \mathsf{Z}}
  {\Theta \vdash A + B : \mathsf{Z}}

  \inferrule*
  {\Theta \vdash A : \mathsf{Z}}
  {\Theta \vdash -A : \mathsf{Z}}
\end{mathpar}
Each of these constants has a trivial object-level interpretation, due
to the trivial collection of objects in the reflexive graph
$\sem{\mathsf{Z}}$. At the relation-level, the interpretations are
simply given using the group structure of the integers. These
interpretations satisfy the abelian group axioms, so we add these
axioms to the type-level equations.

\paragraph{Translation and Matrix Groups} The group of integers is not
suitable for stating the invariance properties we require to apply
Noether's theorem. To do so, we require groups of translations and
invertible linear transformations. We extend our type system with
small kinds representing $n$-dimensional ($n \geq 0$) translations,
invertible linear transformations, and orthogonal transformations:
\begin{mathpar}
  \kappa ::= \cdots \sepbar \mathsf{T}(n) \sepbar \mathsf{GL}(n) \sepbar \mathsf{O}(n)

  \inferrule*{ }{\mathsf{T}(n), \mathsf{GL}(n), \mathsf{O}(n)~\mathrm{small}}
\end{mathpar}
The interpretations of these kinds follow the same pattern as for the
kind $\mathsf{Z}$ above. Each interpretation is a reflexive graph with
a trivial collection of objects, and relations taken from the
appropriate group:
\begin{displaymath}
  \begin{array}{@{}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\mathsf{T}(n)} &=& (\{*\}, \lambda *,*.~\mathbb{R}^n, \lambda \mathord*.~\vec{0}) \\
    \sem{\mathsf{GL}(n)} &=& (\{*\}, \lambda *,*.~\mathrm{GL}(n), \lambda \mathord*. I) \\
    \sem{\mathsf{O}(n)} &=& (\{*\}, \lambda *,*.~\mathrm{O}(n), \lambda \mathord*. I)
  \end{array}
\end{displaymath}
We add the group operations and group axioms for each of these
groupoid kinds in the same way as we did for the kind $\mathsf{Z}$
above, except that we use multiplicative notation for the kinds
$\mathsf{GL}(n)$ and $\mathsf{O}(n)$. Note that, except for
$\mathsf{GL}(1)$, the groups $\mathsf{GL}(n)$ and $\mathsf{O}(n)$ are
not abelian.

We also extend our type system with the following type-level
constants. Each of these is interpreted by the correspondingly named
homomorphism between the groups involved. For example,
$\mathit{scale}_n$ is interpreted by the homomorphism $\mathrm{GL}(1)
\to \mathrm{GL}(n)$ that takes a non-zero real number $s$ to the
matrix with $s$s along the diagonal and zeros elsewhere.
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathit{exp} &:& \mathsf{T}(1) \to \mathsf{GL}(1) \\
    \mathit{ortho}_n &:& \mathsf{O}(n) \to \mathsf{GL}(n) \\
    \mathit{scale}_n &:& \mathsf{GL}(1) \to \mathsf{GL}(n) \\
    \underline{c}*- &:& \mathsf{Z} \to \mathsf{T}(1) 
  \end{array}
\end{displaymath}
In the last of these $\underline{c}$ stands for an arbitrary real
constant.  Since each of these is interpreted by a group homomorphism,
we are justified in adding the group homomorphism laws as axioms to
our type-level equational theory, maintaining
Property~\ref{property:semantic-types}.

\paragraph{The Groupoid of Cartesian Spaces} Finally in this section,
we introduce the groupoid kind of cartesian spaces, which we will use
for the configuration spaces of the classical mechanical systems we
describe in our system. As we noted above, the collection of cartesian
spaces is a groupoid with a non-trivial collection of objects. We
extend our system with a kind of cartesian spaces:
\begin{displaymath}
  \kappa ::= \cdots \sepbar \mathsf{CartSp}
\end{displaymath}
with the following interpretation:
\begin{displaymath}
  \begin{array}{@{}l}
    \sem{\mathsf{CartSp}} = \\
    \quad (\mathbb{N}, \lambda m,n.~\{ f : \mathbb{R}^m \to \mathbb{R}^n \sepbar f\textrm{ a diffeomorphism}\}, \lambda n.~\mathrm{id}_{\mathbb{R}^n})
  \end{array}
\end{displaymath}
We have chosen to represent cartesian spaces of dimension $n$ just as
the natural number $n$. This gives us a canonical representation of
$n$-dimensional space for each $n$, avoids tricky problems with
isomorphic constructions of the same space.

Cartesian spaces are closed under taking their product:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp} \\ \Theta \vdash Y : \mathsf{CartSp}}
  {\Theta \vdash X \times Y : \mathsf{CartSp}}
\end{displaymath}
with the following interpretation, where the cartesian product of
cartesian spaces adds their dimensions, and composes diffeomorphisms
``in parallel'':
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{X \times Y}^f \theta & = & \sem{X}^f \theta + \sem{Y}^f \theta \\
    \sem{X \times Y}^r \theta \theta' \rho & = & \lambda (\vec{x},\vec{y}).~(\sem{X}^r\theta\theta'\rho \vec{x}, \sem{Y}^r\theta\theta'\rho \vec{y})
  \end{array}
\end{displaymath}

Cartesian spaces are generated by the following construct that yields
the $n$-dimensional cartesian space ($n \geq 0$) that varies with the
given invertible linear transformation and translation:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash G : \mathsf{GL}(n) \\ \Theta \vdash T : \mathsf{T}(n)}
  {\Theta \vdash \mathbb{R}^n\langle G, T \rangle : \mathsf{CartSp}}
\end{displaymath}
As a notational convenience, we write $\mathbb{R}^1\langle G, T
\rangle$ as just $\mathbb{R}\langle G, T \rangle$ and
$\mathbb{R}^0\langle G, T \rangle$ as just $\mathbb{R}^0$.

The type $\mathbb{R}^n\langle G, T \rangle$ has the following
interpretation as a reflexive graph morphism:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\mathbb{R}^n\langle G, T \rangle}^f \theta & = & n \\
    \sem{\mathbb{R}^n\langle G, T \rangle}^r \theta \theta' \rho & = & \lambda \vec{x}.~(\sem{G}^r \theta \theta' \rho) \vec{x} + \sem{T}^r \theta \theta' \rho
  \end{array}
\end{displaymath}
Note that $\sem{\mathbb{R}^n\langle G, T \rangle}^r \theta \theta'
(\semKI{\Theta}\theta)$ is the identity diffeomorphism, so this
interpretation preserves identity edges, exactly as required in the
definition of reflexive graph morphisms. Consequently, the
interpretation of $\mathbb{R}^n\langle G, T \rangle$, and also the
interpretation for products of cartesian spaces, preserves
Property~\ref{property:semantic-types}.

Finally, we include an operator that takes any cartesian space to
its corresponding proper type:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp}}
  {\Theta \vdash \typeOfCartSp{X} : *}
\end{displaymath}
with the following straightforward interpretation:
\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{\typeOfCartSp{X}}^f\theta & = & \mathbb{R}^{\sem{X}^f\theta} \\
    \sem{\typeOfCartSp{X}}^r\theta\theta'\rho & = & \{ (\vec{x}, \vec{x'}) \sepbar (\sem{X}^r\theta\theta'\rho)\vec{x} = \vec{x'} \}
  \end{array}
\end{displaymath}



% \subsection{Why not Groupoids Everywhere?}

% Given that we crucially use groupoid kinds in our model in order 

% Explain why we aren't using groupoids as kinds: don't need to, doesn't
% directly generalise relational parametricity, see Robinson's
% paper. Distance-indexed types.

\section{A Type System for Classical Mechanics}
\label{sec:types-for-classical-mech}

In the previous section we constructed a way to derive invariance
properties from types. In
Section~\ref{sec:conservation-laws-from-symmetry}, we saw that
Noether's theorem is a method for deriving conservation laws for
classical mechanical systems from their invariance properties. In this
section, we construct a type system for constructing invariant
Lagrangians. In the following section, Section~\ref{sec:examples}, we
present several uses of our type system for defining invariant
Lagrangians that describe many different kinds of classical mechanical
systems.

\subsection{Extending System F$\omega$ with Smooth Functions}
\label{sec:types-for-classical-mech-1}

\paragraph{The Type of Smooth Functions} Given a pair of cartesian
spaces $X$ and $Y$ we provide a way to construct the type of smooth
invariant smooth functions from $X$ to $Y$:
\begin{displaymath}
  \inferrule*
  {\Theta \vdash X : \mathsf{CartSp} \\
    \Theta \vdash Y : \mathsf{CartSp}}
  {\Theta \vdash C^\infty(X, Y) : *}
\end{displaymath}
with the following interpretation. Since $C^\infty(X,Y)$ is a proper
type, the relational interpetation in this case is a genuine
relation. We relate functions that are invariant under the
diffeomorphism interpretations of $X$ and $Y$ in the current
relational context $\rho$:
\begin{displaymath}
  \begin{array}{@{\hspace{0.05em}}l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sem{C^\infty(X,Y)}^f\theta & = & \{ f : \mathbb{R}^{\sem{X}^f\theta} \to \mathbb{R}^{\sem{Y}^f\theta} \sepbar f\textrm{ smooth} \} \\
    \sem{C^\infty(X,Y)}^f\theta\theta'\rho & = & \{
    \begin{array}[t]{@{}l}
      (f,f') \sepbar \forall \vec{x} \in \mathbb{R}^{\sem{X}^f\theta}.\\
      \quad (\sem{Y}^r\theta\theta'\rho)(f~\vec{x}) = f'~(\sem{X}^r\theta\theta'\rho \vec{x}) \}
    \end{array}
  \end{array}
\end{displaymath}

\paragraph{An Example Free Theorem} We are now in a position to
formally show how we can use the relationally parametric model we have
defined to derive invariance properties. Consider a closed term with
the following type:
\begin{displaymath}
  e : \forall o : \mathsf{O}(n).~C^\infty(\mathbb{R}^n\langle \mathit{ortho}_n(o), 0 \rangle, \mathbb{R}\langle 1, 0 \rangle)
\end{displaymath}
We can deduce, from Property~\ref{property:semantic-terms} and the
relational interpretations of all the types involved, that the
denotation of $e$ satisfies the following free theorem:
\begin{displaymath}
  \forall O \in \mathrm{O}(n).~\forall \vec{x} \in \mathbb{R}^n.~\sem{e}(O\vec{x}) = \sem{e}(\vec{x})
\end{displaymath}
This free theorem is exactly the kind of invariance property we
require to apply Noether's theorem. Compare the form of the statement
here, with the mildly more general statement of
Equation~\ref{eq:simplest-invariance}, back in
Section~\ref{sec:conservation-laws-from-symmetry}. Moreover, $\sem{e}$
is a smooth function from $\mathbb{R}^n$ to $\mathbb{R}$, just we
require to for Lagrangian mechanics.

\paragraph{Combinators for Smooth Functions} Of course, such free
theorems are pointless without ways to build elements of the smooth
function spaces. We now extend our type system, for the last time,
with a set of term-level constants for constructing smooth functions,
invariant under linear transformations and translations.

FIXME: Administrative things: composition, products

\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \mathrm{const} &:& \typeOfCartSp{Y} \to C^\infty(X, Y) \\
    \mathrm{pair} &:& C^\infty(X,Y) \to C^\infty(X,Z) \to C^\infty(X, Y \times Z) \\
    \mathrm{proj_1}&:& C^\infty(X \times Y, X) \\
    \mathrm{proj_2}&:& C^\infty(X \times Y, Y) \\
    (\comp) &:& C^\infty(X,Y) \to C^\infty(Y,Z) \\
    \mathrm{id} &:& C^\infty(X,X)
  \end{array}
\end{displaymath}

FIXME: vector spacey things

\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \underline{\vec{x}} &:& \typeOfCartSp{\mathbb{R}^n\langle 1, 0 \rangle} \\
    0 &:& \forall g \mathord: \mathsf{GL}(n).~\typeOfCartSp{\mathbb{R}^n\langle g, 0 \rangle} \\
    (+) &:&
    \begin{array}[t]{@{}l}
      \forall g \mathord: \mathsf{GL}(n), t_1,t_2 \mathord: \mathsf{T}(n). \\
      \hspace{1.5cm} C^\infty(\mathbb{R}^n\langle g, t_1 \rangle \times \mathbb{R}^n\langle g, t_2 \rangle, \mathbb{R}^n\langle g, t_1 + t_2 \rangle)\\
    \end{array} \\
    (-) &:&
    \begin{array}[t]{@{}l}
      \forall g \mathord: \mathsf{GL}(n), t_1,t_2 \mathord: \mathsf{T}(n). \\
      \hspace{1.5cm} C^\infty(\mathbb{R}^n\langle g, t_1 \rangle \times \mathbb{R}^n\langle g, t_2 \rangle, \mathbb{R}^n\langle g, t_1 - t_2 \rangle)\\
    \end{array} \\
    (*) &:& FIXME \\
    (\cdot) &:& FIXME \\
  \end{array}
\end{displaymath}

FIXME: trigonometic functions, and exponentials.

\begin{displaymath}
  \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
    \sin &:& \forall z \mathord: \mathsf{Z}.~C^\infty(\mathbb{R}\langle 1, \underline{2\pi} z \rangle, \mathbb{R} \langle 1, 0 \rangle) \\
    \cos &:& \forall z \mathord: \mathsf{Z}.~C^\infty(\mathbb{R}\langle 1, \underline{2\pi} z \rangle, \mathbb{R} \langle 1, 0 \rangle) \\
    \mathrm{exp} &:& \forall t \mathord: \mathsf{T}(1).~C^\infty(\mathbb{R}\langle 1, t \rangle, \mathbb{R}\langle \mathit{exp}~t, 0 \rangle) \\
  \end{array}
\end{displaymath}

FIXME: division, excusing the partiality

\begin{displaymath}
  (/) : \forall 
\end{displaymath}

FIXME: sum and cross

\subsection{A Surface Syntax for Smooth Functions}
\label{sec:surface-syntax}

\begin{figure*}[t]
  \centering
  \textbf{Administrative rules}
  \begin{mathpar}
    \inferrule*
    {z : \typeOfCartSp{X} \in \Gamma}
    {\Theta \sepbar \Gamma; \Delta \vdash z : X}

    \inferrule*
    {x : X \in \Delta}
    {\Theta \sepbar \Gamma; \Delta \vdash x : X}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : X_1 \times ... \times X_n \\
      \Theta \sepbar \Gamma; \Delta, x_1 : X_1, ..., x_n : X_n \vdash e_2 : Y}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{let}~x_1, ..., x_n = e_1~\mathrm{in}~e_2 : Y}

    \inferrule*
    {\Theta \sepbar \Gamma \vdash e_1 : C^\infty(X, Y) \\\\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : X}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 (e_2) : Y}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : X \\
      ... \\
      \Theta \sepbar \Gamma; \Delta \vdash e_n : X_n}
    {\Theta \sepbar \Gamma; \Delta \vdash (e_1, ..., e_n) : X_1 \times ... \times X_n}
  \end{mathpar}

  \medskip
  \textbf{Vector space operations, and dot product}
  \begin{mathpar}
    \inferrule*
    {\vec{x} \in \mathbb{R}^n}
    {\Theta \sepbar \Gamma; \Delta \vdash \vec{x} : \mathbb{R}^n\langle 1, 0 \rangle}

    \inferrule*
    {\Theta \vdash g : \mathsf{GL}(n)}
    {\Theta \sepbar \Gamma; \Delta \vdash 0 : \mathbb{R}^n\langle g, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle g, t_1 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle g, t_2 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 + e_2 : \mathbb{R}^n\langle g, t_1 + t_2 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle g, t_1 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle g, t_2 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 - e_2 : \mathbb{R}^n\langle g, t_1 - t_2 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}\langle g_1, 0 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle g_2, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 * e_2 : \mathbb{R}^n\langle \mathit{scale}_n(g_1)g_2, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 : \mathbb{R}^n\langle \mathit{scale}_n(s)\mathit{ortho}_n(o), 0 \rangle \\
      \Theta \sepbar \Gamma; \Delta \vdash e_2 : \mathbb{R}^n\langle \mathit{scale}_n(s)\mathit{ortho}_n(o), 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash e_1 \cdot e_2 : \mathbb{R}\langle\mathit{scale}_n(s)^n, 0 \rangle}
  \end{mathpar}

  \medskip
  \textbf{Transcendental functions}
  \begin{mathpar}
    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 1, t \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{exp}~e : \mathbb{R}\langle \mathit{exp}~t, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 2\pi z, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{sin}~e : \mathbb{R}\langle 1, 0 \rangle}

    \inferrule*
    {\Theta \sepbar \Gamma; \Delta \vdash e : \mathbb{R}\langle 2\pi z, 0 \rangle}
    {\Theta \sepbar \Gamma; \Delta \vdash \mathrm{cos}~e : \mathbb{R}\langle 1, 0 \rangle}
  \end{mathpar}
  FIXME: division, n-ary products (sum, zip, reduce)
  \caption{A surface syntax for smooth functions}
  \label{fig:smooth-terms}
\end{figure*}

\begin{figure}
  \centering
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      \elab{z}_\Delta & = & \mathrm{const}~z \\
      \elab{x}_\Delta & = & \mathrm{project}(x, \Delta) \\
    \end{array}
  \end{displaymath}
  \caption{Desugaring of the surface syntax}
  \label{fig:desugar}
\end{figure}

FIXME: define the translation

Define $\Delta$ and $\elab{\Delta}$.

Define project

\begin{theorem}
  If $\Theta |\Gamma; \Delta \vdash e : X$ then $\Theta \sepbar
  \Gamma \vdash \elab{e} : C^\infty(\elab{\Delta}, X)$.
\end{theorem}

\section{Examples of Conservation Laws from Types}
\label{sec:examples}

We now present a number of examples of classical mechanical systems
expressible in the type system we constructed in the previous section,
and derive the free theorems and consequent conserved properties for
each one. These examples are all standard examples demonstrating the
application of Lagrangian mechanics (see, for example, Landau and
Lifschitz \cite{landau60mechanics}). Our contribution here is to
express them in a type system that makes clear their invariance
properties.

\subsection{Single Particles}

% $- \sepbar V : \forall ... . C^\infty(\mathbb{R}^3\langle o, t \rangle, \mathbb{R}\langle 1, 0 \rangle); t : \mathbb{R}\langle 1, t_t \rangle, q : \mathbb{R}^3\langle o, t_q \rangle, \dot{q} : \mathbb{R}^3\langle o, 0 \rangle \vdash \frac{1}{2} * m * (\dot{q} \cdot \dot{q}) - V(q) : \mathbb{R}\langle 1, 0 \rangle$

\paragraph{Free Particle}

\paragraph{Particle in a Potential Field}

\subsection{$n$-Body Problems}

\paragraph{Two Bodies}

\paragraph{$n$-Bodies}

\subsection{Pendulums}

\paragraph{A single pendulum}

\paragraph{Coupled pendulum}

\paragraph{Pendulum on a Moving Base}

\paragraph{Pendulum on a Rotating Base}

No time translation invariance.

\subsection{Oscillators}

\paragraph{Coupled Particles} Our first example of a Lagrangian in the
introduction was of a pair of particles of equal mass coupled by a
spring.

\paragraph{Fixed Endpoint Oscillator} We now look at the slightly
simpler case of a single particle connected to a spring attached to a
fixed point.

\paragraph{Damped Oscillator}

\section{Conclusions}
\label{sec:conclusions}

FIXME: sum up what's happened

\paragraph{Related Work} We are not aware of any other work linking
type systems, programming languages or relational parametricity with
invariance properties for classical mechanics, or with Noether's
theorem. We have already mentioned the work of Atkey, Johann and
Kennedy \cite{atkey13abstraction} that uses 

\paragraph{Future Work}

\begin{enumerate}
\item Gauge theory
\item Quantum field theory
\item Dependent types
\item Homotopy type theory
\item Distance indexed types and differential privacy.
\item Languages with function spaces with more structure (Alex's
  Enriched Effect Calculus) (Idea for differential privacy)
\end{enumerate}

\end{document}
